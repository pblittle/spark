// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: spark.proto

package spark

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	common "github.com/lightsparkdev/spark/proto/common"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = common.SignatureIntent(0)
)

// define the regex for a UUID once up-front
var _spark_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on SubscribeToEventsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeToEventsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeToEventsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeToEventsRequestMultiError, or nil if none found.
func (m *SubscribeToEventsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeToEventsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdentityPublicKey

	if len(errors) > 0 {
		return SubscribeToEventsRequestMultiError(errors)
	}

	return nil
}

// SubscribeToEventsRequestMultiError is an error wrapping multiple validation
// errors returned by SubscribeToEventsRequest.ValidateAll() if the designated
// constraints aren't met.
type SubscribeToEventsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeToEventsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeToEventsRequestMultiError) AllErrors() []error { return m }

// SubscribeToEventsRequestValidationError is the validation error returned by
// SubscribeToEventsRequest.Validate if the designated constraints aren't met.
type SubscribeToEventsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeToEventsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeToEventsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeToEventsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeToEventsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeToEventsRequestValidationError) ErrorName() string {
	return "SubscribeToEventsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeToEventsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeToEventsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeToEventsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeToEventsRequestValidationError{}

// Validate checks the field values on SubscribeToEventsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeToEventsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeToEventsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeToEventsResponseMultiError, or nil if none found.
func (m *SubscribeToEventsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeToEventsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Event.(type) {
	case *SubscribeToEventsResponse_Transfer:
		if v == nil {
			err := SubscribeToEventsResponseValidationError{
				field:  "Event",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTransfer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribeToEventsResponseValidationError{
						field:  "Transfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribeToEventsResponseValidationError{
						field:  "Transfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribeToEventsResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SubscribeToEventsResponse_Deposit:
		if v == nil {
			err := SubscribeToEventsResponseValidationError{
				field:  "Event",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeposit()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribeToEventsResponseValidationError{
						field:  "Deposit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribeToEventsResponseValidationError{
						field:  "Deposit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeposit()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribeToEventsResponseValidationError{
					field:  "Deposit",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SubscribeToEventsResponse_Connected:
		if v == nil {
			err := SubscribeToEventsResponseValidationError{
				field:  "Event",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConnected()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribeToEventsResponseValidationError{
						field:  "Connected",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribeToEventsResponseValidationError{
						field:  "Connected",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConnected()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribeToEventsResponseValidationError{
					field:  "Connected",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SubscribeToEventsResponseMultiError(errors)
	}

	return nil
}

// SubscribeToEventsResponseMultiError is an error wrapping multiple validation
// errors returned by SubscribeToEventsResponse.ValidateAll() if the
// designated constraints aren't met.
type SubscribeToEventsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeToEventsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeToEventsResponseMultiError) AllErrors() []error { return m }

// SubscribeToEventsResponseValidationError is the validation error returned by
// SubscribeToEventsResponse.Validate if the designated constraints aren't met.
type SubscribeToEventsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeToEventsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeToEventsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeToEventsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeToEventsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeToEventsResponseValidationError) ErrorName() string {
	return "SubscribeToEventsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeToEventsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeToEventsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeToEventsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeToEventsResponseValidationError{}

// Validate checks the field values on ConnectedEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConnectedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectedEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectedEventMultiError,
// or nil if none found.
func (m *ConnectedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ConnectedEventMultiError(errors)
	}

	return nil
}

// ConnectedEventMultiError is an error wrapping multiple validation errors
// returned by ConnectedEvent.ValidateAll() if the designated constraints
// aren't met.
type ConnectedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectedEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectedEventMultiError) AllErrors() []error { return m }

// ConnectedEventValidationError is the validation error returned by
// ConnectedEvent.Validate if the designated constraints aren't met.
type ConnectedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectedEventValidationError) ErrorName() string { return "ConnectedEventValidationError" }

// Error satisfies the builtin error interface
func (e ConnectedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectedEventValidationError{}

// Validate checks the field values on TransferEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TransferEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransferEventMultiError, or
// nil if none found.
func (m *TransferEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferEventValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferEventValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferEventValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransferEventMultiError(errors)
	}

	return nil
}

// TransferEventMultiError is an error wrapping multiple validation errors
// returned by TransferEvent.ValidateAll() if the designated constraints
// aren't met.
type TransferEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferEventMultiError) AllErrors() []error { return m }

// TransferEventValidationError is the validation error returned by
// TransferEvent.Validate if the designated constraints aren't met.
type TransferEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferEventValidationError) ErrorName() string { return "TransferEventValidationError" }

// Error satisfies the builtin error interface
func (e TransferEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferEventValidationError{}

// Validate checks the field values on DepositEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DepositEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DepositEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DepositEventMultiError, or
// nil if none found.
func (m *DepositEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DepositEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDeposit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DepositEventValidationError{
					field:  "Deposit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DepositEventValidationError{
					field:  "Deposit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeposit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DepositEventValidationError{
				field:  "Deposit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DepositEventMultiError(errors)
	}

	return nil
}

// DepositEventMultiError is an error wrapping multiple validation errors
// returned by DepositEvent.ValidateAll() if the designated constraints aren't met.
type DepositEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DepositEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DepositEventMultiError) AllErrors() []error { return m }

// DepositEventValidationError is the validation error returned by
// DepositEvent.Validate if the designated constraints aren't met.
type DepositEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DepositEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DepositEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DepositEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DepositEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DepositEventValidationError) ErrorName() string { return "DepositEventValidationError" }

// Error satisfies the builtin error interface
func (e DepositEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDepositEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DepositEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DepositEventValidationError{}

// Validate checks the field values on DepositAddressProof with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DepositAddressProof) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DepositAddressProof with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DepositAddressProofMultiError, or nil if none found.
func (m *DepositAddressProof) ValidateAll() error {
	return m.validate(true)
}

func (m *DepositAddressProof) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AddressSignatures

	// no validation rules for ProofOfPossessionSignature

	if len(errors) > 0 {
		return DepositAddressProofMultiError(errors)
	}

	return nil
}

// DepositAddressProofMultiError is an error wrapping multiple validation
// errors returned by DepositAddressProof.ValidateAll() if the designated
// constraints aren't met.
type DepositAddressProofMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DepositAddressProofMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DepositAddressProofMultiError) AllErrors() []error { return m }

// DepositAddressProofValidationError is the validation error returned by
// DepositAddressProof.Validate if the designated constraints aren't met.
type DepositAddressProofValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DepositAddressProofValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DepositAddressProofValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DepositAddressProofValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DepositAddressProofValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DepositAddressProofValidationError) ErrorName() string {
	return "DepositAddressProofValidationError"
}

// Error satisfies the builtin error interface
func (e DepositAddressProofValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDepositAddressProof.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DepositAddressProofValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DepositAddressProofValidationError{}

// Validate checks the field values on GenerateDepositAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateDepositAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateDepositAddressRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GenerateDepositAddressRequestMultiError, or nil if none found.
func (m *GenerateDepositAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateDepositAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SigningPublicKey

	// no validation rules for IdentityPublicKey

	if _, ok := _GenerateDepositAddressRequest_Network_NotInLookup[m.GetNetwork()]; ok {
		err := GenerateDepositAddressRequestValidationError{
			field:  "Network",
			reason: "value must not be in list [UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.LeafId != nil {

		if err := m._validateUuid(m.GetLeafId()); err != nil {
			err = GenerateDepositAddressRequestValidationError{
				field:  "LeafId",
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.IsStatic != nil {
		// no validation rules for IsStatic
	}

	if len(errors) > 0 {
		return GenerateDepositAddressRequestMultiError(errors)
	}

	return nil
}

func (m *GenerateDepositAddressRequest) _validateUuid(uuid string) error {
	if matched := _spark_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GenerateDepositAddressRequestMultiError is an error wrapping multiple
// validation errors returned by GenerateDepositAddressRequest.ValidateAll()
// if the designated constraints aren't met.
type GenerateDepositAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateDepositAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateDepositAddressRequestMultiError) AllErrors() []error { return m }

// GenerateDepositAddressRequestValidationError is the validation error
// returned by GenerateDepositAddressRequest.Validate if the designated
// constraints aren't met.
type GenerateDepositAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateDepositAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateDepositAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateDepositAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateDepositAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateDepositAddressRequestValidationError) ErrorName() string {
	return "GenerateDepositAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateDepositAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateDepositAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateDepositAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateDepositAddressRequestValidationError{}

var _GenerateDepositAddressRequest_Network_NotInLookup = map[Network]struct{}{
	0: {},
}

// Validate checks the field values on Address with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Address) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Address with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AddressMultiError, or nil if none found.
func (m *Address) ValidateAll() error {
	return m.validate(true)
}

func (m *Address) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for VerifyingKey

	if all {
		switch v := interface{}(m.GetDepositAddressProof()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddressValidationError{
					field:  "DepositAddressProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddressValidationError{
					field:  "DepositAddressProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDepositAddressProof()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddressValidationError{
				field:  "DepositAddressProof",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsStatic

	if len(errors) > 0 {
		return AddressMultiError(errors)
	}

	return nil
}

// AddressMultiError is an error wrapping multiple validation errors returned
// by Address.ValidateAll() if the designated constraints aren't met.
type AddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressMultiError) AllErrors() []error { return m }

// AddressValidationError is the validation error returned by Address.Validate
// if the designated constraints aren't met.
type AddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressValidationError) ErrorName() string { return "AddressValidationError" }

// Error satisfies the builtin error interface
func (e AddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressValidationError{}

// Validate checks the field values on GenerateDepositAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateDepositAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateDepositAddressResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GenerateDepositAddressResponseMultiError, or nil if none found.
func (m *GenerateDepositAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateDepositAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDepositAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateDepositAddressResponseValidationError{
					field:  "DepositAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateDepositAddressResponseValidationError{
					field:  "DepositAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDepositAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateDepositAddressResponseValidationError{
				field:  "DepositAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenerateDepositAddressResponseMultiError(errors)
	}

	return nil
}

// GenerateDepositAddressResponseMultiError is an error wrapping multiple
// validation errors returned by GenerateDepositAddressResponse.ValidateAll()
// if the designated constraints aren't met.
type GenerateDepositAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateDepositAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateDepositAddressResponseMultiError) AllErrors() []error { return m }

// GenerateDepositAddressResponseValidationError is the validation error
// returned by GenerateDepositAddressResponse.Validate if the designated
// constraints aren't met.
type GenerateDepositAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateDepositAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateDepositAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateDepositAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateDepositAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateDepositAddressResponseValidationError) ErrorName() string {
	return "GenerateDepositAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateDepositAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateDepositAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateDepositAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateDepositAddressResponseValidationError{}

// Validate checks the field values on GenerateStaticDepositAddressRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GenerateStaticDepositAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateStaticDepositAddressRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GenerateStaticDepositAddressRequestMultiError, or nil if none found.
func (m *GenerateStaticDepositAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateStaticDepositAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetSigningPublicKey()) != 33 {
		err := GenerateStaticDepositAddressRequestValidationError{
			field:  "SigningPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetIdentityPublicKey()) != 33 {
		err := GenerateStaticDepositAddressRequestValidationError{
			field:  "IdentityPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _GenerateStaticDepositAddressRequest_Network_NotInLookup[m.GetNetwork()]; ok {
		err := GenerateStaticDepositAddressRequestValidationError{
			field:  "Network",
			reason: "value must not be in list [UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GenerateStaticDepositAddressRequestMultiError(errors)
	}

	return nil
}

// GenerateStaticDepositAddressRequestMultiError is an error wrapping multiple
// validation errors returned by
// GenerateStaticDepositAddressRequest.ValidateAll() if the designated
// constraints aren't met.
type GenerateStaticDepositAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateStaticDepositAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateStaticDepositAddressRequestMultiError) AllErrors() []error { return m }

// GenerateStaticDepositAddressRequestValidationError is the validation error
// returned by GenerateStaticDepositAddressRequest.Validate if the designated
// constraints aren't met.
type GenerateStaticDepositAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateStaticDepositAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateStaticDepositAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateStaticDepositAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateStaticDepositAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateStaticDepositAddressRequestValidationError) ErrorName() string {
	return "GenerateStaticDepositAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateStaticDepositAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateStaticDepositAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateStaticDepositAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateStaticDepositAddressRequestValidationError{}

var _GenerateStaticDepositAddressRequest_Network_NotInLookup = map[Network]struct{}{
	0: {},
}

// Validate checks the field values on GenerateStaticDepositAddressResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GenerateStaticDepositAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateStaticDepositAddressResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GenerateStaticDepositAddressResponseMultiError, or nil if none found.
func (m *GenerateStaticDepositAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateStaticDepositAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDepositAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateStaticDepositAddressResponseValidationError{
					field:  "DepositAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateStaticDepositAddressResponseValidationError{
					field:  "DepositAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDepositAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateStaticDepositAddressResponseValidationError{
				field:  "DepositAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenerateStaticDepositAddressResponseMultiError(errors)
	}

	return nil
}

// GenerateStaticDepositAddressResponseMultiError is an error wrapping multiple
// validation errors returned by
// GenerateStaticDepositAddressResponse.ValidateAll() if the designated
// constraints aren't met.
type GenerateStaticDepositAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateStaticDepositAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateStaticDepositAddressResponseMultiError) AllErrors() []error { return m }

// GenerateStaticDepositAddressResponseValidationError is the validation error
// returned by GenerateStaticDepositAddressResponse.Validate if the designated
// constraints aren't met.
type GenerateStaticDepositAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateStaticDepositAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateStaticDepositAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateStaticDepositAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateStaticDepositAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateStaticDepositAddressResponseValidationError) ErrorName() string {
	return "GenerateStaticDepositAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateStaticDepositAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateStaticDepositAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateStaticDepositAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateStaticDepositAddressResponseValidationError{}

// Validate checks the field values on UTXO with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *UTXO) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UTXO with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UTXOMultiError, or nil if none found.
func (m *UTXO) ValidateAll() error {
	return m.validate(true)
}

func (m *UTXO) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RawTx

	// no validation rules for Vout

	if _, ok := _UTXO_Network_NotInLookup[m.GetNetwork()]; ok {
		err := UTXOValidationError{
			field:  "Network",
			reason: "value must not be in list [UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Txid

	if len(errors) > 0 {
		return UTXOMultiError(errors)
	}

	return nil
}

// UTXOMultiError is an error wrapping multiple validation errors returned by
// UTXO.ValidateAll() if the designated constraints aren't met.
type UTXOMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UTXOMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UTXOMultiError) AllErrors() []error { return m }

// UTXOValidationError is the validation error returned by UTXO.Validate if the
// designated constraints aren't met.
type UTXOValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UTXOValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UTXOValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UTXOValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UTXOValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UTXOValidationError) ErrorName() string { return "UTXOValidationError" }

// Error satisfies the builtin error interface
func (e UTXOValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUTXO.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UTXOValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UTXOValidationError{}

var _UTXO_Network_NotInLookup = map[Network]struct{}{
	0: {},
}

// Validate checks the field values on NodeOutput with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeOutput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeOutputMultiError, or
// nil if none found.
func (m *NodeOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeId

	// no validation rules for Vout

	if len(errors) > 0 {
		return NodeOutputMultiError(errors)
	}

	return nil
}

// NodeOutputMultiError is an error wrapping multiple validation errors
// returned by NodeOutput.ValidateAll() if the designated constraints aren't met.
type NodeOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeOutputMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeOutputMultiError) AllErrors() []error { return m }

// NodeOutputValidationError is the validation error returned by
// NodeOutput.Validate if the designated constraints aren't met.
type NodeOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeOutputValidationError) ErrorName() string { return "NodeOutputValidationError" }

// Error satisfies the builtin error interface
func (e NodeOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeOutputValidationError{}

// Validate checks the field values on SigningJob with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SigningJob) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SigningJob with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SigningJobMultiError, or
// nil if none found.
func (m *SigningJob) ValidateAll() error {
	return m.validate(true)
}

func (m *SigningJob) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SigningPublicKey

	// no validation rules for RawTx

	if all {
		switch v := interface{}(m.GetSigningNonceCommitment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SigningJobValidationError{
					field:  "SigningNonceCommitment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SigningJobValidationError{
					field:  "SigningNonceCommitment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningNonceCommitment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SigningJobValidationError{
				field:  "SigningNonceCommitment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SigningJobMultiError(errors)
	}

	return nil
}

// SigningJobMultiError is an error wrapping multiple validation errors
// returned by SigningJob.ValidateAll() if the designated constraints aren't met.
type SigningJobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SigningJobMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SigningJobMultiError) AllErrors() []error { return m }

// SigningJobValidationError is the validation error returned by
// SigningJob.Validate if the designated constraints aren't met.
type SigningJobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SigningJobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SigningJobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SigningJobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SigningJobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SigningJobValidationError) ErrorName() string { return "SigningJobValidationError" }

// Error satisfies the builtin error interface
func (e SigningJobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSigningJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SigningJobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SigningJobValidationError{}

// Validate checks the field values on SigningKeyshare with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SigningKeyshare) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SigningKeyshare with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SigningKeyshareMultiError, or nil if none found.
func (m *SigningKeyshare) ValidateAll() error {
	return m.validate(true)
}

func (m *SigningKeyshare) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Threshold

	// no validation rules for PublicKey

	// no validation rules for PublicShares

	if all {
		switch v := interface{}(m.GetUpdatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SigningKeyshareValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SigningKeyshareValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SigningKeyshareValidationError{
				field:  "UpdatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SigningKeyshareMultiError(errors)
	}

	return nil
}

// SigningKeyshareMultiError is an error wrapping multiple validation errors
// returned by SigningKeyshare.ValidateAll() if the designated constraints
// aren't met.
type SigningKeyshareMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SigningKeyshareMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SigningKeyshareMultiError) AllErrors() []error { return m }

// SigningKeyshareValidationError is the validation error returned by
// SigningKeyshare.Validate if the designated constraints aren't met.
type SigningKeyshareValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SigningKeyshareValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SigningKeyshareValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SigningKeyshareValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SigningKeyshareValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SigningKeyshareValidationError) ErrorName() string { return "SigningKeyshareValidationError" }

// Error satisfies the builtin error interface
func (e SigningKeyshareValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSigningKeyshare.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SigningKeyshareValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SigningKeyshareValidationError{}

// Validate checks the field values on SigningResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SigningResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SigningResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SigningResultMultiError, or
// nil if none found.
func (m *SigningResult) ValidateAll() error {
	return m.validate(true)
}

func (m *SigningResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PublicKeys

	{
		sorted_keys := make([]string, len(m.GetSigningNonceCommitments()))
		i := 0
		for key := range m.GetSigningNonceCommitments() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSigningNonceCommitments()[key]
			_ = val

			// no validation rules for SigningNonceCommitments[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SigningResultValidationError{
							field:  fmt.Sprintf("SigningNonceCommitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SigningResultValidationError{
							field:  fmt.Sprintf("SigningNonceCommitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SigningResultValidationError{
						field:  fmt.Sprintf("SigningNonceCommitments[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for SignatureShares

	if all {
		switch v := interface{}(m.GetSigningKeyshare()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SigningResultValidationError{
					field:  "SigningKeyshare",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SigningResultValidationError{
					field:  "SigningKeyshare",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningKeyshare()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SigningResultValidationError{
				field:  "SigningKeyshare",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SigningResultMultiError(errors)
	}

	return nil
}

// SigningResultMultiError is an error wrapping multiple validation errors
// returned by SigningResult.ValidateAll() if the designated constraints
// aren't met.
type SigningResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SigningResultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SigningResultMultiError) AllErrors() []error { return m }

// SigningResultValidationError is the validation error returned by
// SigningResult.Validate if the designated constraints aren't met.
type SigningResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SigningResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SigningResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SigningResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SigningResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SigningResultValidationError) ErrorName() string { return "SigningResultValidationError" }

// Error satisfies the builtin error interface
func (e SigningResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSigningResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SigningResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SigningResultValidationError{}

// Validate checks the field values on NodeSignatureShares with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NodeSignatureShares) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeSignatureShares with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeSignatureSharesMultiError, or nil if none found.
func (m *NodeSignatureShares) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeSignatureShares) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeId

	if all {
		switch v := interface{}(m.GetNodeTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeSignatureSharesValidationError{
					field:  "NodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeSignatureSharesValidationError{
					field:  "NodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeSignatureSharesValidationError{
				field:  "NodeTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeSignatureSharesValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeSignatureSharesValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeSignatureSharesValidationError{
				field:  "RefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VerifyingKey

	if all {
		switch v := interface{}(m.GetDirectNodeTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeSignatureSharesValidationError{
					field:  "DirectNodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeSignatureSharesValidationError{
					field:  "DirectNodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectNodeTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeSignatureSharesValidationError{
				field:  "DirectNodeTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeSignatureSharesValidationError{
					field:  "DirectRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeSignatureSharesValidationError{
					field:  "DirectRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeSignatureSharesValidationError{
				field:  "DirectRefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectFromCpfpRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeSignatureSharesValidationError{
					field:  "DirectFromCpfpRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeSignatureSharesValidationError{
					field:  "DirectFromCpfpRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectFromCpfpRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeSignatureSharesValidationError{
				field:  "DirectFromCpfpRefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NodeSignatureSharesMultiError(errors)
	}

	return nil
}

// NodeSignatureSharesMultiError is an error wrapping multiple validation
// errors returned by NodeSignatureShares.ValidateAll() if the designated
// constraints aren't met.
type NodeSignatureSharesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeSignatureSharesMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeSignatureSharesMultiError) AllErrors() []error { return m }

// NodeSignatureSharesValidationError is the validation error returned by
// NodeSignatureShares.Validate if the designated constraints aren't met.
type NodeSignatureSharesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeSignatureSharesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeSignatureSharesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeSignatureSharesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeSignatureSharesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeSignatureSharesValidationError) ErrorName() string {
	return "NodeSignatureSharesValidationError"
}

// Error satisfies the builtin error interface
func (e NodeSignatureSharesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeSignatureShares.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeSignatureSharesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeSignatureSharesValidationError{}

// Validate checks the field values on NodeSignatures with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeSignatures) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeSignatures with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeSignaturesMultiError,
// or nil if none found.
func (m *NodeSignatures) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeSignatures) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeId

	// no validation rules for NodeTxSignature

	// no validation rules for RefundTxSignature

	// no validation rules for DirectNodeTxSignature

	// no validation rules for DirectRefundTxSignature

	// no validation rules for DirectFromCpfpRefundTxSignature

	if len(errors) > 0 {
		return NodeSignaturesMultiError(errors)
	}

	return nil
}

// NodeSignaturesMultiError is an error wrapping multiple validation errors
// returned by NodeSignatures.ValidateAll() if the designated constraints
// aren't met.
type NodeSignaturesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeSignaturesMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeSignaturesMultiError) AllErrors() []error { return m }

// NodeSignaturesValidationError is the validation error returned by
// NodeSignatures.Validate if the designated constraints aren't met.
type NodeSignaturesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeSignaturesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeSignaturesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeSignaturesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeSignaturesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeSignaturesValidationError) ErrorName() string { return "NodeSignaturesValidationError" }

// Error satisfies the builtin error interface
func (e NodeSignaturesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeSignatures.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeSignaturesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeSignaturesValidationError{}

// Validate checks the field values on StartTreeCreationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartTreeCreationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartTreeCreationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartTreeCreationRequestMultiError, or nil if none found.
func (m *StartTreeCreationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartTreeCreationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdentityPublicKey

	if all {
		switch v := interface{}(m.GetOnChainUtxo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOnChainUtxo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTreeCreationRequestValidationError{
				field:  "OnChainUtxo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRootTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "RootTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "RootTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRootTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTreeCreationRequestValidationError{
				field:  "RootTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTreeCreationRequestValidationError{
				field:  "RefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectRootTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "DirectRootTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "DirectRootTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectRootTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTreeCreationRequestValidationError{
				field:  "DirectRootTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "DirectRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "DirectRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTreeCreationRequestValidationError{
				field:  "DirectRefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectFromCpfpRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "DirectFromCpfpRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "DirectFromCpfpRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectFromCpfpRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTreeCreationRequestValidationError{
				field:  "DirectFromCpfpRefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartTreeCreationRequestMultiError(errors)
	}

	return nil
}

// StartTreeCreationRequestMultiError is an error wrapping multiple validation
// errors returned by StartTreeCreationRequest.ValidateAll() if the designated
// constraints aren't met.
type StartTreeCreationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartTreeCreationRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartTreeCreationRequestMultiError) AllErrors() []error { return m }

// StartTreeCreationRequestValidationError is the validation error returned by
// StartTreeCreationRequest.Validate if the designated constraints aren't met.
type StartTreeCreationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartTreeCreationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartTreeCreationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartTreeCreationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartTreeCreationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartTreeCreationRequestValidationError) ErrorName() string {
	return "StartTreeCreationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartTreeCreationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartTreeCreationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartTreeCreationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartTreeCreationRequestValidationError{}

// Validate checks the field values on StartTreeCreationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartTreeCreationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartTreeCreationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartTreeCreationResponseMultiError, or nil if none found.
func (m *StartTreeCreationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartTreeCreationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TreeId

	if all {
		switch v := interface{}(m.GetRootNodeSignatureShares()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTreeCreationResponseValidationError{
					field:  "RootNodeSignatureShares",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTreeCreationResponseValidationError{
					field:  "RootNodeSignatureShares",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRootNodeSignatureShares()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTreeCreationResponseValidationError{
				field:  "RootNodeSignatureShares",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartTreeCreationResponseMultiError(errors)
	}

	return nil
}

// StartTreeCreationResponseMultiError is an error wrapping multiple validation
// errors returned by StartTreeCreationResponse.ValidateAll() if the
// designated constraints aren't met.
type StartTreeCreationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartTreeCreationResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartTreeCreationResponseMultiError) AllErrors() []error { return m }

// StartTreeCreationResponseValidationError is the validation error returned by
// StartTreeCreationResponse.Validate if the designated constraints aren't met.
type StartTreeCreationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartTreeCreationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartTreeCreationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartTreeCreationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartTreeCreationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartTreeCreationResponseValidationError) ErrorName() string {
	return "StartTreeCreationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartTreeCreationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartTreeCreationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartTreeCreationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartTreeCreationResponseValidationError{}

// Validate checks the field values on StartDepositTreeCreationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartDepositTreeCreationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartDepositTreeCreationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// StartDepositTreeCreationRequestMultiError, or nil if none found.
func (m *StartDepositTreeCreationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartDepositTreeCreationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdentityPublicKey

	if all {
		switch v := interface{}(m.GetOnChainUtxo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartDepositTreeCreationRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartDepositTreeCreationRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOnChainUtxo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartDepositTreeCreationRequestValidationError{
				field:  "OnChainUtxo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRootTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartDepositTreeCreationRequestValidationError{
					field:  "RootTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartDepositTreeCreationRequestValidationError{
					field:  "RootTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRootTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartDepositTreeCreationRequestValidationError{
				field:  "RootTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartDepositTreeCreationRequestValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartDepositTreeCreationRequestValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartDepositTreeCreationRequestValidationError{
				field:  "RefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectRootTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartDepositTreeCreationRequestValidationError{
					field:  "DirectRootTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartDepositTreeCreationRequestValidationError{
					field:  "DirectRootTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectRootTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartDepositTreeCreationRequestValidationError{
				field:  "DirectRootTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartDepositTreeCreationRequestValidationError{
					field:  "DirectRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartDepositTreeCreationRequestValidationError{
					field:  "DirectRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartDepositTreeCreationRequestValidationError{
				field:  "DirectRefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectFromCpfpRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartDepositTreeCreationRequestValidationError{
					field:  "DirectFromCpfpRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartDepositTreeCreationRequestValidationError{
					field:  "DirectFromCpfpRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectFromCpfpRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartDepositTreeCreationRequestValidationError{
				field:  "DirectFromCpfpRefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartDepositTreeCreationRequestMultiError(errors)
	}

	return nil
}

// StartDepositTreeCreationRequestMultiError is an error wrapping multiple
// validation errors returned by StartDepositTreeCreationRequest.ValidateAll()
// if the designated constraints aren't met.
type StartDepositTreeCreationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartDepositTreeCreationRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartDepositTreeCreationRequestMultiError) AllErrors() []error { return m }

// StartDepositTreeCreationRequestValidationError is the validation error
// returned by StartDepositTreeCreationRequest.Validate if the designated
// constraints aren't met.
type StartDepositTreeCreationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartDepositTreeCreationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartDepositTreeCreationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartDepositTreeCreationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartDepositTreeCreationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartDepositTreeCreationRequestValidationError) ErrorName() string {
	return "StartDepositTreeCreationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartDepositTreeCreationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartDepositTreeCreationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartDepositTreeCreationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartDepositTreeCreationRequestValidationError{}

// Validate checks the field values on StartDepositTreeCreationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *StartDepositTreeCreationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartDepositTreeCreationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// StartDepositTreeCreationResponseMultiError, or nil if none found.
func (m *StartDepositTreeCreationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartDepositTreeCreationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TreeId

	if all {
		switch v := interface{}(m.GetRootNodeSignatureShares()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartDepositTreeCreationResponseValidationError{
					field:  "RootNodeSignatureShares",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartDepositTreeCreationResponseValidationError{
					field:  "RootNodeSignatureShares",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRootNodeSignatureShares()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartDepositTreeCreationResponseValidationError{
				field:  "RootNodeSignatureShares",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartDepositTreeCreationResponseMultiError(errors)
	}

	return nil
}

// StartDepositTreeCreationResponseMultiError is an error wrapping multiple
// validation errors returned by
// StartDepositTreeCreationResponse.ValidateAll() if the designated
// constraints aren't met.
type StartDepositTreeCreationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartDepositTreeCreationResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartDepositTreeCreationResponseMultiError) AllErrors() []error { return m }

// StartDepositTreeCreationResponseValidationError is the validation error
// returned by StartDepositTreeCreationResponse.Validate if the designated
// constraints aren't met.
type StartDepositTreeCreationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartDepositTreeCreationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartDepositTreeCreationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartDepositTreeCreationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartDepositTreeCreationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartDepositTreeCreationResponseValidationError) ErrorName() string {
	return "StartDepositTreeCreationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartDepositTreeCreationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartDepositTreeCreationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartDepositTreeCreationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartDepositTreeCreationResponseValidationError{}

// Validate checks the field values on TokenOutputToSpend with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenOutputToSpend) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenOutputToSpend with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenOutputToSpendMultiError, or nil if none found.
func (m *TokenOutputToSpend) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenOutputToSpend) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetPrevTokenTransactionHash()) != 32 {
		err := TokenOutputToSpendValidationError{
			field:  "PrevTokenTransactionHash",
			reason: "value length must be 32 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PrevTokenTransactionVout

	if len(errors) > 0 {
		return TokenOutputToSpendMultiError(errors)
	}

	return nil
}

// TokenOutputToSpendMultiError is an error wrapping multiple validation errors
// returned by TokenOutputToSpend.ValidateAll() if the designated constraints
// aren't met.
type TokenOutputToSpendMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenOutputToSpendMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenOutputToSpendMultiError) AllErrors() []error { return m }

// TokenOutputToSpendValidationError is the validation error returned by
// TokenOutputToSpend.Validate if the designated constraints aren't met.
type TokenOutputToSpendValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenOutputToSpendValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenOutputToSpendValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenOutputToSpendValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenOutputToSpendValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenOutputToSpendValidationError) ErrorName() string {
	return "TokenOutputToSpendValidationError"
}

// Error satisfies the builtin error interface
func (e TokenOutputToSpendValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenOutputToSpend.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenOutputToSpendValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenOutputToSpendValidationError{}

// Validate checks the field values on TokenTransferInput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenTransferInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenTransferInput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenTransferInputMultiError, or nil if none found.
func (m *TokenTransferInput) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenTransferInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOutputsToSpend() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenTransferInputValidationError{
						field:  fmt.Sprintf("OutputsToSpend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenTransferInputValidationError{
						field:  fmt.Sprintf("OutputsToSpend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenTransferInputValidationError{
					field:  fmt.Sprintf("OutputsToSpend[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TokenTransferInputMultiError(errors)
	}

	return nil
}

// TokenTransferInputMultiError is an error wrapping multiple validation errors
// returned by TokenTransferInput.ValidateAll() if the designated constraints
// aren't met.
type TokenTransferInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenTransferInputMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenTransferInputMultiError) AllErrors() []error { return m }

// TokenTransferInputValidationError is the validation error returned by
// TokenTransferInput.Validate if the designated constraints aren't met.
type TokenTransferInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenTransferInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenTransferInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenTransferInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenTransferInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenTransferInputValidationError) ErrorName() string {
	return "TokenTransferInputValidationError"
}

// Error satisfies the builtin error interface
func (e TokenTransferInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenTransferInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenTransferInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenTransferInputValidationError{}

// Validate checks the field values on TokenMintInput with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TokenMintInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenMintInput with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TokenMintInputMultiError,
// or nil if none found.
func (m *TokenMintInput) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenMintInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetIssuerPublicKey()) != 33 {
		err := TokenMintInputValidationError{
			field:  "IssuerPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IssuerProvidedTimestamp

	if m.TokenIdentifier != nil {

		if len(m.GetTokenIdentifier()) != 32 {
			err := TokenMintInputValidationError{
				field:  "TokenIdentifier",
				reason: "value length must be 32 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return TokenMintInputMultiError(errors)
	}

	return nil
}

// TokenMintInputMultiError is an error wrapping multiple validation errors
// returned by TokenMintInput.ValidateAll() if the designated constraints
// aren't met.
type TokenMintInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenMintInputMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenMintInputMultiError) AllErrors() []error { return m }

// TokenMintInputValidationError is the validation error returned by
// TokenMintInput.Validate if the designated constraints aren't met.
type TokenMintInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenMintInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenMintInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenMintInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenMintInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenMintInputValidationError) ErrorName() string { return "TokenMintInputValidationError" }

// Error satisfies the builtin error interface
func (e TokenMintInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenMintInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenMintInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenMintInputValidationError{}

// Validate checks the field values on TokenCreateInput with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TokenCreateInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenCreateInput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenCreateInputMultiError, or nil if none found.
func (m *TokenCreateInput) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenCreateInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetIssuerPublicKey()) != 33 {
		err := TokenCreateInputValidationError{
			field:  "IssuerPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTokenName()) > 20 {
		err := TokenCreateInputValidationError{
			field:  "TokenName",
			reason: "value length must be at most 20 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTokenTicker()) > 6 {
		err := TokenCreateInputValidationError{
			field:  "TokenTicker",
			reason: "value length must be at most 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetDecimals() > 255 {
		err := TokenCreateInputValidationError{
			field:  "Decimals",
			reason: "value must be less than or equal to 255",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetMaxSupply()) != 16 {
		err := TokenCreateInputValidationError{
			field:  "MaxSupply",
			reason: "value length must be 16 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsFreezable

	if m.CreationEntityPublicKey != nil {

		if len(m.GetCreationEntityPublicKey()) != 33 {
			err := TokenCreateInputValidationError{
				field:  "CreationEntityPublicKey",
				reason: "value length must be 33 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return TokenCreateInputMultiError(errors)
	}

	return nil
}

// TokenCreateInputMultiError is an error wrapping multiple validation errors
// returned by TokenCreateInput.ValidateAll() if the designated constraints
// aren't met.
type TokenCreateInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenCreateInputMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenCreateInputMultiError) AllErrors() []error { return m }

// TokenCreateInputValidationError is the validation error returned by
// TokenCreateInput.Validate if the designated constraints aren't met.
type TokenCreateInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenCreateInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenCreateInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenCreateInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenCreateInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenCreateInputValidationError) ErrorName() string { return "TokenCreateInputValidationError" }

// Error satisfies the builtin error interface
func (e TokenCreateInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenCreateInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenCreateInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenCreateInputValidationError{}

// Validate checks the field values on TokenOutput with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TokenOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenOutput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TokenOutputMultiError, or
// nil if none found.
func (m *TokenOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetOwnerPublicKey()) != 33 {
		err := TokenOutputValidationError{
			field:  "OwnerPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTokenAmount()) != 16 {
		err := TokenOutputValidationError{
			field:  "TokenAmount",
			reason: "value length must be 16 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Id != nil {

		if err := m._validateUuid(m.GetId()); err != nil {
			err = TokenOutputValidationError{
				field:  "Id",
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.RevocationCommitment != nil {

		if len(m.GetRevocationCommitment()) != 33 {
			err := TokenOutputValidationError{
				field:  "RevocationCommitment",
				reason: "value length must be 33 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.WithdrawBondSats != nil {
		// no validation rules for WithdrawBondSats
	}

	if m.WithdrawRelativeBlockLocktime != nil {
		// no validation rules for WithdrawRelativeBlockLocktime
	}

	if m.TokenPublicKey != nil {

		if len(m.GetTokenPublicKey()) != 33 {
			err := TokenOutputValidationError{
				field:  "TokenPublicKey",
				reason: "value length must be 33 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.TokenIdentifier != nil {

		if len(m.GetTokenIdentifier()) != 32 {
			err := TokenOutputValidationError{
				field:  "TokenIdentifier",
				reason: "value length must be 32 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return TokenOutputMultiError(errors)
	}

	return nil
}

func (m *TokenOutput) _validateUuid(uuid string) error {
	if matched := _spark_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// TokenOutputMultiError is an error wrapping multiple validation errors
// returned by TokenOutput.ValidateAll() if the designated constraints aren't met.
type TokenOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenOutputMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenOutputMultiError) AllErrors() []error { return m }

// TokenOutputValidationError is the validation error returned by
// TokenOutput.Validate if the designated constraints aren't met.
type TokenOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenOutputValidationError) ErrorName() string { return "TokenOutputValidationError" }

// Error satisfies the builtin error interface
func (e TokenOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenOutputValidationError{}

// Validate checks the field values on TokenTransaction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TokenTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenTransactionMultiError, or nil if none found.
func (m *TokenTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTokenOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenTransactionValidationError{
						field:  fmt.Sprintf("TokenOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenTransactionValidationError{
						field:  fmt.Sprintf("TokenOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenTransactionValidationError{
					field:  fmt.Sprintf("TokenOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSparkOperatorIdentityPublicKeys() {
		_, _ = idx, item

		if len(item) != 33 {
			err := TokenTransactionValidationError{
				field:  fmt.Sprintf("SparkOperatorIdentityPublicKeys[%v]", idx),
				reason: "value length must be 33 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if _, ok := _TokenTransaction_Network_NotInLookup[m.GetNetwork()]; ok {
		err := TokenTransactionValidationError{
			field:  "Network",
			reason: "value must not be in list [UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	switch v := m.TokenInputs.(type) {
	case *TokenTransaction_MintInput:
		if v == nil {
			err := TokenTransactionValidationError{
				field:  "TokenInputs",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMintInput()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenTransactionValidationError{
						field:  "MintInput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenTransactionValidationError{
						field:  "MintInput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMintInput()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenTransactionValidationError{
					field:  "MintInput",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TokenTransaction_TransferInput:
		if v == nil {
			err := TokenTransactionValidationError{
				field:  "TokenInputs",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTransferInput()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenTransactionValidationError{
						field:  "TransferInput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenTransactionValidationError{
						field:  "TransferInput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTransferInput()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenTransactionValidationError{
					field:  "TransferInput",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TokenTransaction_CreateInput:
		if v == nil {
			err := TokenTransactionValidationError{
				field:  "TokenInputs",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCreateInput()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenTransactionValidationError{
						field:  "CreateInput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenTransactionValidationError{
						field:  "CreateInput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreateInput()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenTransactionValidationError{
					field:  "CreateInput",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TokenTransactionMultiError(errors)
	}

	return nil
}

// TokenTransactionMultiError is an error wrapping multiple validation errors
// returned by TokenTransaction.ValidateAll() if the designated constraints
// aren't met.
type TokenTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenTransactionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenTransactionMultiError) AllErrors() []error { return m }

// TokenTransactionValidationError is the validation error returned by
// TokenTransaction.Validate if the designated constraints aren't met.
type TokenTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenTransactionValidationError) ErrorName() string { return "TokenTransactionValidationError" }

// Error satisfies the builtin error interface
func (e TokenTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenTransactionValidationError{}

var _TokenTransaction_Network_NotInLookup = map[Network]struct{}{
	0: {},
}

// Validate checks the field values on SpentTokenOutputMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SpentTokenOutputMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpentTokenOutputMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpentTokenOutputMetadataMultiError, or nil if none found.
func (m *SpentTokenOutputMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *SpentTokenOutputMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OutputId

	// no validation rules for RevocationSecret

	if len(errors) > 0 {
		return SpentTokenOutputMetadataMultiError(errors)
	}

	return nil
}

// SpentTokenOutputMetadataMultiError is an error wrapping multiple validation
// errors returned by SpentTokenOutputMetadata.ValidateAll() if the designated
// constraints aren't met.
type SpentTokenOutputMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpentTokenOutputMetadataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpentTokenOutputMetadataMultiError) AllErrors() []error { return m }

// SpentTokenOutputMetadataValidationError is the validation error returned by
// SpentTokenOutputMetadata.Validate if the designated constraints aren't met.
type SpentTokenOutputMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpentTokenOutputMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpentTokenOutputMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpentTokenOutputMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpentTokenOutputMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpentTokenOutputMetadataValidationError) ErrorName() string {
	return "SpentTokenOutputMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e SpentTokenOutputMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpentTokenOutputMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpentTokenOutputMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpentTokenOutputMetadataValidationError{}

// Validate checks the field values on TokenTransactionConfirmationMetadata
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *TokenTransactionConfirmationMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenTransactionConfirmationMetadata
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// TokenTransactionConfirmationMetadataMultiError, or nil if none found.
func (m *TokenTransactionConfirmationMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenTransactionConfirmationMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSpentTokenOutputsMetadata() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenTransactionConfirmationMetadataValidationError{
						field:  fmt.Sprintf("SpentTokenOutputsMetadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenTransactionConfirmationMetadataValidationError{
						field:  fmt.Sprintf("SpentTokenOutputsMetadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenTransactionConfirmationMetadataValidationError{
					field:  fmt.Sprintf("SpentTokenOutputsMetadata[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TokenTransactionConfirmationMetadataMultiError(errors)
	}

	return nil
}

// TokenTransactionConfirmationMetadataMultiError is an error wrapping multiple
// validation errors returned by
// TokenTransactionConfirmationMetadata.ValidateAll() if the designated
// constraints aren't met.
type TokenTransactionConfirmationMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenTransactionConfirmationMetadataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenTransactionConfirmationMetadataMultiError) AllErrors() []error { return m }

// TokenTransactionConfirmationMetadataValidationError is the validation error
// returned by TokenTransactionConfirmationMetadata.Validate if the designated
// constraints aren't met.
type TokenTransactionConfirmationMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenTransactionConfirmationMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenTransactionConfirmationMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenTransactionConfirmationMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenTransactionConfirmationMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenTransactionConfirmationMetadataValidationError) ErrorName() string {
	return "TokenTransactionConfirmationMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e TokenTransactionConfirmationMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenTransactionConfirmationMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenTransactionConfirmationMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenTransactionConfirmationMetadataValidationError{}

// Validate checks the field values on TokenTransactionWithStatus with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenTransactionWithStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenTransactionWithStatus with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenTransactionWithStatusMultiError, or nil if none found.
func (m *TokenTransactionWithStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenTransactionWithStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TokenTransactionWithStatusValidationError{
					field:  "TokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TokenTransactionWithStatusValidationError{
					field:  "TokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TokenTransactionWithStatusValidationError{
				field:  "TokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetConfirmationMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TokenTransactionWithStatusValidationError{
					field:  "ConfirmationMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TokenTransactionWithStatusValidationError{
					field:  "ConfirmationMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfirmationMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TokenTransactionWithStatusValidationError{
				field:  "ConfirmationMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetTokenTransactionHash()) != 32 {
		err := TokenTransactionWithStatusValidationError{
			field:  "TokenTransactionHash",
			reason: "value length must be 32 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TokenTransactionWithStatusMultiError(errors)
	}

	return nil
}

// TokenTransactionWithStatusMultiError is an error wrapping multiple
// validation errors returned by TokenTransactionWithStatus.ValidateAll() if
// the designated constraints aren't met.
type TokenTransactionWithStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenTransactionWithStatusMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenTransactionWithStatusMultiError) AllErrors() []error { return m }

// TokenTransactionWithStatusValidationError is the validation error returned
// by TokenTransactionWithStatus.Validate if the designated constraints aren't met.
type TokenTransactionWithStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenTransactionWithStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenTransactionWithStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenTransactionWithStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenTransactionWithStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenTransactionWithStatusValidationError) ErrorName() string {
	return "TokenTransactionWithStatusValidationError"
}

// Error satisfies the builtin error interface
func (e TokenTransactionWithStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenTransactionWithStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenTransactionWithStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenTransactionWithStatusValidationError{}

// Validate checks the field values on SignatureWithIndex with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignatureWithIndex) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignatureWithIndex with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignatureWithIndexMultiError, or nil if none found.
func (m *SignatureWithIndex) ValidateAll() error {
	return m.validate(true)
}

func (m *SignatureWithIndex) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetSignature()); l < 64 || l > 73 {
		err := SignatureWithIndexValidationError{
			field:  "Signature",
			reason: "value length must be between 64 and 73 bytes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for InputIndex

	if len(errors) > 0 {
		return SignatureWithIndexMultiError(errors)
	}

	return nil
}

// SignatureWithIndexMultiError is an error wrapping multiple validation errors
// returned by SignatureWithIndex.ValidateAll() if the designated constraints
// aren't met.
type SignatureWithIndexMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignatureWithIndexMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignatureWithIndexMultiError) AllErrors() []error { return m }

// SignatureWithIndexValidationError is the validation error returned by
// SignatureWithIndex.Validate if the designated constraints aren't met.
type SignatureWithIndexValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignatureWithIndexValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignatureWithIndexValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignatureWithIndexValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignatureWithIndexValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignatureWithIndexValidationError) ErrorName() string {
	return "SignatureWithIndexValidationError"
}

// Error satisfies the builtin error interface
func (e SignatureWithIndexValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignatureWithIndex.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignatureWithIndexValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignatureWithIndexValidationError{}

// Validate checks the field values on TokenTransactionSignatures with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenTransactionSignatures) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenTransactionSignatures with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenTransactionSignaturesMultiError, or nil if none found.
func (m *TokenTransactionSignatures) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenTransactionSignatures) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOwnerSignatures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenTransactionSignaturesValidationError{
						field:  fmt.Sprintf("OwnerSignatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenTransactionSignaturesValidationError{
						field:  fmt.Sprintf("OwnerSignatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenTransactionSignaturesValidationError{
					field:  fmt.Sprintf("OwnerSignatures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TokenTransactionSignaturesMultiError(errors)
	}

	return nil
}

// TokenTransactionSignaturesMultiError is an error wrapping multiple
// validation errors returned by TokenTransactionSignatures.ValidateAll() if
// the designated constraints aren't met.
type TokenTransactionSignaturesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenTransactionSignaturesMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenTransactionSignaturesMultiError) AllErrors() []error { return m }

// TokenTransactionSignaturesValidationError is the validation error returned
// by TokenTransactionSignatures.Validate if the designated constraints aren't met.
type TokenTransactionSignaturesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenTransactionSignaturesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenTransactionSignaturesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenTransactionSignaturesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenTransactionSignaturesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenTransactionSignaturesValidationError) ErrorName() string {
	return "TokenTransactionSignaturesValidationError"
}

// Error satisfies the builtin error interface
func (e TokenTransactionSignaturesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenTransactionSignatures.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenTransactionSignaturesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenTransactionSignaturesValidationError{}

// Validate checks the field values on StartTokenTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartTokenTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartTokenTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartTokenTransactionRequestMultiError, or nil if none found.
func (m *StartTokenTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartTokenTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetIdentityPublicKey()) != 33 {
		err := StartTokenTransactionRequestValidationError{
			field:  "IdentityPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPartialTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTokenTransactionRequestValidationError{
					field:  "PartialTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTokenTransactionRequestValidationError{
					field:  "PartialTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPartialTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTokenTransactionRequestValidationError{
				field:  "PartialTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTokenTransactionSignatures()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTokenTransactionRequestValidationError{
					field:  "TokenTransactionSignatures",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTokenTransactionRequestValidationError{
					field:  "TokenTransactionSignatures",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTokenTransactionSignatures()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTokenTransactionRequestValidationError{
				field:  "TokenTransactionSignatures",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SparkPaymentIntent

	if len(errors) > 0 {
		return StartTokenTransactionRequestMultiError(errors)
	}

	return nil
}

// StartTokenTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by StartTokenTransactionRequest.ValidateAll() if
// the designated constraints aren't met.
type StartTokenTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartTokenTransactionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartTokenTransactionRequestMultiError) AllErrors() []error { return m }

// StartTokenTransactionRequestValidationError is the validation error returned
// by StartTokenTransactionRequest.Validate if the designated constraints
// aren't met.
type StartTokenTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartTokenTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartTokenTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartTokenTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartTokenTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartTokenTransactionRequestValidationError) ErrorName() string {
	return "StartTokenTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartTokenTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartTokenTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartTokenTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartTokenTransactionRequestValidationError{}

// Validate checks the field values on StartTokenTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartTokenTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartTokenTransactionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// StartTokenTransactionResponseMultiError, or nil if none found.
func (m *StartTokenTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartTokenTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTokenTransactionResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTokenTransactionResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTokenTransactionResponseValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKeyshareInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTokenTransactionResponseValidationError{
					field:  "KeyshareInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTokenTransactionResponseValidationError{
					field:  "KeyshareInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKeyshareInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTokenTransactionResponseValidationError{
				field:  "KeyshareInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartTokenTransactionResponseMultiError(errors)
	}

	return nil
}

// StartTokenTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by StartTokenTransactionResponse.ValidateAll()
// if the designated constraints aren't met.
type StartTokenTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartTokenTransactionResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartTokenTransactionResponseMultiError) AllErrors() []error { return m }

// StartTokenTransactionResponseValidationError is the validation error
// returned by StartTokenTransactionResponse.Validate if the designated
// constraints aren't met.
type StartTokenTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartTokenTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartTokenTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartTokenTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartTokenTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartTokenTransactionResponseValidationError) ErrorName() string {
	return "StartTokenTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartTokenTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartTokenTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartTokenTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartTokenTransactionResponseValidationError{}

// Validate checks the field values on
// OperatorSpecificTokenTransactionSignablePayload with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OperatorSpecificTokenTransactionSignablePayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// OperatorSpecificTokenTransactionSignablePayload with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// OperatorSpecificTokenTransactionSignablePayloadMultiError, or nil if none found.
func (m *OperatorSpecificTokenTransactionSignablePayload) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorSpecificTokenTransactionSignablePayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetFinalTokenTransactionHash()) != 32 {
		err := OperatorSpecificTokenTransactionSignablePayloadValidationError{
			field:  "FinalTokenTransactionHash",
			reason: "value length must be 32 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetOperatorIdentityPublicKey()) != 33 {
		err := OperatorSpecificTokenTransactionSignablePayloadValidationError{
			field:  "OperatorIdentityPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return OperatorSpecificTokenTransactionSignablePayloadMultiError(errors)
	}

	return nil
}

// OperatorSpecificTokenTransactionSignablePayloadMultiError is an error
// wrapping multiple validation errors returned by
// OperatorSpecificTokenTransactionSignablePayload.ValidateAll() if the
// designated constraints aren't met.
type OperatorSpecificTokenTransactionSignablePayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorSpecificTokenTransactionSignablePayloadMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorSpecificTokenTransactionSignablePayloadMultiError) AllErrors() []error { return m }

// OperatorSpecificTokenTransactionSignablePayloadValidationError is the
// validation error returned by
// OperatorSpecificTokenTransactionSignablePayload.Validate if the designated
// constraints aren't met.
type OperatorSpecificTokenTransactionSignablePayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorSpecificTokenTransactionSignablePayloadValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e OperatorSpecificTokenTransactionSignablePayloadValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e OperatorSpecificTokenTransactionSignablePayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorSpecificTokenTransactionSignablePayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorSpecificTokenTransactionSignablePayloadValidationError) ErrorName() string {
	return "OperatorSpecificTokenTransactionSignablePayloadValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorSpecificTokenTransactionSignablePayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorSpecificTokenTransactionSignablePayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorSpecificTokenTransactionSignablePayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorSpecificTokenTransactionSignablePayloadValidationError{}

// Validate checks the field values on OperatorSpecificOwnerSignature with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorSpecificOwnerSignature) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorSpecificOwnerSignature with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// OperatorSpecificOwnerSignatureMultiError, or nil if none found.
func (m *OperatorSpecificOwnerSignature) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorSpecificOwnerSignature) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOwnerSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorSpecificOwnerSignatureValidationError{
					field:  "OwnerSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorSpecificOwnerSignatureValidationError{
					field:  "OwnerSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOwnerSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorSpecificOwnerSignatureValidationError{
				field:  "OwnerSignature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorSpecificOwnerSignatureValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorSpecificOwnerSignatureValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorSpecificOwnerSignatureValidationError{
				field:  "Payload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OperatorSpecificOwnerSignatureMultiError(errors)
	}

	return nil
}

// OperatorSpecificOwnerSignatureMultiError is an error wrapping multiple
// validation errors returned by OperatorSpecificOwnerSignature.ValidateAll()
// if the designated constraints aren't met.
type OperatorSpecificOwnerSignatureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorSpecificOwnerSignatureMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorSpecificOwnerSignatureMultiError) AllErrors() []error { return m }

// OperatorSpecificOwnerSignatureValidationError is the validation error
// returned by OperatorSpecificOwnerSignature.Validate if the designated
// constraints aren't met.
type OperatorSpecificOwnerSignatureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorSpecificOwnerSignatureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorSpecificOwnerSignatureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorSpecificOwnerSignatureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorSpecificOwnerSignatureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorSpecificOwnerSignatureValidationError) ErrorName() string {
	return "OperatorSpecificOwnerSignatureValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorSpecificOwnerSignatureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorSpecificOwnerSignature.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorSpecificOwnerSignatureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorSpecificOwnerSignatureValidationError{}

// Validate checks the field values on SignTokenTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignTokenTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignTokenTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignTokenTransactionRequestMultiError, or nil if none found.
func (m *SignTokenTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SignTokenTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignTokenTransactionRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignTokenTransactionRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignTokenTransactionRequestValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOperatorSpecificSignatures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignTokenTransactionRequestValidationError{
						field:  fmt.Sprintf("OperatorSpecificSignatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignTokenTransactionRequestValidationError{
						field:  fmt.Sprintf("OperatorSpecificSignatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignTokenTransactionRequestValidationError{
					field:  fmt.Sprintf("OperatorSpecificSignatures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetIdentityPublicKey()) != 33 {
		err := SignTokenTransactionRequestValidationError{
			field:  "IdentityPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SignTokenTransactionRequestMultiError(errors)
	}

	return nil
}

// SignTokenTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by SignTokenTransactionRequest.ValidateAll() if
// the designated constraints aren't met.
type SignTokenTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignTokenTransactionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignTokenTransactionRequestMultiError) AllErrors() []error { return m }

// SignTokenTransactionRequestValidationError is the validation error returned
// by SignTokenTransactionRequest.Validate if the designated constraints
// aren't met.
type SignTokenTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignTokenTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignTokenTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignTokenTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignTokenTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignTokenTransactionRequestValidationError) ErrorName() string {
	return "SignTokenTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SignTokenTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignTokenTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignTokenTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignTokenTransactionRequestValidationError{}

// Validate checks the field values on KeyshareWithIndex with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *KeyshareWithIndex) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyshareWithIndex with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KeyshareWithIndexMultiError, or nil if none found.
func (m *KeyshareWithIndex) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyshareWithIndex) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InputIndex

	if len(m.GetKeyshare()) != 32 {
		err := KeyshareWithIndexValidationError{
			field:  "Keyshare",
			reason: "value length must be 32 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return KeyshareWithIndexMultiError(errors)
	}

	return nil
}

// KeyshareWithIndexMultiError is an error wrapping multiple validation errors
// returned by KeyshareWithIndex.ValidateAll() if the designated constraints
// aren't met.
type KeyshareWithIndexMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyshareWithIndexMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyshareWithIndexMultiError) AllErrors() []error { return m }

// KeyshareWithIndexValidationError is the validation error returned by
// KeyshareWithIndex.Validate if the designated constraints aren't met.
type KeyshareWithIndexValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyshareWithIndexValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyshareWithIndexValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyshareWithIndexValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyshareWithIndexValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyshareWithIndexValidationError) ErrorName() string {
	return "KeyshareWithIndexValidationError"
}

// Error satisfies the builtin error interface
func (e KeyshareWithIndexValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyshareWithIndex.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyshareWithIndexValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyshareWithIndexValidationError{}

// Validate checks the field values on SignTokenTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignTokenTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignTokenTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignTokenTransactionResponseMultiError, or nil if none found.
func (m *SignTokenTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SignTokenTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetSparkOperatorSignature()); l < 64 || l > 73 {
		err := SignTokenTransactionResponseValidationError{
			field:  "SparkOperatorSignature",
			reason: "value length must be between 64 and 73 bytes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRevocationKeyshares() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignTokenTransactionResponseValidationError{
						field:  fmt.Sprintf("RevocationKeyshares[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignTokenTransactionResponseValidationError{
						field:  fmt.Sprintf("RevocationKeyshares[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignTokenTransactionResponseValidationError{
					field:  fmt.Sprintf("RevocationKeyshares[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SignTokenTransactionResponseMultiError(errors)
	}

	return nil
}

// SignTokenTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by SignTokenTransactionResponse.ValidateAll() if
// the designated constraints aren't met.
type SignTokenTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignTokenTransactionResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignTokenTransactionResponseMultiError) AllErrors() []error { return m }

// SignTokenTransactionResponseValidationError is the validation error returned
// by SignTokenTransactionResponse.Validate if the designated constraints
// aren't met.
type SignTokenTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignTokenTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignTokenTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignTokenTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignTokenTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignTokenTransactionResponseValidationError) ErrorName() string {
	return "SignTokenTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SignTokenTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignTokenTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignTokenTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignTokenTransactionResponseValidationError{}

// Validate checks the field values on RevocationSecretWithIndex with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RevocationSecretWithIndex) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RevocationSecretWithIndex with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RevocationSecretWithIndexMultiError, or nil if none found.
func (m *RevocationSecretWithIndex) ValidateAll() error {
	return m.validate(true)
}

func (m *RevocationSecretWithIndex) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InputIndex

	if len(m.GetRevocationSecret()) != 32 {
		err := RevocationSecretWithIndexValidationError{
			field:  "RevocationSecret",
			reason: "value length must be 32 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RevocationSecretWithIndexMultiError(errors)
	}

	return nil
}

// RevocationSecretWithIndexMultiError is an error wrapping multiple validation
// errors returned by RevocationSecretWithIndex.ValidateAll() if the
// designated constraints aren't met.
type RevocationSecretWithIndexMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RevocationSecretWithIndexMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RevocationSecretWithIndexMultiError) AllErrors() []error { return m }

// RevocationSecretWithIndexValidationError is the validation error returned by
// RevocationSecretWithIndex.Validate if the designated constraints aren't met.
type RevocationSecretWithIndexValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RevocationSecretWithIndexValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RevocationSecretWithIndexValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RevocationSecretWithIndexValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RevocationSecretWithIndexValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RevocationSecretWithIndexValidationError) ErrorName() string {
	return "RevocationSecretWithIndexValidationError"
}

// Error satisfies the builtin error interface
func (e RevocationSecretWithIndexValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRevocationSecretWithIndex.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RevocationSecretWithIndexValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RevocationSecretWithIndexValidationError{}

// Validate checks the field values on FinalizeTokenTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeTokenTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeTokenTransactionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FinalizeTokenTransactionRequestMultiError, or nil if none found.
func (m *FinalizeTokenTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeTokenTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinalizeTokenTransactionRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinalizeTokenTransactionRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinalizeTokenTransactionRequestValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRevocationSecrets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinalizeTokenTransactionRequestValidationError{
						field:  fmt.Sprintf("RevocationSecrets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinalizeTokenTransactionRequestValidationError{
						field:  fmt.Sprintf("RevocationSecrets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinalizeTokenTransactionRequestValidationError{
					field:  fmt.Sprintf("RevocationSecrets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetIdentityPublicKey()) != 33 {
		err := FinalizeTokenTransactionRequestValidationError{
			field:  "IdentityPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for SparkPaymentIntent

	if len(errors) > 0 {
		return FinalizeTokenTransactionRequestMultiError(errors)
	}

	return nil
}

// FinalizeTokenTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by FinalizeTokenTransactionRequest.ValidateAll()
// if the designated constraints aren't met.
type FinalizeTokenTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeTokenTransactionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeTokenTransactionRequestMultiError) AllErrors() []error { return m }

// FinalizeTokenTransactionRequestValidationError is the validation error
// returned by FinalizeTokenTransactionRequest.Validate if the designated
// constraints aren't met.
type FinalizeTokenTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeTokenTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeTokenTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeTokenTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeTokenTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeTokenTransactionRequestValidationError) ErrorName() string {
	return "FinalizeTokenTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeTokenTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeTokenTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeTokenTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeTokenTransactionRequestValidationError{}

// Validate checks the field values on FreezeTokensPayload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FreezeTokensPayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FreezeTokensPayload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FreezeTokensPayloadMultiError, or nil if none found.
func (m *FreezeTokensPayload) ValidateAll() error {
	return m.validate(true)
}

func (m *FreezeTokensPayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetOwnerPublicKey()) != 33 {
		err := FreezeTokensPayloadValidationError{
			field:  "OwnerPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTokenPublicKey()) != 33 {
		err := FreezeTokensPayloadValidationError{
			field:  "TokenPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IssuerProvidedTimestamp

	if len(m.GetOperatorIdentityPublicKey()) != 33 {
		err := FreezeTokensPayloadValidationError{
			field:  "OperatorIdentityPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ShouldUnfreeze

	if m.TokenIdentifier != nil {

		if len(m.GetTokenIdentifier()) != 32 {
			err := FreezeTokensPayloadValidationError{
				field:  "TokenIdentifier",
				reason: "value length must be 32 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return FreezeTokensPayloadMultiError(errors)
	}

	return nil
}

// FreezeTokensPayloadMultiError is an error wrapping multiple validation
// errors returned by FreezeTokensPayload.ValidateAll() if the designated
// constraints aren't met.
type FreezeTokensPayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FreezeTokensPayloadMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FreezeTokensPayloadMultiError) AllErrors() []error { return m }

// FreezeTokensPayloadValidationError is the validation error returned by
// FreezeTokensPayload.Validate if the designated constraints aren't met.
type FreezeTokensPayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FreezeTokensPayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FreezeTokensPayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FreezeTokensPayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FreezeTokensPayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FreezeTokensPayloadValidationError) ErrorName() string {
	return "FreezeTokensPayloadValidationError"
}

// Error satisfies the builtin error interface
func (e FreezeTokensPayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFreezeTokensPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FreezeTokensPayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FreezeTokensPayloadValidationError{}

// Validate checks the field values on FreezeTokensRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FreezeTokensRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FreezeTokensRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FreezeTokensRequestMultiError, or nil if none found.
func (m *FreezeTokensRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FreezeTokensRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFreezeTokensPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FreezeTokensRequestValidationError{
					field:  "FreezeTokensPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FreezeTokensRequestValidationError{
					field:  "FreezeTokensPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFreezeTokensPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FreezeTokensRequestValidationError{
				field:  "FreezeTokensPayload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetIssuerSignature()); l < 64 || l > 73 {
		err := FreezeTokensRequestValidationError{
			field:  "IssuerSignature",
			reason: "value length must be between 64 and 73 bytes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return FreezeTokensRequestMultiError(errors)
	}

	return nil
}

// FreezeTokensRequestMultiError is an error wrapping multiple validation
// errors returned by FreezeTokensRequest.ValidateAll() if the designated
// constraints aren't met.
type FreezeTokensRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FreezeTokensRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FreezeTokensRequestMultiError) AllErrors() []error { return m }

// FreezeTokensRequestValidationError is the validation error returned by
// FreezeTokensRequest.Validate if the designated constraints aren't met.
type FreezeTokensRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FreezeTokensRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FreezeTokensRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FreezeTokensRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FreezeTokensRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FreezeTokensRequestValidationError) ErrorName() string {
	return "FreezeTokensRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FreezeTokensRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFreezeTokensRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FreezeTokensRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FreezeTokensRequestValidationError{}

// Validate checks the field values on FreezeTokensResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FreezeTokensResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FreezeTokensResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FreezeTokensResponseMultiError, or nil if none found.
func (m *FreezeTokensResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FreezeTokensResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetImpactedOutputIds() {
		_, _ = idx, item

		if err := m._validateUuid(item); err != nil {
			err = FreezeTokensResponseValidationError{
				field:  fmt.Sprintf("ImpactedOutputIds[%v]", idx),
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for ImpactedTokenAmount

	if len(errors) > 0 {
		return FreezeTokensResponseMultiError(errors)
	}

	return nil
}

func (m *FreezeTokensResponse) _validateUuid(uuid string) error {
	if matched := _spark_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// FreezeTokensResponseMultiError is an error wrapping multiple validation
// errors returned by FreezeTokensResponse.ValidateAll() if the designated
// constraints aren't met.
type FreezeTokensResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FreezeTokensResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FreezeTokensResponseMultiError) AllErrors() []error { return m }

// FreezeTokensResponseValidationError is the validation error returned by
// FreezeTokensResponse.Validate if the designated constraints aren't met.
type FreezeTokensResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FreezeTokensResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FreezeTokensResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FreezeTokensResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FreezeTokensResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FreezeTokensResponseValidationError) ErrorName() string {
	return "FreezeTokensResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FreezeTokensResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFreezeTokensResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FreezeTokensResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FreezeTokensResponseValidationError{}

// Validate checks the field values on QueryTokenOutputsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryTokenOutputsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryTokenOutputsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryTokenOutputsRequestMultiError, or nil if none found.
func (m *QueryTokenOutputsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryTokenOutputsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOwnerPublicKeys() {
		_, _ = idx, item

		if len(item) != 33 {
			err := QueryTokenOutputsRequestValidationError{
				field:  fmt.Sprintf("OwnerPublicKeys[%v]", idx),
				reason: "value length must be 33 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetTokenPublicKeys() {
		_, _ = idx, item

		if len(item) != 33 {
			err := QueryTokenOutputsRequestValidationError{
				field:  fmt.Sprintf("TokenPublicKeys[%v]", idx),
				reason: "value length must be 33 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetTokenIdentifiers() {
		_, _ = idx, item

		if len(item) != 32 {
			err := QueryTokenOutputsRequestValidationError{
				field:  fmt.Sprintf("TokenIdentifiers[%v]", idx),
				reason: "value length must be 32 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Network

	if len(errors) > 0 {
		return QueryTokenOutputsRequestMultiError(errors)
	}

	return nil
}

// QueryTokenOutputsRequestMultiError is an error wrapping multiple validation
// errors returned by QueryTokenOutputsRequest.ValidateAll() if the designated
// constraints aren't met.
type QueryTokenOutputsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryTokenOutputsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryTokenOutputsRequestMultiError) AllErrors() []error { return m }

// QueryTokenOutputsRequestValidationError is the validation error returned by
// QueryTokenOutputsRequest.Validate if the designated constraints aren't met.
type QueryTokenOutputsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryTokenOutputsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryTokenOutputsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryTokenOutputsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryTokenOutputsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryTokenOutputsRequestValidationError) ErrorName() string {
	return "QueryTokenOutputsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryTokenOutputsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryTokenOutputsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryTokenOutputsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryTokenOutputsRequestValidationError{}

// Validate checks the field values on QueryTokenTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryTokenTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryTokenTransactionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryTokenTransactionsRequestMultiError, or nil if none found.
func (m *QueryTokenTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryTokenTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOutputIds() {
		_, _ = idx, item

		if err := m._validateUuid(item); err != nil {
			err = QueryTokenTransactionsRequestValidationError{
				field:  fmt.Sprintf("OutputIds[%v]", idx),
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetOwnerPublicKeys() {
		_, _ = idx, item

		if len(item) != 33 {
			err := QueryTokenTransactionsRequestValidationError{
				field:  fmt.Sprintf("OwnerPublicKeys[%v]", idx),
				reason: "value length must be 33 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetTokenPublicKeys() {
		_, _ = idx, item

		if len(item) != 33 {
			err := QueryTokenTransactionsRequestValidationError{
				field:  fmt.Sprintf("TokenPublicKeys[%v]", idx),
				reason: "value length must be 33 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetTokenIdentifiers() {
		_, _ = idx, item

		if len(item) != 32 {
			err := QueryTokenTransactionsRequestValidationError{
				field:  fmt.Sprintf("TokenIdentifiers[%v]", idx),
				reason: "value length must be 32 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetTokenTransactionHashes() {
		_, _ = idx, item

		if len(item) != 32 {
			err := QueryTokenTransactionsRequestValidationError{
				field:  fmt.Sprintf("TokenTransactionHashes[%v]", idx),
				reason: "value length must be 32 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Limit

	// no validation rules for Offset

	if len(errors) > 0 {
		return QueryTokenTransactionsRequestMultiError(errors)
	}

	return nil
}

func (m *QueryTokenTransactionsRequest) _validateUuid(uuid string) error {
	if matched := _spark_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// QueryTokenTransactionsRequestMultiError is an error wrapping multiple
// validation errors returned by QueryTokenTransactionsRequest.ValidateAll()
// if the designated constraints aren't met.
type QueryTokenTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryTokenTransactionsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryTokenTransactionsRequestMultiError) AllErrors() []error { return m }

// QueryTokenTransactionsRequestValidationError is the validation error
// returned by QueryTokenTransactionsRequest.Validate if the designated
// constraints aren't met.
type QueryTokenTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryTokenTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryTokenTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryTokenTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryTokenTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryTokenTransactionsRequestValidationError) ErrorName() string {
	return "QueryTokenTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryTokenTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryTokenTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryTokenTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryTokenTransactionsRequestValidationError{}

// Validate checks the field values on QueryTokenTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryTokenTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryTokenTransactionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryTokenTransactionsResponseMultiError, or nil if none found.
func (m *QueryTokenTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryTokenTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTokenTransactionsWithStatus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryTokenTransactionsResponseValidationError{
						field:  fmt.Sprintf("TokenTransactionsWithStatus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryTokenTransactionsResponseValidationError{
						field:  fmt.Sprintf("TokenTransactionsWithStatus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryTokenTransactionsResponseValidationError{
					field:  fmt.Sprintf("TokenTransactionsWithStatus[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Offset

	if len(errors) > 0 {
		return QueryTokenTransactionsResponseMultiError(errors)
	}

	return nil
}

// QueryTokenTransactionsResponseMultiError is an error wrapping multiple
// validation errors returned by QueryTokenTransactionsResponse.ValidateAll()
// if the designated constraints aren't met.
type QueryTokenTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryTokenTransactionsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryTokenTransactionsResponseMultiError) AllErrors() []error { return m }

// QueryTokenTransactionsResponseValidationError is the validation error
// returned by QueryTokenTransactionsResponse.Validate if the designated
// constraints aren't met.
type QueryTokenTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryTokenTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryTokenTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryTokenTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryTokenTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryTokenTransactionsResponseValidationError) ErrorName() string {
	return "QueryTokenTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryTokenTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryTokenTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryTokenTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryTokenTransactionsResponseValidationError{}

// Validate checks the field values on OutputWithPreviousTransactionData with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *OutputWithPreviousTransactionData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OutputWithPreviousTransactionData
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// OutputWithPreviousTransactionDataMultiError, or nil if none found.
func (m *OutputWithPreviousTransactionData) ValidateAll() error {
	return m.validate(true)
}

func (m *OutputWithPreviousTransactionData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutputWithPreviousTransactionDataValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutputWithPreviousTransactionDataValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutputWithPreviousTransactionDataValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetPreviousTransactionHash()) != 32 {
		err := OutputWithPreviousTransactionDataValidationError{
			field:  "PreviousTransactionHash",
			reason: "value length must be 32 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PreviousTransactionVout

	if len(errors) > 0 {
		return OutputWithPreviousTransactionDataMultiError(errors)
	}

	return nil
}

// OutputWithPreviousTransactionDataMultiError is an error wrapping multiple
// validation errors returned by
// OutputWithPreviousTransactionData.ValidateAll() if the designated
// constraints aren't met.
type OutputWithPreviousTransactionDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OutputWithPreviousTransactionDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OutputWithPreviousTransactionDataMultiError) AllErrors() []error { return m }

// OutputWithPreviousTransactionDataValidationError is the validation error
// returned by OutputWithPreviousTransactionData.Validate if the designated
// constraints aren't met.
type OutputWithPreviousTransactionDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OutputWithPreviousTransactionDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OutputWithPreviousTransactionDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OutputWithPreviousTransactionDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OutputWithPreviousTransactionDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OutputWithPreviousTransactionDataValidationError) ErrorName() string {
	return "OutputWithPreviousTransactionDataValidationError"
}

// Error satisfies the builtin error interface
func (e OutputWithPreviousTransactionDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOutputWithPreviousTransactionData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OutputWithPreviousTransactionDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OutputWithPreviousTransactionDataValidationError{}

// Validate checks the field values on QueryTokenOutputsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryTokenOutputsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryTokenOutputsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryTokenOutputsResponseMultiError, or nil if none found.
func (m *QueryTokenOutputsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryTokenOutputsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOutputsWithPreviousTransactionData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryTokenOutputsResponseValidationError{
						field:  fmt.Sprintf("OutputsWithPreviousTransactionData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryTokenOutputsResponseValidationError{
						field:  fmt.Sprintf("OutputsWithPreviousTransactionData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryTokenOutputsResponseValidationError{
					field:  fmt.Sprintf("OutputsWithPreviousTransactionData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryTokenOutputsResponseMultiError(errors)
	}

	return nil
}

// QueryTokenOutputsResponseMultiError is an error wrapping multiple validation
// errors returned by QueryTokenOutputsResponse.ValidateAll() if the
// designated constraints aren't met.
type QueryTokenOutputsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryTokenOutputsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryTokenOutputsResponseMultiError) AllErrors() []error { return m }

// QueryTokenOutputsResponseValidationError is the validation error returned by
// QueryTokenOutputsResponse.Validate if the designated constraints aren't met.
type QueryTokenOutputsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryTokenOutputsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryTokenOutputsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryTokenOutputsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryTokenOutputsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryTokenOutputsResponseValidationError) ErrorName() string {
	return "QueryTokenOutputsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryTokenOutputsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryTokenOutputsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryTokenOutputsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryTokenOutputsResponseValidationError{}

// Validate checks the field values on TreeNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TreeNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TreeNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TreeNodeMultiError, or nil
// if none found.
func (m *TreeNode) ValidateAll() error {
	return m.validate(true)
}

func (m *TreeNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TreeId

	// no validation rules for Value

	// no validation rules for NodeTx

	// no validation rules for RefundTx

	// no validation rules for Vout

	// no validation rules for VerifyingPublicKey

	// no validation rules for OwnerIdentityPublicKey

	if all {
		switch v := interface{}(m.GetSigningKeyshare()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TreeNodeValidationError{
					field:  "SigningKeyshare",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TreeNodeValidationError{
					field:  "SigningKeyshare",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningKeyshare()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TreeNodeValidationError{
				field:  "SigningKeyshare",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	// no validation rules for Network

	if all {
		switch v := interface{}(m.GetCreatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TreeNodeValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TreeNodeValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TreeNodeValidationError{
				field:  "CreatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TreeNodeValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TreeNodeValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TreeNodeValidationError{
				field:  "UpdatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OwnerSigningPublicKey

	// no validation rules for DirectTx

	// no validation rules for DirectRefundTx

	// no validation rules for DirectFromCpfpRefundTx

	if m.ParentNodeId != nil {
		// no validation rules for ParentNodeId
	}

	if len(errors) > 0 {
		return TreeNodeMultiError(errors)
	}

	return nil
}

// TreeNodeMultiError is an error wrapping multiple validation errors returned
// by TreeNode.ValidateAll() if the designated constraints aren't met.
type TreeNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TreeNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TreeNodeMultiError) AllErrors() []error { return m }

// TreeNodeValidationError is the validation error returned by
// TreeNode.Validate if the designated constraints aren't met.
type TreeNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TreeNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TreeNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TreeNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TreeNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TreeNodeValidationError) ErrorName() string { return "TreeNodeValidationError" }

// Error satisfies the builtin error interface
func (e TreeNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTreeNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TreeNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TreeNodeValidationError{}

// Validate checks the field values on FinalizeNodeSignaturesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeNodeSignaturesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeNodeSignaturesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FinalizeNodeSignaturesRequestMultiError, or nil if none found.
func (m *FinalizeNodeSignaturesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeNodeSignaturesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Intent

	for idx, item := range m.GetNodeSignatures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinalizeNodeSignaturesRequestValidationError{
						field:  fmt.Sprintf("NodeSignatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinalizeNodeSignaturesRequestValidationError{
						field:  fmt.Sprintf("NodeSignatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinalizeNodeSignaturesRequestValidationError{
					field:  fmt.Sprintf("NodeSignatures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FinalizeNodeSignaturesRequestMultiError(errors)
	}

	return nil
}

// FinalizeNodeSignaturesRequestMultiError is an error wrapping multiple
// validation errors returned by FinalizeNodeSignaturesRequest.ValidateAll()
// if the designated constraints aren't met.
type FinalizeNodeSignaturesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeNodeSignaturesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeNodeSignaturesRequestMultiError) AllErrors() []error { return m }

// FinalizeNodeSignaturesRequestValidationError is the validation error
// returned by FinalizeNodeSignaturesRequest.Validate if the designated
// constraints aren't met.
type FinalizeNodeSignaturesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeNodeSignaturesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeNodeSignaturesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeNodeSignaturesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeNodeSignaturesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeNodeSignaturesRequestValidationError) ErrorName() string {
	return "FinalizeNodeSignaturesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeNodeSignaturesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeNodeSignaturesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeNodeSignaturesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeNodeSignaturesRequestValidationError{}

// Validate checks the field values on FinalizeNodeSignaturesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeNodeSignaturesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeNodeSignaturesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FinalizeNodeSignaturesResponseMultiError, or nil if none found.
func (m *FinalizeNodeSignaturesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeNodeSignaturesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinalizeNodeSignaturesResponseValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinalizeNodeSignaturesResponseValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinalizeNodeSignaturesResponseValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FinalizeNodeSignaturesResponseMultiError(errors)
	}

	return nil
}

// FinalizeNodeSignaturesResponseMultiError is an error wrapping multiple
// validation errors returned by FinalizeNodeSignaturesResponse.ValidateAll()
// if the designated constraints aren't met.
type FinalizeNodeSignaturesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeNodeSignaturesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeNodeSignaturesResponseMultiError) AllErrors() []error { return m }

// FinalizeNodeSignaturesResponseValidationError is the validation error
// returned by FinalizeNodeSignaturesResponse.Validate if the designated
// constraints aren't met.
type FinalizeNodeSignaturesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeNodeSignaturesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeNodeSignaturesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeNodeSignaturesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeNodeSignaturesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeNodeSignaturesResponseValidationError) ErrorName() string {
	return "FinalizeNodeSignaturesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeNodeSignaturesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeNodeSignaturesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeNodeSignaturesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeNodeSignaturesResponseValidationError{}

// Validate checks the field values on SecretShare with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecretShare) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecretShare with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecretShareMultiError, or
// nil if none found.
func (m *SecretShare) ValidateAll() error {
	return m.validate(true)
}

func (m *SecretShare) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SecretShare

	if len(errors) > 0 {
		return SecretShareMultiError(errors)
	}

	return nil
}

// SecretShareMultiError is an error wrapping multiple validation errors
// returned by SecretShare.ValidateAll() if the designated constraints aren't met.
type SecretShareMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecretShareMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecretShareMultiError) AllErrors() []error { return m }

// SecretShareValidationError is the validation error returned by
// SecretShare.Validate if the designated constraints aren't met.
type SecretShareValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecretShareValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecretShareValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecretShareValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecretShareValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecretShareValidationError) ErrorName() string { return "SecretShareValidationError" }

// Error satisfies the builtin error interface
func (e SecretShareValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecretShare.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecretShareValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecretShareValidationError{}

// Validate checks the field values on SecretProof with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecretProof) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecretProof with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecretProofMultiError, or
// nil if none found.
func (m *SecretProof) ValidateAll() error {
	return m.validate(true)
}

func (m *SecretProof) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SecretProofMultiError(errors)
	}

	return nil
}

// SecretProofMultiError is an error wrapping multiple validation errors
// returned by SecretProof.ValidateAll() if the designated constraints aren't met.
type SecretProofMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecretProofMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecretProofMultiError) AllErrors() []error { return m }

// SecretProofValidationError is the validation error returned by
// SecretProof.Validate if the designated constraints aren't met.
type SecretProofValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecretProofValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecretProofValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecretProofValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecretProofValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecretProofValidationError) ErrorName() string { return "SecretProofValidationError" }

// Error satisfies the builtin error interface
func (e SecretProofValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecretProof.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecretProofValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecretProofValidationError{}

// Validate checks the field values on LeafRefundTxSigningJob with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LeafRefundTxSigningJob) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeafRefundTxSigningJob with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeafRefundTxSigningJobMultiError, or nil if none found.
func (m *LeafRefundTxSigningJob) ValidateAll() error {
	return m.validate(true)
}

func (m *LeafRefundTxSigningJob) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	if all {
		switch v := interface{}(m.GetRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeafRefundTxSigningJobValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeafRefundTxSigningJobValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeafRefundTxSigningJobValidationError{
				field:  "RefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeafRefundTxSigningJobValidationError{
					field:  "DirectRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeafRefundTxSigningJobValidationError{
					field:  "DirectRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeafRefundTxSigningJobValidationError{
				field:  "DirectRefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectFromCpfpRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeafRefundTxSigningJobValidationError{
					field:  "DirectFromCpfpRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeafRefundTxSigningJobValidationError{
					field:  "DirectFromCpfpRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectFromCpfpRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeafRefundTxSigningJobValidationError{
				field:  "DirectFromCpfpRefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LeafRefundTxSigningJobMultiError(errors)
	}

	return nil
}

// LeafRefundTxSigningJobMultiError is an error wrapping multiple validation
// errors returned by LeafRefundTxSigningJob.ValidateAll() if the designated
// constraints aren't met.
type LeafRefundTxSigningJobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeafRefundTxSigningJobMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeafRefundTxSigningJobMultiError) AllErrors() []error { return m }

// LeafRefundTxSigningJobValidationError is the validation error returned by
// LeafRefundTxSigningJob.Validate if the designated constraints aren't met.
type LeafRefundTxSigningJobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeafRefundTxSigningJobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeafRefundTxSigningJobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeafRefundTxSigningJobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeafRefundTxSigningJobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeafRefundTxSigningJobValidationError) ErrorName() string {
	return "LeafRefundTxSigningJobValidationError"
}

// Error satisfies the builtin error interface
func (e LeafRefundTxSigningJobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeafRefundTxSigningJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeafRefundTxSigningJobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeafRefundTxSigningJobValidationError{}

// Validate checks the field values on UserSignedTxSigningJob with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserSignedTxSigningJob) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserSignedTxSigningJob with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserSignedTxSigningJobMultiError, or nil if none found.
func (m *UserSignedTxSigningJob) ValidateAll() error {
	return m.validate(true)
}

func (m *UserSignedTxSigningJob) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	// no validation rules for SigningPublicKey

	// no validation rules for RawTx

	if all {
		switch v := interface{}(m.GetSigningNonceCommitment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserSignedTxSigningJobValidationError{
					field:  "SigningNonceCommitment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserSignedTxSigningJobValidationError{
					field:  "SigningNonceCommitment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningNonceCommitment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserSignedTxSigningJobValidationError{
				field:  "SigningNonceCommitment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserSignature

	if all {
		switch v := interface{}(m.GetSigningCommitments()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserSignedTxSigningJobValidationError{
					field:  "SigningCommitments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserSignedTxSigningJobValidationError{
					field:  "SigningCommitments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningCommitments()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserSignedTxSigningJobValidationError{
				field:  "SigningCommitments",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserSignedTxSigningJobMultiError(errors)
	}

	return nil
}

// UserSignedTxSigningJobMultiError is an error wrapping multiple validation
// errors returned by UserSignedTxSigningJob.ValidateAll() if the designated
// constraints aren't met.
type UserSignedTxSigningJobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserSignedTxSigningJobMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserSignedTxSigningJobMultiError) AllErrors() []error { return m }

// UserSignedTxSigningJobValidationError is the validation error returned by
// UserSignedTxSigningJob.Validate if the designated constraints aren't met.
type UserSignedTxSigningJobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserSignedTxSigningJobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserSignedTxSigningJobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserSignedTxSigningJobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserSignedTxSigningJobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserSignedTxSigningJobValidationError) ErrorName() string {
	return "UserSignedTxSigningJobValidationError"
}

// Error satisfies the builtin error interface
func (e UserSignedTxSigningJobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserSignedTxSigningJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserSignedTxSigningJobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserSignedTxSigningJobValidationError{}

// Validate checks the field values on LeafRefundTxSigningResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LeafRefundTxSigningResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeafRefundTxSigningResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeafRefundTxSigningResultMultiError, or nil if none found.
func (m *LeafRefundTxSigningResult) ValidateAll() error {
	return m.validate(true)
}

func (m *LeafRefundTxSigningResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	if all {
		switch v := interface{}(m.GetRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeafRefundTxSigningResultValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeafRefundTxSigningResultValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeafRefundTxSigningResultValidationError{
				field:  "RefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VerifyingKey

	if all {
		switch v := interface{}(m.GetDirectRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeafRefundTxSigningResultValidationError{
					field:  "DirectRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeafRefundTxSigningResultValidationError{
					field:  "DirectRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeafRefundTxSigningResultValidationError{
				field:  "DirectRefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectFromCpfpRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeafRefundTxSigningResultValidationError{
					field:  "DirectFromCpfpRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeafRefundTxSigningResultValidationError{
					field:  "DirectFromCpfpRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectFromCpfpRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeafRefundTxSigningResultValidationError{
				field:  "DirectFromCpfpRefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LeafRefundTxSigningResultMultiError(errors)
	}

	return nil
}

// LeafRefundTxSigningResultMultiError is an error wrapping multiple validation
// errors returned by LeafRefundTxSigningResult.ValidateAll() if the
// designated constraints aren't met.
type LeafRefundTxSigningResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeafRefundTxSigningResultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeafRefundTxSigningResultMultiError) AllErrors() []error { return m }

// LeafRefundTxSigningResultValidationError is the validation error returned by
// LeafRefundTxSigningResult.Validate if the designated constraints aren't met.
type LeafRefundTxSigningResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeafRefundTxSigningResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeafRefundTxSigningResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeafRefundTxSigningResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeafRefundTxSigningResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeafRefundTxSigningResultValidationError) ErrorName() string {
	return "LeafRefundTxSigningResultValidationError"
}

// Error satisfies the builtin error interface
func (e LeafRefundTxSigningResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeafRefundTxSigningResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeafRefundTxSigningResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeafRefundTxSigningResultValidationError{}

// Validate checks the field values on StartUserSignedTransferRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartUserSignedTransferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartUserSignedTransferRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// StartUserSignedTransferRequestMultiError, or nil if none found.
func (m *StartUserSignedTransferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartUserSignedTransferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for OwnerIdentityPublicKey

	for idx, item := range m.GetLeavesToSend() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StartUserSignedTransferRequestValidationError{
						field:  fmt.Sprintf("LeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StartUserSignedTransferRequestValidationError{
						field:  fmt.Sprintf("LeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StartUserSignedTransferRequestValidationError{
					field:  fmt.Sprintf("LeavesToSend[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ReceiverIdentityPublicKey

	if all {
		switch v := interface{}(m.GetExpiryTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartUserSignedTransferRequestValidationError{
					field:  "ExpiryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartUserSignedTransferRequestValidationError{
					field:  "ExpiryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiryTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartUserSignedTransferRequestValidationError{
				field:  "ExpiryTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetDirectLeavesToSend() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StartUserSignedTransferRequestValidationError{
						field:  fmt.Sprintf("DirectLeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StartUserSignedTransferRequestValidationError{
						field:  fmt.Sprintf("DirectLeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StartUserSignedTransferRequestValidationError{
					field:  fmt.Sprintf("DirectLeavesToSend[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDirectFromCpfpLeavesToSend() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StartUserSignedTransferRequestValidationError{
						field:  fmt.Sprintf("DirectFromCpfpLeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StartUserSignedTransferRequestValidationError{
						field:  fmt.Sprintf("DirectFromCpfpLeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StartUserSignedTransferRequestValidationError{
					field:  fmt.Sprintf("DirectFromCpfpLeavesToSend[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StartUserSignedTransferRequestMultiError(errors)
	}

	return nil
}

// StartUserSignedTransferRequestMultiError is an error wrapping multiple
// validation errors returned by StartUserSignedTransferRequest.ValidateAll()
// if the designated constraints aren't met.
type StartUserSignedTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartUserSignedTransferRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartUserSignedTransferRequestMultiError) AllErrors() []error { return m }

// StartUserSignedTransferRequestValidationError is the validation error
// returned by StartUserSignedTransferRequest.Validate if the designated
// constraints aren't met.
type StartUserSignedTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartUserSignedTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartUserSignedTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartUserSignedTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartUserSignedTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartUserSignedTransferRequestValidationError) ErrorName() string {
	return "StartUserSignedTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartUserSignedTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartUserSignedTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartUserSignedTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartUserSignedTransferRequestValidationError{}

// Validate checks the field values on StartTransferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartTransferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartTransferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartTransferRequestMultiError, or nil if none found.
func (m *StartTransferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartTransferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for OwnerIdentityPublicKey

	for idx, item := range m.GetLeavesToSend() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StartTransferRequestValidationError{
						field:  fmt.Sprintf("LeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StartTransferRequestValidationError{
						field:  fmt.Sprintf("LeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StartTransferRequestValidationError{
					field:  fmt.Sprintf("LeavesToSend[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ReceiverIdentityPublicKey

	if all {
		switch v := interface{}(m.GetExpiryTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTransferRequestValidationError{
					field:  "ExpiryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTransferRequestValidationError{
					field:  "ExpiryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiryTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTransferRequestValidationError{
				field:  "ExpiryTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTransferPackage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTransferRequestValidationError{
					field:  "TransferPackage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTransferRequestValidationError{
					field:  "TransferPackage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransferPackage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTransferRequestValidationError{
				field:  "TransferPackage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SparkInvoice

	if len(errors) > 0 {
		return StartTransferRequestMultiError(errors)
	}

	return nil
}

// StartTransferRequestMultiError is an error wrapping multiple validation
// errors returned by StartTransferRequest.ValidateAll() if the designated
// constraints aren't met.
type StartTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartTransferRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartTransferRequestMultiError) AllErrors() []error { return m }

// StartTransferRequestValidationError is the validation error returned by
// StartTransferRequest.Validate if the designated constraints aren't met.
type StartTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartTransferRequestValidationError) ErrorName() string {
	return "StartTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartTransferRequestValidationError{}

// Validate checks the field values on StartTransferResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartTransferResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartTransferResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartTransferResponseMultiError, or nil if none found.
func (m *StartTransferResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartTransferResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTransferResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTransferResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTransferResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSigningResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StartTransferResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StartTransferResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StartTransferResponseValidationError{
					field:  fmt.Sprintf("SigningResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StartTransferResponseMultiError(errors)
	}

	return nil
}

// StartTransferResponseMultiError is an error wrapping multiple validation
// errors returned by StartTransferResponse.ValidateAll() if the designated
// constraints aren't met.
type StartTransferResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartTransferResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartTransferResponseMultiError) AllErrors() []error { return m }

// StartTransferResponseValidationError is the validation error returned by
// StartTransferResponse.Validate if the designated constraints aren't met.
type StartTransferResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartTransferResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartTransferResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartTransferResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartTransferResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartTransferResponseValidationError) ErrorName() string {
	return "StartTransferResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartTransferResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartTransferResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartTransferResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartTransferResponseValidationError{}

// Validate checks the field values on TransferPackage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TransferPackage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferPackage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransferPackageMultiError, or nil if none found.
func (m *TransferPackage) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferPackage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLeavesToSend() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransferPackageValidationError{
						field:  fmt.Sprintf("LeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransferPackageValidationError{
						field:  fmt.Sprintf("LeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransferPackageValidationError{
					field:  fmt.Sprintf("LeavesToSend[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for KeyTweakPackage

	// no validation rules for UserSignature

	for idx, item := range m.GetDirectLeavesToSend() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransferPackageValidationError{
						field:  fmt.Sprintf("DirectLeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransferPackageValidationError{
						field:  fmt.Sprintf("DirectLeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransferPackageValidationError{
					field:  fmt.Sprintf("DirectLeavesToSend[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDirectFromCpfpLeavesToSend() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransferPackageValidationError{
						field:  fmt.Sprintf("DirectFromCpfpLeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransferPackageValidationError{
						field:  fmt.Sprintf("DirectFromCpfpLeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransferPackageValidationError{
					field:  fmt.Sprintf("DirectFromCpfpLeavesToSend[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TransferPackageMultiError(errors)
	}

	return nil
}

// TransferPackageMultiError is an error wrapping multiple validation errors
// returned by TransferPackage.ValidateAll() if the designated constraints
// aren't met.
type TransferPackageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferPackageMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferPackageMultiError) AllErrors() []error { return m }

// TransferPackageValidationError is the validation error returned by
// TransferPackage.Validate if the designated constraints aren't met.
type TransferPackageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferPackageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferPackageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferPackageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferPackageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferPackageValidationError) ErrorName() string { return "TransferPackageValidationError" }

// Error satisfies the builtin error interface
func (e TransferPackageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferPackage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferPackageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferPackageValidationError{}

// Validate checks the field values on SendLeafKeyTweaks with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SendLeafKeyTweaks) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendLeafKeyTweaks with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendLeafKeyTweaksMultiError, or nil if none found.
func (m *SendLeafKeyTweaks) ValidateAll() error {
	return m.validate(true)
}

func (m *SendLeafKeyTweaks) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLeavesToSend() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SendLeafKeyTweaksValidationError{
						field:  fmt.Sprintf("LeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SendLeafKeyTweaksValidationError{
						field:  fmt.Sprintf("LeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SendLeafKeyTweaksValidationError{
					field:  fmt.Sprintf("LeavesToSend[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SendLeafKeyTweaksMultiError(errors)
	}

	return nil
}

// SendLeafKeyTweaksMultiError is an error wrapping multiple validation errors
// returned by SendLeafKeyTweaks.ValidateAll() if the designated constraints
// aren't met.
type SendLeafKeyTweaksMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendLeafKeyTweaksMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendLeafKeyTweaksMultiError) AllErrors() []error { return m }

// SendLeafKeyTweaksValidationError is the validation error returned by
// SendLeafKeyTweaks.Validate if the designated constraints aren't met.
type SendLeafKeyTweaksValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendLeafKeyTweaksValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendLeafKeyTweaksValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendLeafKeyTweaksValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendLeafKeyTweaksValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendLeafKeyTweaksValidationError) ErrorName() string {
	return "SendLeafKeyTweaksValidationError"
}

// Error satisfies the builtin error interface
func (e SendLeafKeyTweaksValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendLeafKeyTweaks.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendLeafKeyTweaksValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendLeafKeyTweaksValidationError{}

// Validate checks the field values on SendLeafKeyTweak with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SendLeafKeyTweak) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendLeafKeyTweak with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendLeafKeyTweakMultiError, or nil if none found.
func (m *SendLeafKeyTweak) ValidateAll() error {
	return m.validate(true)
}

func (m *SendLeafKeyTweak) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	if all {
		switch v := interface{}(m.GetSecretShareTweak()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendLeafKeyTweakValidationError{
					field:  "SecretShareTweak",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendLeafKeyTweakValidationError{
					field:  "SecretShareTweak",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecretShareTweak()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendLeafKeyTweakValidationError{
				field:  "SecretShareTweak",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PubkeySharesTweak

	// no validation rules for SecretCipher

	// no validation rules for Signature

	// no validation rules for RefundSignature

	// no validation rules for DirectRefundSignature

	// no validation rules for DirectFromCpfpRefundSignature

	if len(errors) > 0 {
		return SendLeafKeyTweakMultiError(errors)
	}

	return nil
}

// SendLeafKeyTweakMultiError is an error wrapping multiple validation errors
// returned by SendLeafKeyTweak.ValidateAll() if the designated constraints
// aren't met.
type SendLeafKeyTweakMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendLeafKeyTweakMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendLeafKeyTweakMultiError) AllErrors() []error { return m }

// SendLeafKeyTweakValidationError is the validation error returned by
// SendLeafKeyTweak.Validate if the designated constraints aren't met.
type SendLeafKeyTweakValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendLeafKeyTweakValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendLeafKeyTweakValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendLeafKeyTweakValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendLeafKeyTweakValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendLeafKeyTweakValidationError) ErrorName() string { return "SendLeafKeyTweakValidationError" }

// Error satisfies the builtin error interface
func (e SendLeafKeyTweakValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendLeafKeyTweak.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendLeafKeyTweakValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendLeafKeyTweakValidationError{}

// Validate checks the field values on FinalizeTransferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeTransferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeTransferRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FinalizeTransferRequestMultiError, or nil if none found.
func (m *FinalizeTransferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeTransferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for OwnerIdentityPublicKey

	for idx, item := range m.GetLeavesToSend() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinalizeTransferRequestValidationError{
						field:  fmt.Sprintf("LeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinalizeTransferRequestValidationError{
						field:  fmt.Sprintf("LeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinalizeTransferRequestValidationError{
					field:  fmt.Sprintf("LeavesToSend[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for SparkPaymentIntent

	if len(errors) > 0 {
		return FinalizeTransferRequestMultiError(errors)
	}

	return nil
}

// FinalizeTransferRequestMultiError is an error wrapping multiple validation
// errors returned by FinalizeTransferRequest.ValidateAll() if the designated
// constraints aren't met.
type FinalizeTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeTransferRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeTransferRequestMultiError) AllErrors() []error { return m }

// FinalizeTransferRequestValidationError is the validation error returned by
// FinalizeTransferRequest.Validate if the designated constraints aren't met.
type FinalizeTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeTransferRequestValidationError) ErrorName() string {
	return "FinalizeTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeTransferRequestValidationError{}

// Validate checks the field values on
// FinalizeTransferWithTransferPackageRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FinalizeTransferWithTransferPackageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// FinalizeTransferWithTransferPackageRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// FinalizeTransferWithTransferPackageRequestMultiError, or nil if none found.
func (m *FinalizeTransferWithTransferPackageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeTransferWithTransferPackageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for OwnerIdentityPublicKey

	if all {
		switch v := interface{}(m.GetTransferPackage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinalizeTransferWithTransferPackageRequestValidationError{
					field:  "TransferPackage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinalizeTransferWithTransferPackageRequestValidationError{
					field:  "TransferPackage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransferPackage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinalizeTransferWithTransferPackageRequestValidationError{
				field:  "TransferPackage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FinalizeTransferWithTransferPackageRequestMultiError(errors)
	}

	return nil
}

// FinalizeTransferWithTransferPackageRequestMultiError is an error wrapping
// multiple validation errors returned by
// FinalizeTransferWithTransferPackageRequest.ValidateAll() if the designated
// constraints aren't met.
type FinalizeTransferWithTransferPackageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeTransferWithTransferPackageRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeTransferWithTransferPackageRequestMultiError) AllErrors() []error { return m }

// FinalizeTransferWithTransferPackageRequestValidationError is the validation
// error returned by FinalizeTransferWithTransferPackageRequest.Validate if
// the designated constraints aren't met.
type FinalizeTransferWithTransferPackageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeTransferWithTransferPackageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeTransferWithTransferPackageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeTransferWithTransferPackageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeTransferWithTransferPackageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeTransferWithTransferPackageRequestValidationError) ErrorName() string {
	return "FinalizeTransferWithTransferPackageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeTransferWithTransferPackageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeTransferWithTransferPackageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeTransferWithTransferPackageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeTransferWithTransferPackageRequestValidationError{}

// Validate checks the field values on FinalizeTransferResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeTransferResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeTransferResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FinalizeTransferResponseMultiError, or nil if none found.
func (m *FinalizeTransferResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeTransferResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinalizeTransferResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinalizeTransferResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinalizeTransferResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FinalizeTransferResponseMultiError(errors)
	}

	return nil
}

// FinalizeTransferResponseMultiError is an error wrapping multiple validation
// errors returned by FinalizeTransferResponse.ValidateAll() if the designated
// constraints aren't met.
type FinalizeTransferResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeTransferResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeTransferResponseMultiError) AllErrors() []error { return m }

// FinalizeTransferResponseValidationError is the validation error returned by
// FinalizeTransferResponse.Validate if the designated constraints aren't met.
type FinalizeTransferResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeTransferResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeTransferResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeTransferResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeTransferResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeTransferResponseValidationError) ErrorName() string {
	return "FinalizeTransferResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeTransferResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeTransferResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeTransferResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeTransferResponseValidationError{}

// Validate checks the field values on Transfer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transfer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transfer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransferMultiError, or nil
// if none found.
func (m *Transfer) ValidateAll() error {
	return m.validate(true)
}

func (m *Transfer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for SenderIdentityPublicKey

	// no validation rules for ReceiverIdentityPublicKey

	// no validation rules for Status

	// no validation rules for TotalValue

	if all {
		switch v := interface{}(m.GetExpiryTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "ExpiryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "ExpiryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiryTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferValidationError{
				field:  "ExpiryTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLeaves() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransferValidationError{
						field:  fmt.Sprintf("Leaves[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransferValidationError{
						field:  fmt.Sprintf("Leaves[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransferValidationError{
					field:  fmt.Sprintf("Leaves[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCreatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferValidationError{
				field:  "CreatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferValidationError{
				field:  "UpdatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	// no validation rules for SparkInvoice

	if len(errors) > 0 {
		return TransferMultiError(errors)
	}

	return nil
}

// TransferMultiError is an error wrapping multiple validation errors returned
// by Transfer.ValidateAll() if the designated constraints aren't met.
type TransferMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferMultiError) AllErrors() []error { return m }

// TransferValidationError is the validation error returned by
// Transfer.Validate if the designated constraints aren't met.
type TransferValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferValidationError) ErrorName() string { return "TransferValidationError" }

// Error satisfies the builtin error interface
func (e TransferValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransfer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferValidationError{}

// Validate checks the field values on TransferLeaf with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TransferLeaf) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferLeaf with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransferLeafMultiError, or
// nil if none found.
func (m *TransferLeaf) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferLeaf) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLeaf()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferLeafValidationError{
					field:  "Leaf",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferLeafValidationError{
					field:  "Leaf",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLeaf()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferLeafValidationError{
				field:  "Leaf",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SecretCipher

	// no validation rules for Signature

	// no validation rules for IntermediateRefundTx

	// no validation rules for IntermediateDirectRefundTx

	// no validation rules for IntermediateDirectFromCpfpRefundTx

	// no validation rules for PendingKeyTweakPublicKey

	if len(errors) > 0 {
		return TransferLeafMultiError(errors)
	}

	return nil
}

// TransferLeafMultiError is an error wrapping multiple validation errors
// returned by TransferLeaf.ValidateAll() if the designated constraints aren't met.
type TransferLeafMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferLeafMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferLeafMultiError) AllErrors() []error { return m }

// TransferLeafValidationError is the validation error returned by
// TransferLeaf.Validate if the designated constraints aren't met.
type TransferLeafValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferLeafValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferLeafValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferLeafValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferLeafValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferLeafValidationError) ErrorName() string { return "TransferLeafValidationError" }

// Error satisfies the builtin error interface
func (e TransferLeafValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferLeaf.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferLeafValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferLeafValidationError{}

// Validate checks the field values on TransferFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TransferFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransferFilterMultiError,
// or nil if none found.
func (m *TransferFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for Offset

	// no validation rules for Network

	// no validation rules for Order

	switch v := m.Participant.(type) {
	case *TransferFilter_ReceiverIdentityPublicKey:
		if v == nil {
			err := TransferFilterValidationError{
				field:  "Participant",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ReceiverIdentityPublicKey
	case *TransferFilter_SenderIdentityPublicKey:
		if v == nil {
			err := TransferFilterValidationError{
				field:  "Participant",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for SenderIdentityPublicKey
	case *TransferFilter_SenderOrReceiverIdentityPublicKey:
		if v == nil {
			err := TransferFilterValidationError{
				field:  "Participant",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for SenderOrReceiverIdentityPublicKey
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TransferFilterMultiError(errors)
	}

	return nil
}

// TransferFilterMultiError is an error wrapping multiple validation errors
// returned by TransferFilter.ValidateAll() if the designated constraints
// aren't met.
type TransferFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferFilterMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferFilterMultiError) AllErrors() []error { return m }

// TransferFilterValidationError is the validation error returned by
// TransferFilter.Validate if the designated constraints aren't met.
type TransferFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferFilterValidationError) ErrorName() string { return "TransferFilterValidationError" }

// Error satisfies the builtin error interface
func (e TransferFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferFilterValidationError{}

// Validate checks the field values on QueryTransfersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryTransfersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryTransfersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryTransfersResponseMultiError, or nil if none found.
func (m *QueryTransfersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryTransfersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransfers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryTransfersResponseValidationError{
						field:  fmt.Sprintf("Transfers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryTransfersResponseValidationError{
						field:  fmt.Sprintf("Transfers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryTransfersResponseValidationError{
					field:  fmt.Sprintf("Transfers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Offset

	if len(errors) > 0 {
		return QueryTransfersResponseMultiError(errors)
	}

	return nil
}

// QueryTransfersResponseMultiError is an error wrapping multiple validation
// errors returned by QueryTransfersResponse.ValidateAll() if the designated
// constraints aren't met.
type QueryTransfersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryTransfersResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryTransfersResponseMultiError) AllErrors() []error { return m }

// QueryTransfersResponseValidationError is the validation error returned by
// QueryTransfersResponse.Validate if the designated constraints aren't met.
type QueryTransfersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryTransfersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryTransfersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryTransfersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryTransfersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryTransfersResponseValidationError) ErrorName() string {
	return "QueryTransfersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryTransfersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryTransfersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryTransfersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryTransfersResponseValidationError{}

// Validate checks the field values on ClaimLeafKeyTweak with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ClaimLeafKeyTweak) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClaimLeafKeyTweak with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClaimLeafKeyTweakMultiError, or nil if none found.
func (m *ClaimLeafKeyTweak) ValidateAll() error {
	return m.validate(true)
}

func (m *ClaimLeafKeyTweak) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	if all {
		switch v := interface{}(m.GetSecretShareTweak()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClaimLeafKeyTweakValidationError{
					field:  "SecretShareTweak",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClaimLeafKeyTweakValidationError{
					field:  "SecretShareTweak",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecretShareTweak()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClaimLeafKeyTweakValidationError{
				field:  "SecretShareTweak",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PubkeySharesTweak

	if len(errors) > 0 {
		return ClaimLeafKeyTweakMultiError(errors)
	}

	return nil
}

// ClaimLeafKeyTweakMultiError is an error wrapping multiple validation errors
// returned by ClaimLeafKeyTweak.ValidateAll() if the designated constraints
// aren't met.
type ClaimLeafKeyTweakMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClaimLeafKeyTweakMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClaimLeafKeyTweakMultiError) AllErrors() []error { return m }

// ClaimLeafKeyTweakValidationError is the validation error returned by
// ClaimLeafKeyTweak.Validate if the designated constraints aren't met.
type ClaimLeafKeyTweakValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClaimLeafKeyTweakValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClaimLeafKeyTweakValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClaimLeafKeyTweakValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClaimLeafKeyTweakValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClaimLeafKeyTweakValidationError) ErrorName() string {
	return "ClaimLeafKeyTweakValidationError"
}

// Error satisfies the builtin error interface
func (e ClaimLeafKeyTweakValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClaimLeafKeyTweak.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClaimLeafKeyTweakValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClaimLeafKeyTweakValidationError{}

// Validate checks the field values on ClaimTransferTweakKeysRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClaimTransferTweakKeysRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClaimTransferTweakKeysRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ClaimTransferTweakKeysRequestMultiError, or nil if none found.
func (m *ClaimTransferTweakKeysRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ClaimTransferTweakKeysRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for OwnerIdentityPublicKey

	for idx, item := range m.GetLeavesToReceive() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClaimTransferTweakKeysRequestValidationError{
						field:  fmt.Sprintf("LeavesToReceive[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClaimTransferTweakKeysRequestValidationError{
						field:  fmt.Sprintf("LeavesToReceive[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClaimTransferTweakKeysRequestValidationError{
					field:  fmt.Sprintf("LeavesToReceive[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ClaimTransferTweakKeysRequestMultiError(errors)
	}

	return nil
}

// ClaimTransferTweakKeysRequestMultiError is an error wrapping multiple
// validation errors returned by ClaimTransferTweakKeysRequest.ValidateAll()
// if the designated constraints aren't met.
type ClaimTransferTweakKeysRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClaimTransferTweakKeysRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClaimTransferTweakKeysRequestMultiError) AllErrors() []error { return m }

// ClaimTransferTweakKeysRequestValidationError is the validation error
// returned by ClaimTransferTweakKeysRequest.Validate if the designated
// constraints aren't met.
type ClaimTransferTweakKeysRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClaimTransferTweakKeysRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClaimTransferTweakKeysRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClaimTransferTweakKeysRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClaimTransferTweakKeysRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClaimTransferTweakKeysRequestValidationError) ErrorName() string {
	return "ClaimTransferTweakKeysRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ClaimTransferTweakKeysRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClaimTransferTweakKeysRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClaimTransferTweakKeysRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClaimTransferTweakKeysRequestValidationError{}

// Validate checks the field values on ClaimTransferSignRefundsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClaimTransferSignRefundsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClaimTransferSignRefundsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ClaimTransferSignRefundsRequestMultiError, or nil if none found.
func (m *ClaimTransferSignRefundsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ClaimTransferSignRefundsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for OwnerIdentityPublicKey

	for idx, item := range m.GetSigningJobs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClaimTransferSignRefundsRequestValidationError{
						field:  fmt.Sprintf("SigningJobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClaimTransferSignRefundsRequestValidationError{
						field:  fmt.Sprintf("SigningJobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClaimTransferSignRefundsRequestValidationError{
					field:  fmt.Sprintf("SigningJobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ClaimTransferSignRefundsRequestMultiError(errors)
	}

	return nil
}

// ClaimTransferSignRefundsRequestMultiError is an error wrapping multiple
// validation errors returned by ClaimTransferSignRefundsRequest.ValidateAll()
// if the designated constraints aren't met.
type ClaimTransferSignRefundsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClaimTransferSignRefundsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClaimTransferSignRefundsRequestMultiError) AllErrors() []error { return m }

// ClaimTransferSignRefundsRequestValidationError is the validation error
// returned by ClaimTransferSignRefundsRequest.Validate if the designated
// constraints aren't met.
type ClaimTransferSignRefundsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClaimTransferSignRefundsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClaimTransferSignRefundsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClaimTransferSignRefundsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClaimTransferSignRefundsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClaimTransferSignRefundsRequestValidationError) ErrorName() string {
	return "ClaimTransferSignRefundsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ClaimTransferSignRefundsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClaimTransferSignRefundsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClaimTransferSignRefundsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClaimTransferSignRefundsRequestValidationError{}

// Validate checks the field values on ClaimTransferSignRefundsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ClaimTransferSignRefundsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClaimTransferSignRefundsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ClaimTransferSignRefundsResponseMultiError, or nil if none found.
func (m *ClaimTransferSignRefundsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ClaimTransferSignRefundsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSigningResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClaimTransferSignRefundsResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClaimTransferSignRefundsResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClaimTransferSignRefundsResponseValidationError{
					field:  fmt.Sprintf("SigningResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ClaimTransferSignRefundsResponseMultiError(errors)
	}

	return nil
}

// ClaimTransferSignRefundsResponseMultiError is an error wrapping multiple
// validation errors returned by
// ClaimTransferSignRefundsResponse.ValidateAll() if the designated
// constraints aren't met.
type ClaimTransferSignRefundsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClaimTransferSignRefundsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClaimTransferSignRefundsResponseMultiError) AllErrors() []error { return m }

// ClaimTransferSignRefundsResponseValidationError is the validation error
// returned by ClaimTransferSignRefundsResponse.Validate if the designated
// constraints aren't met.
type ClaimTransferSignRefundsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClaimTransferSignRefundsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClaimTransferSignRefundsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClaimTransferSignRefundsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClaimTransferSignRefundsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClaimTransferSignRefundsResponseValidationError) ErrorName() string {
	return "ClaimTransferSignRefundsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ClaimTransferSignRefundsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClaimTransferSignRefundsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClaimTransferSignRefundsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClaimTransferSignRefundsResponseValidationError{}

// Validate checks the field values on StorePreimageShareRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StorePreimageShareRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StorePreimageShareRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StorePreimageShareRequestMultiError, or nil if none found.
func (m *StorePreimageShareRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StorePreimageShareRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentHash

	if all {
		switch v := interface{}(m.GetPreimageShare()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StorePreimageShareRequestValidationError{
					field:  "PreimageShare",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StorePreimageShareRequestValidationError{
					field:  "PreimageShare",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPreimageShare()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StorePreimageShareRequestValidationError{
				field:  "PreimageShare",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Threshold

	// no validation rules for InvoiceString

	// no validation rules for UserIdentityPublicKey

	if len(errors) > 0 {
		return StorePreimageShareRequestMultiError(errors)
	}

	return nil
}

// StorePreimageShareRequestMultiError is an error wrapping multiple validation
// errors returned by StorePreimageShareRequest.ValidateAll() if the
// designated constraints aren't met.
type StorePreimageShareRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StorePreimageShareRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StorePreimageShareRequestMultiError) AllErrors() []error { return m }

// StorePreimageShareRequestValidationError is the validation error returned by
// StorePreimageShareRequest.Validate if the designated constraints aren't met.
type StorePreimageShareRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StorePreimageShareRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StorePreimageShareRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StorePreimageShareRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StorePreimageShareRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StorePreimageShareRequestValidationError) ErrorName() string {
	return "StorePreimageShareRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StorePreimageShareRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStorePreimageShareRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StorePreimageShareRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StorePreimageShareRequestValidationError{}

// Validate checks the field values on RequestedSigningCommitments with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RequestedSigningCommitments) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestedSigningCommitments with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RequestedSigningCommitmentsMultiError, or nil if none found.
func (m *RequestedSigningCommitments) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestedSigningCommitments) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetSigningNonceCommitments()))
		i := 0
		for key := range m.GetSigningNonceCommitments() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSigningNonceCommitments()[key]
			_ = val

			// no validation rules for SigningNonceCommitments[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, RequestedSigningCommitmentsValidationError{
							field:  fmt.Sprintf("SigningNonceCommitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, RequestedSigningCommitmentsValidationError{
							field:  fmt.Sprintf("SigningNonceCommitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return RequestedSigningCommitmentsValidationError{
						field:  fmt.Sprintf("SigningNonceCommitments[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return RequestedSigningCommitmentsMultiError(errors)
	}

	return nil
}

// RequestedSigningCommitmentsMultiError is an error wrapping multiple
// validation errors returned by RequestedSigningCommitments.ValidateAll() if
// the designated constraints aren't met.
type RequestedSigningCommitmentsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestedSigningCommitmentsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestedSigningCommitmentsMultiError) AllErrors() []error { return m }

// RequestedSigningCommitmentsValidationError is the validation error returned
// by RequestedSigningCommitments.Validate if the designated constraints
// aren't met.
type RequestedSigningCommitmentsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestedSigningCommitmentsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestedSigningCommitmentsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestedSigningCommitmentsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestedSigningCommitmentsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestedSigningCommitmentsValidationError) ErrorName() string {
	return "RequestedSigningCommitmentsValidationError"
}

// Error satisfies the builtin error interface
func (e RequestedSigningCommitmentsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestedSigningCommitments.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestedSigningCommitmentsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestedSigningCommitmentsValidationError{}

// Validate checks the field values on GetSigningCommitmentsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSigningCommitmentsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSigningCommitmentsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSigningCommitmentsRequestMultiError, or nil if none found.
func (m *GetSigningCommitmentsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSigningCommitmentsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	if len(errors) > 0 {
		return GetSigningCommitmentsRequestMultiError(errors)
	}

	return nil
}

// GetSigningCommitmentsRequestMultiError is an error wrapping multiple
// validation errors returned by GetSigningCommitmentsRequest.ValidateAll() if
// the designated constraints aren't met.
type GetSigningCommitmentsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSigningCommitmentsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSigningCommitmentsRequestMultiError) AllErrors() []error { return m }

// GetSigningCommitmentsRequestValidationError is the validation error returned
// by GetSigningCommitmentsRequest.Validate if the designated constraints
// aren't met.
type GetSigningCommitmentsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSigningCommitmentsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSigningCommitmentsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSigningCommitmentsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSigningCommitmentsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSigningCommitmentsRequestValidationError) ErrorName() string {
	return "GetSigningCommitmentsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSigningCommitmentsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSigningCommitmentsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSigningCommitmentsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSigningCommitmentsRequestValidationError{}

// Validate checks the field values on GetSigningCommitmentsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSigningCommitmentsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSigningCommitmentsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetSigningCommitmentsResponseMultiError, or nil if none found.
func (m *GetSigningCommitmentsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSigningCommitmentsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSigningCommitments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSigningCommitmentsResponseValidationError{
						field:  fmt.Sprintf("SigningCommitments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSigningCommitmentsResponseValidationError{
						field:  fmt.Sprintf("SigningCommitments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSigningCommitmentsResponseValidationError{
					field:  fmt.Sprintf("SigningCommitments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetSigningCommitmentsResponseMultiError(errors)
	}

	return nil
}

// GetSigningCommitmentsResponseMultiError is an error wrapping multiple
// validation errors returned by GetSigningCommitmentsResponse.ValidateAll()
// if the designated constraints aren't met.
type GetSigningCommitmentsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSigningCommitmentsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSigningCommitmentsResponseMultiError) AllErrors() []error { return m }

// GetSigningCommitmentsResponseValidationError is the validation error
// returned by GetSigningCommitmentsResponse.Validate if the designated
// constraints aren't met.
type GetSigningCommitmentsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSigningCommitmentsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSigningCommitmentsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSigningCommitmentsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSigningCommitmentsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSigningCommitmentsResponseValidationError) ErrorName() string {
	return "GetSigningCommitmentsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSigningCommitmentsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSigningCommitmentsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSigningCommitmentsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSigningCommitmentsResponseValidationError{}

// Validate checks the field values on SigningCommitments with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SigningCommitments) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SigningCommitments with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SigningCommitmentsMultiError, or nil if none found.
func (m *SigningCommitments) ValidateAll() error {
	return m.validate(true)
}

func (m *SigningCommitments) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetSigningCommitments()))
		i := 0
		for key := range m.GetSigningCommitments() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSigningCommitments()[key]
			_ = val

			// no validation rules for SigningCommitments[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SigningCommitmentsValidationError{
							field:  fmt.Sprintf("SigningCommitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SigningCommitmentsValidationError{
							field:  fmt.Sprintf("SigningCommitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SigningCommitmentsValidationError{
						field:  fmt.Sprintf("SigningCommitments[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return SigningCommitmentsMultiError(errors)
	}

	return nil
}

// SigningCommitmentsMultiError is an error wrapping multiple validation errors
// returned by SigningCommitments.ValidateAll() if the designated constraints
// aren't met.
type SigningCommitmentsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SigningCommitmentsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SigningCommitmentsMultiError) AllErrors() []error { return m }

// SigningCommitmentsValidationError is the validation error returned by
// SigningCommitments.Validate if the designated constraints aren't met.
type SigningCommitmentsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SigningCommitmentsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SigningCommitmentsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SigningCommitmentsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SigningCommitmentsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SigningCommitmentsValidationError) ErrorName() string {
	return "SigningCommitmentsValidationError"
}

// Error satisfies the builtin error interface
func (e SigningCommitmentsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSigningCommitments.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SigningCommitmentsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SigningCommitmentsValidationError{}

// Validate checks the field values on UserSignedRefund with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserSignedRefund) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserSignedRefund with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserSignedRefundMultiError, or nil if none found.
func (m *UserSignedRefund) ValidateAll() error {
	return m.validate(true)
}

func (m *UserSignedRefund) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeId

	// no validation rules for RefundTx

	// no validation rules for UserSignature

	if all {
		switch v := interface{}(m.GetSigningCommitments()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserSignedRefundValidationError{
					field:  "SigningCommitments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserSignedRefundValidationError{
					field:  "SigningCommitments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningCommitments()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserSignedRefundValidationError{
				field:  "SigningCommitments",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUserSignatureCommitment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserSignedRefundValidationError{
					field:  "UserSignatureCommitment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserSignedRefundValidationError{
					field:  "UserSignatureCommitment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserSignatureCommitment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserSignedRefundValidationError{
				field:  "UserSignatureCommitment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := _UserSignedRefund_Network_NotInLookup[m.GetNetwork()]; ok {
		err := UserSignedRefundValidationError{
			field:  "Network",
			reason: "value must not be in list [UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserSignedRefundMultiError(errors)
	}

	return nil
}

// UserSignedRefundMultiError is an error wrapping multiple validation errors
// returned by UserSignedRefund.ValidateAll() if the designated constraints
// aren't met.
type UserSignedRefundMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserSignedRefundMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserSignedRefundMultiError) AllErrors() []error { return m }

// UserSignedRefundValidationError is the validation error returned by
// UserSignedRefund.Validate if the designated constraints aren't met.
type UserSignedRefundValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserSignedRefundValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserSignedRefundValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserSignedRefundValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserSignedRefundValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserSignedRefundValidationError) ErrorName() string { return "UserSignedRefundValidationError" }

// Error satisfies the builtin error interface
func (e UserSignedRefundValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserSignedRefund.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserSignedRefundValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserSignedRefundValidationError{}

var _UserSignedRefund_Network_NotInLookup = map[Network]struct{}{
	0: {},
}

// Validate checks the field values on InvoiceAmountProof with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InvoiceAmountProof) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceAmountProof with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvoiceAmountProofMultiError, or nil if none found.
func (m *InvoiceAmountProof) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceAmountProof) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bolt11Invoice

	if len(errors) > 0 {
		return InvoiceAmountProofMultiError(errors)
	}

	return nil
}

// InvoiceAmountProofMultiError is an error wrapping multiple validation errors
// returned by InvoiceAmountProof.ValidateAll() if the designated constraints
// aren't met.
type InvoiceAmountProofMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceAmountProofMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceAmountProofMultiError) AllErrors() []error { return m }

// InvoiceAmountProofValidationError is the validation error returned by
// InvoiceAmountProof.Validate if the designated constraints aren't met.
type InvoiceAmountProofValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceAmountProofValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceAmountProofValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceAmountProofValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceAmountProofValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceAmountProofValidationError) ErrorName() string {
	return "InvoiceAmountProofValidationError"
}

// Error satisfies the builtin error interface
func (e InvoiceAmountProofValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceAmountProof.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceAmountProofValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceAmountProofValidationError{}

// Validate checks the field values on InvoiceAmount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceAmount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceAmount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceAmountMultiError, or
// nil if none found.
func (m *InvoiceAmount) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceAmount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ValueSats

	if all {
		switch v := interface{}(m.GetInvoiceAmountProof()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceAmountValidationError{
					field:  "InvoiceAmountProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceAmountValidationError{
					field:  "InvoiceAmountProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceAmountProof()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceAmountValidationError{
				field:  "InvoiceAmountProof",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvoiceAmountMultiError(errors)
	}

	return nil
}

// InvoiceAmountMultiError is an error wrapping multiple validation errors
// returned by InvoiceAmount.ValidateAll() if the designated constraints
// aren't met.
type InvoiceAmountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceAmountMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceAmountMultiError) AllErrors() []error { return m }

// InvoiceAmountValidationError is the validation error returned by
// InvoiceAmount.Validate if the designated constraints aren't met.
type InvoiceAmountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceAmountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceAmountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceAmountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceAmountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceAmountValidationError) ErrorName() string { return "InvoiceAmountValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceAmountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceAmount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceAmountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceAmountValidationError{}

// Validate checks the field values on InitiatePreimageSwapRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiatePreimageSwapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiatePreimageSwapRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiatePreimageSwapRequestMultiError, or nil if none found.
func (m *InitiatePreimageSwapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiatePreimageSwapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentHash

	if all {
		switch v := interface{}(m.GetInvoiceAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiatePreimageSwapRequestValidationError{
					field:  "InvoiceAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiatePreimageSwapRequestValidationError{
					field:  "InvoiceAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiatePreimageSwapRequestValidationError{
				field:  "InvoiceAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reason

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiatePreimageSwapRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiatePreimageSwapRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiatePreimageSwapRequestValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ReceiverIdentityPublicKey

	// no validation rules for FeeSats

	if len(errors) > 0 {
		return InitiatePreimageSwapRequestMultiError(errors)
	}

	return nil
}

// InitiatePreimageSwapRequestMultiError is an error wrapping multiple
// validation errors returned by InitiatePreimageSwapRequest.ValidateAll() if
// the designated constraints aren't met.
type InitiatePreimageSwapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiatePreimageSwapRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiatePreimageSwapRequestMultiError) AllErrors() []error { return m }

// InitiatePreimageSwapRequestValidationError is the validation error returned
// by InitiatePreimageSwapRequest.Validate if the designated constraints
// aren't met.
type InitiatePreimageSwapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiatePreimageSwapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiatePreimageSwapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiatePreimageSwapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiatePreimageSwapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiatePreimageSwapRequestValidationError) ErrorName() string {
	return "InitiatePreimageSwapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitiatePreimageSwapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiatePreimageSwapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiatePreimageSwapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiatePreimageSwapRequestValidationError{}

// Validate checks the field values on InitiatePreimageSwapResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiatePreimageSwapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiatePreimageSwapResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiatePreimageSwapResponseMultiError, or nil if none found.
func (m *InitiatePreimageSwapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiatePreimageSwapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Preimage

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiatePreimageSwapResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiatePreimageSwapResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiatePreimageSwapResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InitiatePreimageSwapResponseMultiError(errors)
	}

	return nil
}

// InitiatePreimageSwapResponseMultiError is an error wrapping multiple
// validation errors returned by InitiatePreimageSwapResponse.ValidateAll() if
// the designated constraints aren't met.
type InitiatePreimageSwapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiatePreimageSwapResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiatePreimageSwapResponseMultiError) AllErrors() []error { return m }

// InitiatePreimageSwapResponseValidationError is the validation error returned
// by InitiatePreimageSwapResponse.Validate if the designated constraints
// aren't met.
type InitiatePreimageSwapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiatePreimageSwapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiatePreimageSwapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiatePreimageSwapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiatePreimageSwapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiatePreimageSwapResponseValidationError) ErrorName() string {
	return "InitiatePreimageSwapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InitiatePreimageSwapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiatePreimageSwapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiatePreimageSwapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiatePreimageSwapResponseValidationError{}

// Validate checks the field values on OutPoint with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OutPoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OutPoint with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OutPointMultiError, or nil
// if none found.
func (m *OutPoint) ValidateAll() error {
	return m.validate(true)
}

func (m *OutPoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Txid

	// no validation rules for Vout

	if len(errors) > 0 {
		return OutPointMultiError(errors)
	}

	return nil
}

// OutPointMultiError is an error wrapping multiple validation errors returned
// by OutPoint.ValidateAll() if the designated constraints aren't met.
type OutPointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OutPointMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OutPointMultiError) AllErrors() []error { return m }

// OutPointValidationError is the validation error returned by
// OutPoint.Validate if the designated constraints aren't met.
type OutPointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OutPointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OutPointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OutPointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OutPointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OutPointValidationError) ErrorName() string { return "OutPointValidationError" }

// Error satisfies the builtin error interface
func (e OutPointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOutPoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OutPointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OutPointValidationError{}

// Validate checks the field values on CooperativeExitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CooperativeExitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CooperativeExitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CooperativeExitRequestMultiError, or nil if none found.
func (m *CooperativeExitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CooperativeExitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CooperativeExitRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CooperativeExitRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CooperativeExitRequestValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ExitId

	// no validation rules for ExitTxid

	if len(errors) > 0 {
		return CooperativeExitRequestMultiError(errors)
	}

	return nil
}

// CooperativeExitRequestMultiError is an error wrapping multiple validation
// errors returned by CooperativeExitRequest.ValidateAll() if the designated
// constraints aren't met.
type CooperativeExitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CooperativeExitRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CooperativeExitRequestMultiError) AllErrors() []error { return m }

// CooperativeExitRequestValidationError is the validation error returned by
// CooperativeExitRequest.Validate if the designated constraints aren't met.
type CooperativeExitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CooperativeExitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CooperativeExitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CooperativeExitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CooperativeExitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CooperativeExitRequestValidationError) ErrorName() string {
	return "CooperativeExitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CooperativeExitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCooperativeExitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CooperativeExitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CooperativeExitRequestValidationError{}

// Validate checks the field values on CooperativeExitResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CooperativeExitResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CooperativeExitResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CooperativeExitResponseMultiError, or nil if none found.
func (m *CooperativeExitResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CooperativeExitResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CooperativeExitResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CooperativeExitResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CooperativeExitResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSigningResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CooperativeExitResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CooperativeExitResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CooperativeExitResponseValidationError{
					field:  fmt.Sprintf("SigningResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CooperativeExitResponseMultiError(errors)
	}

	return nil
}

// CooperativeExitResponseMultiError is an error wrapping multiple validation
// errors returned by CooperativeExitResponse.ValidateAll() if the designated
// constraints aren't met.
type CooperativeExitResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CooperativeExitResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CooperativeExitResponseMultiError) AllErrors() []error { return m }

// CooperativeExitResponseValidationError is the validation error returned by
// CooperativeExitResponse.Validate if the designated constraints aren't met.
type CooperativeExitResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CooperativeExitResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CooperativeExitResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CooperativeExitResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CooperativeExitResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CooperativeExitResponseValidationError) ErrorName() string {
	return "CooperativeExitResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CooperativeExitResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCooperativeExitResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CooperativeExitResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CooperativeExitResponseValidationError{}

// Validate checks the field values on CounterLeafSwapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CounterLeafSwapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CounterLeafSwapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CounterLeafSwapRequestMultiError, or nil if none found.
func (m *CounterLeafSwapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CounterLeafSwapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CounterLeafSwapRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CounterLeafSwapRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CounterLeafSwapRequestValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SwapId

	// no validation rules for AdaptorPublicKey

	// no validation rules for DirectAdaptorPublicKey

	// no validation rules for DirectFromCpfpAdaptorPublicKey

	if len(errors) > 0 {
		return CounterLeafSwapRequestMultiError(errors)
	}

	return nil
}

// CounterLeafSwapRequestMultiError is an error wrapping multiple validation
// errors returned by CounterLeafSwapRequest.ValidateAll() if the designated
// constraints aren't met.
type CounterLeafSwapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CounterLeafSwapRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CounterLeafSwapRequestMultiError) AllErrors() []error { return m }

// CounterLeafSwapRequestValidationError is the validation error returned by
// CounterLeafSwapRequest.Validate if the designated constraints aren't met.
type CounterLeafSwapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CounterLeafSwapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CounterLeafSwapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CounterLeafSwapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CounterLeafSwapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CounterLeafSwapRequestValidationError) ErrorName() string {
	return "CounterLeafSwapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CounterLeafSwapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCounterLeafSwapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CounterLeafSwapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CounterLeafSwapRequestValidationError{}

// Validate checks the field values on CounterLeafSwapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CounterLeafSwapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CounterLeafSwapResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CounterLeafSwapResponseMultiError, or nil if none found.
func (m *CounterLeafSwapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CounterLeafSwapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CounterLeafSwapResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CounterLeafSwapResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CounterLeafSwapResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSigningResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CounterLeafSwapResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CounterLeafSwapResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CounterLeafSwapResponseValidationError{
					field:  fmt.Sprintf("SigningResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CounterLeafSwapResponseMultiError(errors)
	}

	return nil
}

// CounterLeafSwapResponseMultiError is an error wrapping multiple validation
// errors returned by CounterLeafSwapResponse.ValidateAll() if the designated
// constraints aren't met.
type CounterLeafSwapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CounterLeafSwapResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CounterLeafSwapResponseMultiError) AllErrors() []error { return m }

// CounterLeafSwapResponseValidationError is the validation error returned by
// CounterLeafSwapResponse.Validate if the designated constraints aren't met.
type CounterLeafSwapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CounterLeafSwapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CounterLeafSwapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CounterLeafSwapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CounterLeafSwapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CounterLeafSwapResponseValidationError) ErrorName() string {
	return "CounterLeafSwapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CounterLeafSwapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCounterLeafSwapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CounterLeafSwapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CounterLeafSwapResponseValidationError{}

// Validate checks the field values on RefreshTimelockRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTimelockRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTimelockRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTimelockRequestMultiError, or nil if none found.
func (m *RefreshTimelockRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTimelockRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	// no validation rules for OwnerIdentityPublicKey

	for idx, item := range m.GetSigningJobs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RefreshTimelockRequestValidationError{
						field:  fmt.Sprintf("SigningJobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RefreshTimelockRequestValidationError{
						field:  fmt.Sprintf("SigningJobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RefreshTimelockRequestValidationError{
					field:  fmt.Sprintf("SigningJobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RefreshTimelockRequestMultiError(errors)
	}

	return nil
}

// RefreshTimelockRequestMultiError is an error wrapping multiple validation
// errors returned by RefreshTimelockRequest.ValidateAll() if the designated
// constraints aren't met.
type RefreshTimelockRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTimelockRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTimelockRequestMultiError) AllErrors() []error { return m }

// RefreshTimelockRequestValidationError is the validation error returned by
// RefreshTimelockRequest.Validate if the designated constraints aren't met.
type RefreshTimelockRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTimelockRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTimelockRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTimelockRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTimelockRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTimelockRequestValidationError) ErrorName() string {
	return "RefreshTimelockRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTimelockRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTimelockRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTimelockRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTimelockRequestValidationError{}

// Validate checks the field values on RefreshTimelockSigningResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTimelockSigningResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTimelockSigningResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTimelockSigningResultMultiError, or nil if none found.
func (m *RefreshTimelockSigningResult) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTimelockSigningResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RefreshTimelockSigningResultValidationError{
					field:  "SigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RefreshTimelockSigningResultValidationError{
					field:  "SigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RefreshTimelockSigningResultValidationError{
				field:  "SigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VerifyingKey

	if len(errors) > 0 {
		return RefreshTimelockSigningResultMultiError(errors)
	}

	return nil
}

// RefreshTimelockSigningResultMultiError is an error wrapping multiple
// validation errors returned by RefreshTimelockSigningResult.ValidateAll() if
// the designated constraints aren't met.
type RefreshTimelockSigningResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTimelockSigningResultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTimelockSigningResultMultiError) AllErrors() []error { return m }

// RefreshTimelockSigningResultValidationError is the validation error returned
// by RefreshTimelockSigningResult.Validate if the designated constraints
// aren't met.
type RefreshTimelockSigningResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTimelockSigningResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTimelockSigningResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTimelockSigningResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTimelockSigningResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTimelockSigningResultValidationError) ErrorName() string {
	return "RefreshTimelockSigningResultValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTimelockSigningResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTimelockSigningResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTimelockSigningResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTimelockSigningResultValidationError{}

// Validate checks the field values on RefreshTimelockResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTimelockResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTimelockResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTimelockResponseMultiError, or nil if none found.
func (m *RefreshTimelockResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTimelockResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSigningResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RefreshTimelockResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RefreshTimelockResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RefreshTimelockResponseValidationError{
					field:  fmt.Sprintf("SigningResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RefreshTimelockResponseMultiError(errors)
	}

	return nil
}

// RefreshTimelockResponseMultiError is an error wrapping multiple validation
// errors returned by RefreshTimelockResponse.ValidateAll() if the designated
// constraints aren't met.
type RefreshTimelockResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTimelockResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTimelockResponseMultiError) AllErrors() []error { return m }

// RefreshTimelockResponseValidationError is the validation error returned by
// RefreshTimelockResponse.Validate if the designated constraints aren't met.
type RefreshTimelockResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTimelockResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTimelockResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTimelockResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTimelockResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTimelockResponseValidationError) ErrorName() string {
	return "RefreshTimelockResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTimelockResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTimelockResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTimelockResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTimelockResponseValidationError{}

// Validate checks the field values on ExtendLeafRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExtendLeafRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExtendLeafRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExtendLeafRequestMultiError, or nil if none found.
func (m *ExtendLeafRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExtendLeafRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	// no validation rules for OwnerIdentityPublicKey

	if all {
		switch v := interface{}(m.GetNodeTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafRequestValidationError{
					field:  "NodeTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafRequestValidationError{
					field:  "NodeTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafRequestValidationError{
				field:  "NodeTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafRequestValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafRequestValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafRequestValidationError{
				field:  "RefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectNodeTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafRequestValidationError{
					field:  "DirectNodeTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafRequestValidationError{
					field:  "DirectNodeTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectNodeTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafRequestValidationError{
				field:  "DirectNodeTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafRequestValidationError{
					field:  "DirectRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafRequestValidationError{
					field:  "DirectRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafRequestValidationError{
				field:  "DirectRefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectFromCpfpRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafRequestValidationError{
					field:  "DirectFromCpfpRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafRequestValidationError{
					field:  "DirectFromCpfpRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectFromCpfpRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafRequestValidationError{
				field:  "DirectFromCpfpRefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExtendLeafRequestMultiError(errors)
	}

	return nil
}

// ExtendLeafRequestMultiError is an error wrapping multiple validation errors
// returned by ExtendLeafRequest.ValidateAll() if the designated constraints
// aren't met.
type ExtendLeafRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtendLeafRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtendLeafRequestMultiError) AllErrors() []error { return m }

// ExtendLeafRequestValidationError is the validation error returned by
// ExtendLeafRequest.Validate if the designated constraints aren't met.
type ExtendLeafRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtendLeafRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtendLeafRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtendLeafRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtendLeafRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtendLeafRequestValidationError) ErrorName() string {
	return "ExtendLeafRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExtendLeafRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtendLeafRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtendLeafRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtendLeafRequestValidationError{}

// Validate checks the field values on ExtendLeafSigningResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExtendLeafSigningResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExtendLeafSigningResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExtendLeafSigningResultMultiError, or nil if none found.
func (m *ExtendLeafSigningResult) ValidateAll() error {
	return m.validate(true)
}

func (m *ExtendLeafSigningResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafSigningResultValidationError{
					field:  "SigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafSigningResultValidationError{
					field:  "SigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafSigningResultValidationError{
				field:  "SigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VerifyingKey

	if len(errors) > 0 {
		return ExtendLeafSigningResultMultiError(errors)
	}

	return nil
}

// ExtendLeafSigningResultMultiError is an error wrapping multiple validation
// errors returned by ExtendLeafSigningResult.ValidateAll() if the designated
// constraints aren't met.
type ExtendLeafSigningResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtendLeafSigningResultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtendLeafSigningResultMultiError) AllErrors() []error { return m }

// ExtendLeafSigningResultValidationError is the validation error returned by
// ExtendLeafSigningResult.Validate if the designated constraints aren't met.
type ExtendLeafSigningResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtendLeafSigningResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtendLeafSigningResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtendLeafSigningResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtendLeafSigningResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtendLeafSigningResultValidationError) ErrorName() string {
	return "ExtendLeafSigningResultValidationError"
}

// Error satisfies the builtin error interface
func (e ExtendLeafSigningResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtendLeafSigningResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtendLeafSigningResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtendLeafSigningResultValidationError{}

// Validate checks the field values on ExtendLeafResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExtendLeafResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExtendLeafResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExtendLeafResponseMultiError, or nil if none found.
func (m *ExtendLeafResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExtendLeafResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	if all {
		switch v := interface{}(m.GetNodeTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafResponseValidationError{
					field:  "NodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafResponseValidationError{
					field:  "NodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafResponseValidationError{
				field:  "NodeTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafResponseValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafResponseValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafResponseValidationError{
				field:  "RefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectNodeTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafResponseValidationError{
					field:  "DirectNodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafResponseValidationError{
					field:  "DirectNodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectNodeTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafResponseValidationError{
				field:  "DirectNodeTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafResponseValidationError{
					field:  "DirectRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafResponseValidationError{
					field:  "DirectRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafResponseValidationError{
				field:  "DirectRefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectFromCpfpRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafResponseValidationError{
					field:  "DirectFromCpfpRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafResponseValidationError{
					field:  "DirectFromCpfpRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectFromCpfpRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafResponseValidationError{
				field:  "DirectFromCpfpRefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExtendLeafResponseMultiError(errors)
	}

	return nil
}

// ExtendLeafResponseMultiError is an error wrapping multiple validation errors
// returned by ExtendLeafResponse.ValidateAll() if the designated constraints
// aren't met.
type ExtendLeafResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtendLeafResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtendLeafResponseMultiError) AllErrors() []error { return m }

// ExtendLeafResponseValidationError is the validation error returned by
// ExtendLeafResponse.Validate if the designated constraints aren't met.
type ExtendLeafResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtendLeafResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtendLeafResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtendLeafResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtendLeafResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtendLeafResponseValidationError) ErrorName() string {
	return "ExtendLeafResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExtendLeafResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtendLeafResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtendLeafResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtendLeafResponseValidationError{}

// Validate checks the field values on AddressRequestNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddressRequestNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddressRequestNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddressRequestNodeMultiError, or nil if none found.
func (m *AddressRequestNode) ValidateAll() error {
	return m.validate(true)
}

func (m *AddressRequestNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserPublicKey

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddressRequestNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddressRequestNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddressRequestNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AddressRequestNodeMultiError(errors)
	}

	return nil
}

// AddressRequestNodeMultiError is an error wrapping multiple validation errors
// returned by AddressRequestNode.ValidateAll() if the designated constraints
// aren't met.
type AddressRequestNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressRequestNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressRequestNodeMultiError) AllErrors() []error { return m }

// AddressRequestNodeValidationError is the validation error returned by
// AddressRequestNode.Validate if the designated constraints aren't met.
type AddressRequestNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressRequestNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressRequestNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressRequestNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressRequestNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressRequestNodeValidationError) ErrorName() string {
	return "AddressRequestNodeValidationError"
}

// Error satisfies the builtin error interface
func (e AddressRequestNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddressRequestNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressRequestNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressRequestNodeValidationError{}

// Validate checks the field values on PrepareTreeAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PrepareTreeAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrepareTreeAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrepareTreeAddressRequestMultiError, or nil if none found.
func (m *PrepareTreeAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PrepareTreeAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PrepareTreeAddressRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PrepareTreeAddressRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PrepareTreeAddressRequestValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserIdentityPublicKey

	switch v := m.Source.(type) {
	case *PrepareTreeAddressRequest_ParentNodeOutput:
		if v == nil {
			err := PrepareTreeAddressRequestValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetParentNodeOutput()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PrepareTreeAddressRequestValidationError{
						field:  "ParentNodeOutput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PrepareTreeAddressRequestValidationError{
						field:  "ParentNodeOutput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetParentNodeOutput()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PrepareTreeAddressRequestValidationError{
					field:  "ParentNodeOutput",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PrepareTreeAddressRequest_OnChainUtxo:
		if v == nil {
			err := PrepareTreeAddressRequestValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOnChainUtxo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PrepareTreeAddressRequestValidationError{
						field:  "OnChainUtxo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PrepareTreeAddressRequestValidationError{
						field:  "OnChainUtxo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOnChainUtxo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PrepareTreeAddressRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return PrepareTreeAddressRequestMultiError(errors)
	}

	return nil
}

// PrepareTreeAddressRequestMultiError is an error wrapping multiple validation
// errors returned by PrepareTreeAddressRequest.ValidateAll() if the
// designated constraints aren't met.
type PrepareTreeAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrepareTreeAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrepareTreeAddressRequestMultiError) AllErrors() []error { return m }

// PrepareTreeAddressRequestValidationError is the validation error returned by
// PrepareTreeAddressRequest.Validate if the designated constraints aren't met.
type PrepareTreeAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrepareTreeAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrepareTreeAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrepareTreeAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrepareTreeAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrepareTreeAddressRequestValidationError) ErrorName() string {
	return "PrepareTreeAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PrepareTreeAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrepareTreeAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrepareTreeAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrepareTreeAddressRequestValidationError{}

// Validate checks the field values on AddressNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddressNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddressNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AddressNodeMultiError, or
// nil if none found.
func (m *AddressNode) ValidateAll() error {
	return m.validate(true)
}

func (m *AddressNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddressNodeValidationError{
					field:  "Address",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddressNodeValidationError{
					field:  "Address",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddressNodeValidationError{
				field:  "Address",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddressNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddressNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddressNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AddressNodeMultiError(errors)
	}

	return nil
}

// AddressNodeMultiError is an error wrapping multiple validation errors
// returned by AddressNode.ValidateAll() if the designated constraints aren't met.
type AddressNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressNodeMultiError) AllErrors() []error { return m }

// AddressNodeValidationError is the validation error returned by
// AddressNode.Validate if the designated constraints aren't met.
type AddressNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressNodeValidationError) ErrorName() string { return "AddressNodeValidationError" }

// Error satisfies the builtin error interface
func (e AddressNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddressNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressNodeValidationError{}

// Validate checks the field values on PrepareTreeAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PrepareTreeAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrepareTreeAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrepareTreeAddressResponseMultiError, or nil if none found.
func (m *PrepareTreeAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PrepareTreeAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PrepareTreeAddressResponseValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PrepareTreeAddressResponseValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PrepareTreeAddressResponseValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PrepareTreeAddressResponseMultiError(errors)
	}

	return nil
}

// PrepareTreeAddressResponseMultiError is an error wrapping multiple
// validation errors returned by PrepareTreeAddressResponse.ValidateAll() if
// the designated constraints aren't met.
type PrepareTreeAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrepareTreeAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrepareTreeAddressResponseMultiError) AllErrors() []error { return m }

// PrepareTreeAddressResponseValidationError is the validation error returned
// by PrepareTreeAddressResponse.Validate if the designated constraints aren't met.
type PrepareTreeAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrepareTreeAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrepareTreeAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrepareTreeAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrepareTreeAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrepareTreeAddressResponseValidationError) ErrorName() string {
	return "PrepareTreeAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PrepareTreeAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrepareTreeAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrepareTreeAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrepareTreeAddressResponseValidationError{}

// Validate checks the field values on CreationNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreationNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreationNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreationNodeMultiError, or
// nil if none found.
func (m *CreationNode) ValidateAll() error {
	return m.validate(true)
}

func (m *CreationNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNodeTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreationNodeValidationError{
					field:  "NodeTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreationNodeValidationError{
					field:  "NodeTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreationNodeValidationError{
				field:  "NodeTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreationNodeValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreationNodeValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreationNodeValidationError{
				field:  "RefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreationNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreationNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreationNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetDirectNodeTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreationNodeValidationError{
					field:  "DirectNodeTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreationNodeValidationError{
					field:  "DirectNodeTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectNodeTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreationNodeValidationError{
				field:  "DirectNodeTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreationNodeValidationError{
					field:  "DirectRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreationNodeValidationError{
					field:  "DirectRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreationNodeValidationError{
				field:  "DirectRefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectFromCpfpRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreationNodeValidationError{
					field:  "DirectFromCpfpRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreationNodeValidationError{
					field:  "DirectFromCpfpRefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectFromCpfpRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreationNodeValidationError{
				field:  "DirectFromCpfpRefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreationNodeMultiError(errors)
	}

	return nil
}

// CreationNodeMultiError is an error wrapping multiple validation errors
// returned by CreationNode.ValidateAll() if the designated constraints aren't met.
type CreationNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreationNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreationNodeMultiError) AllErrors() []error { return m }

// CreationNodeValidationError is the validation error returned by
// CreationNode.Validate if the designated constraints aren't met.
type CreationNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreationNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreationNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreationNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreationNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreationNodeValidationError) ErrorName() string { return "CreationNodeValidationError" }

// Error satisfies the builtin error interface
func (e CreationNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreationNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreationNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreationNodeValidationError{}

// Validate checks the field values on CreateTreeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateTreeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTreeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTreeRequestMultiError, or nil if none found.
func (m *CreateTreeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTreeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTreeRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTreeRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTreeRequestValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserIdentityPublicKey

	switch v := m.Source.(type) {
	case *CreateTreeRequest_ParentNodeOutput:
		if v == nil {
			err := CreateTreeRequestValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetParentNodeOutput()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTreeRequestValidationError{
						field:  "ParentNodeOutput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTreeRequestValidationError{
						field:  "ParentNodeOutput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetParentNodeOutput()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTreeRequestValidationError{
					field:  "ParentNodeOutput",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CreateTreeRequest_OnChainUtxo:
		if v == nil {
			err := CreateTreeRequestValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOnChainUtxo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTreeRequestValidationError{
						field:  "OnChainUtxo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTreeRequestValidationError{
						field:  "OnChainUtxo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOnChainUtxo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTreeRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return CreateTreeRequestMultiError(errors)
	}

	return nil
}

// CreateTreeRequestMultiError is an error wrapping multiple validation errors
// returned by CreateTreeRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateTreeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTreeRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTreeRequestMultiError) AllErrors() []error { return m }

// CreateTreeRequestValidationError is the validation error returned by
// CreateTreeRequest.Validate if the designated constraints aren't met.
type CreateTreeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTreeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTreeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTreeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTreeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTreeRequestValidationError) ErrorName() string {
	return "CreateTreeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTreeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTreeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTreeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTreeRequestValidationError{}

// Validate checks the field values on CreationResponseNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreationResponseNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreationResponseNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreationResponseNodeMultiError, or nil if none found.
func (m *CreationResponseNode) ValidateAll() error {
	return m.validate(true)
}

func (m *CreationResponseNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeId

	if all {
		switch v := interface{}(m.GetNodeTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreationResponseNodeValidationError{
					field:  "NodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreationResponseNodeValidationError{
					field:  "NodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreationResponseNodeValidationError{
				field:  "NodeTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreationResponseNodeValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreationResponseNodeValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreationResponseNodeValidationError{
				field:  "RefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreationResponseNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreationResponseNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreationResponseNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetDirectNodeTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreationResponseNodeValidationError{
					field:  "DirectNodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreationResponseNodeValidationError{
					field:  "DirectNodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectNodeTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreationResponseNodeValidationError{
				field:  "DirectNodeTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreationResponseNodeValidationError{
					field:  "DirectRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreationResponseNodeValidationError{
					field:  "DirectRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreationResponseNodeValidationError{
				field:  "DirectRefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirectFromCpfpRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreationResponseNodeValidationError{
					field:  "DirectFromCpfpRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreationResponseNodeValidationError{
					field:  "DirectFromCpfpRefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectFromCpfpRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreationResponseNodeValidationError{
				field:  "DirectFromCpfpRefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreationResponseNodeMultiError(errors)
	}

	return nil
}

// CreationResponseNodeMultiError is an error wrapping multiple validation
// errors returned by CreationResponseNode.ValidateAll() if the designated
// constraints aren't met.
type CreationResponseNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreationResponseNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreationResponseNodeMultiError) AllErrors() []error { return m }

// CreationResponseNodeValidationError is the validation error returned by
// CreationResponseNode.Validate if the designated constraints aren't met.
type CreationResponseNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreationResponseNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreationResponseNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreationResponseNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreationResponseNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreationResponseNodeValidationError) ErrorName() string {
	return "CreationResponseNodeValidationError"
}

// Error satisfies the builtin error interface
func (e CreationResponseNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreationResponseNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreationResponseNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreationResponseNodeValidationError{}

// Validate checks the field values on CreateTreeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTreeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTreeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTreeResponseMultiError, or nil if none found.
func (m *CreateTreeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTreeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTreeResponseValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTreeResponseValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTreeResponseValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTreeResponseMultiError(errors)
	}

	return nil
}

// CreateTreeResponseMultiError is an error wrapping multiple validation errors
// returned by CreateTreeResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateTreeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTreeResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTreeResponseMultiError) AllErrors() []error { return m }

// CreateTreeResponseValidationError is the validation error returned by
// CreateTreeResponse.Validate if the designated constraints aren't met.
type CreateTreeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTreeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTreeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTreeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTreeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTreeResponseValidationError) ErrorName() string {
	return "CreateTreeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTreeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTreeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTreeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTreeResponseValidationError{}

// Validate checks the field values on SigningOperatorInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SigningOperatorInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SigningOperatorInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SigningOperatorInfoMultiError, or nil if none found.
func (m *SigningOperatorInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SigningOperatorInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	// no validation rules for Identifier

	// no validation rules for PublicKey

	// no validation rules for Address

	if len(errors) > 0 {
		return SigningOperatorInfoMultiError(errors)
	}

	return nil
}

// SigningOperatorInfoMultiError is an error wrapping multiple validation
// errors returned by SigningOperatorInfo.ValidateAll() if the designated
// constraints aren't met.
type SigningOperatorInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SigningOperatorInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SigningOperatorInfoMultiError) AllErrors() []error { return m }

// SigningOperatorInfoValidationError is the validation error returned by
// SigningOperatorInfo.Validate if the designated constraints aren't met.
type SigningOperatorInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SigningOperatorInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SigningOperatorInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SigningOperatorInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SigningOperatorInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SigningOperatorInfoValidationError) ErrorName() string {
	return "SigningOperatorInfoValidationError"
}

// Error satisfies the builtin error interface
func (e SigningOperatorInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSigningOperatorInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SigningOperatorInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SigningOperatorInfoValidationError{}

// Validate checks the field values on GetSigningOperatorListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSigningOperatorListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSigningOperatorListResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetSigningOperatorListResponseMultiError, or nil if none found.
func (m *GetSigningOperatorListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSigningOperatorListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetSigningOperators()))
		i := 0
		for key := range m.GetSigningOperators() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSigningOperators()[key]
			_ = val

			// no validation rules for SigningOperators[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetSigningOperatorListResponseValidationError{
							field:  fmt.Sprintf("SigningOperators[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetSigningOperatorListResponseValidationError{
							field:  fmt.Sprintf("SigningOperators[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetSigningOperatorListResponseValidationError{
						field:  fmt.Sprintf("SigningOperators[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return GetSigningOperatorListResponseMultiError(errors)
	}

	return nil
}

// GetSigningOperatorListResponseMultiError is an error wrapping multiple
// validation errors returned by GetSigningOperatorListResponse.ValidateAll()
// if the designated constraints aren't met.
type GetSigningOperatorListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSigningOperatorListResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSigningOperatorListResponseMultiError) AllErrors() []error { return m }

// GetSigningOperatorListResponseValidationError is the validation error
// returned by GetSigningOperatorListResponse.Validate if the designated
// constraints aren't met.
type GetSigningOperatorListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSigningOperatorListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSigningOperatorListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSigningOperatorListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSigningOperatorListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSigningOperatorListResponseValidationError) ErrorName() string {
	return "GetSigningOperatorListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSigningOperatorListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSigningOperatorListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSigningOperatorListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSigningOperatorListResponseValidationError{}

// Validate checks the field values on QueryUserSignedRefundsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryUserSignedRefundsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryUserSignedRefundsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryUserSignedRefundsRequestMultiError, or nil if none found.
func (m *QueryUserSignedRefundsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryUserSignedRefundsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentHash

	// no validation rules for IdentityPublicKey

	if len(errors) > 0 {
		return QueryUserSignedRefundsRequestMultiError(errors)
	}

	return nil
}

// QueryUserSignedRefundsRequestMultiError is an error wrapping multiple
// validation errors returned by QueryUserSignedRefundsRequest.ValidateAll()
// if the designated constraints aren't met.
type QueryUserSignedRefundsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryUserSignedRefundsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryUserSignedRefundsRequestMultiError) AllErrors() []error { return m }

// QueryUserSignedRefundsRequestValidationError is the validation error
// returned by QueryUserSignedRefundsRequest.Validate if the designated
// constraints aren't met.
type QueryUserSignedRefundsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryUserSignedRefundsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryUserSignedRefundsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryUserSignedRefundsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryUserSignedRefundsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryUserSignedRefundsRequestValidationError) ErrorName() string {
	return "QueryUserSignedRefundsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryUserSignedRefundsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryUserSignedRefundsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryUserSignedRefundsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryUserSignedRefundsRequestValidationError{}

// Validate checks the field values on QueryUserSignedRefundsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryUserSignedRefundsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryUserSignedRefundsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryUserSignedRefundsResponseMultiError, or nil if none found.
func (m *QueryUserSignedRefundsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryUserSignedRefundsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUserSignedRefunds() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryUserSignedRefundsResponseValidationError{
						field:  fmt.Sprintf("UserSignedRefunds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryUserSignedRefundsResponseValidationError{
						field:  fmt.Sprintf("UserSignedRefunds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryUserSignedRefundsResponseValidationError{
					field:  fmt.Sprintf("UserSignedRefunds[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryUserSignedRefundsResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryUserSignedRefundsResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryUserSignedRefundsResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QueryUserSignedRefundsResponseMultiError(errors)
	}

	return nil
}

// QueryUserSignedRefundsResponseMultiError is an error wrapping multiple
// validation errors returned by QueryUserSignedRefundsResponse.ValidateAll()
// if the designated constraints aren't met.
type QueryUserSignedRefundsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryUserSignedRefundsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryUserSignedRefundsResponseMultiError) AllErrors() []error { return m }

// QueryUserSignedRefundsResponseValidationError is the validation error
// returned by QueryUserSignedRefundsResponse.Validate if the designated
// constraints aren't met.
type QueryUserSignedRefundsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryUserSignedRefundsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryUserSignedRefundsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryUserSignedRefundsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryUserSignedRefundsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryUserSignedRefundsResponseValidationError) ErrorName() string {
	return "QueryUserSignedRefundsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryUserSignedRefundsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryUserSignedRefundsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryUserSignedRefundsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryUserSignedRefundsResponseValidationError{}

// Validate checks the field values on ProvidePreimageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProvidePreimageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProvidePreimageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProvidePreimageRequestMultiError, or nil if none found.
func (m *ProvidePreimageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProvidePreimageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentHash

	// no validation rules for Preimage

	// no validation rules for IdentityPublicKey

	if len(errors) > 0 {
		return ProvidePreimageRequestMultiError(errors)
	}

	return nil
}

// ProvidePreimageRequestMultiError is an error wrapping multiple validation
// errors returned by ProvidePreimageRequest.ValidateAll() if the designated
// constraints aren't met.
type ProvidePreimageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProvidePreimageRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProvidePreimageRequestMultiError) AllErrors() []error { return m }

// ProvidePreimageRequestValidationError is the validation error returned by
// ProvidePreimageRequest.Validate if the designated constraints aren't met.
type ProvidePreimageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProvidePreimageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProvidePreimageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProvidePreimageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProvidePreimageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProvidePreimageRequestValidationError) ErrorName() string {
	return "ProvidePreimageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProvidePreimageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProvidePreimageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProvidePreimageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProvidePreimageRequestValidationError{}

// Validate checks the field values on ProvidePreimageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProvidePreimageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProvidePreimageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProvidePreimageResponseMultiError, or nil if none found.
func (m *ProvidePreimageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ProvidePreimageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProvidePreimageResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProvidePreimageResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProvidePreimageResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProvidePreimageResponseMultiError(errors)
	}

	return nil
}

// ProvidePreimageResponseMultiError is an error wrapping multiple validation
// errors returned by ProvidePreimageResponse.ValidateAll() if the designated
// constraints aren't met.
type ProvidePreimageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProvidePreimageResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProvidePreimageResponseMultiError) AllErrors() []error { return m }

// ProvidePreimageResponseValidationError is the validation error returned by
// ProvidePreimageResponse.Validate if the designated constraints aren't met.
type ProvidePreimageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProvidePreimageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProvidePreimageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProvidePreimageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProvidePreimageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProvidePreimageResponseValidationError) ErrorName() string {
	return "ProvidePreimageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ProvidePreimageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProvidePreimageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProvidePreimageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProvidePreimageResponseValidationError{}

// Validate checks the field values on ReturnLightningPaymentRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReturnLightningPaymentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReturnLightningPaymentRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReturnLightningPaymentRequestMultiError, or nil if none found.
func (m *ReturnLightningPaymentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReturnLightningPaymentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentHash

	// no validation rules for UserIdentityPublicKey

	if len(errors) > 0 {
		return ReturnLightningPaymentRequestMultiError(errors)
	}

	return nil
}

// ReturnLightningPaymentRequestMultiError is an error wrapping multiple
// validation errors returned by ReturnLightningPaymentRequest.ValidateAll()
// if the designated constraints aren't met.
type ReturnLightningPaymentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReturnLightningPaymentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReturnLightningPaymentRequestMultiError) AllErrors() []error { return m }

// ReturnLightningPaymentRequestValidationError is the validation error
// returned by ReturnLightningPaymentRequest.Validate if the designated
// constraints aren't met.
type ReturnLightningPaymentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReturnLightningPaymentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReturnLightningPaymentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReturnLightningPaymentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReturnLightningPaymentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReturnLightningPaymentRequestValidationError) ErrorName() string {
	return "ReturnLightningPaymentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReturnLightningPaymentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReturnLightningPaymentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReturnLightningPaymentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReturnLightningPaymentRequestValidationError{}

// Validate checks the field values on TreeNodeIds with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TreeNodeIds) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TreeNodeIds with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TreeNodeIdsMultiError, or
// nil if none found.
func (m *TreeNodeIds) ValidateAll() error {
	return m.validate(true)
}

func (m *TreeNodeIds) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TreeNodeIdsMultiError(errors)
	}

	return nil
}

// TreeNodeIdsMultiError is an error wrapping multiple validation errors
// returned by TreeNodeIds.ValidateAll() if the designated constraints aren't met.
type TreeNodeIdsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TreeNodeIdsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TreeNodeIdsMultiError) AllErrors() []error { return m }

// TreeNodeIdsValidationError is the validation error returned by
// TreeNodeIds.Validate if the designated constraints aren't met.
type TreeNodeIdsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TreeNodeIdsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TreeNodeIdsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TreeNodeIdsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TreeNodeIdsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TreeNodeIdsValidationError) ErrorName() string { return "TreeNodeIdsValidationError" }

// Error satisfies the builtin error interface
func (e TreeNodeIdsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTreeNodeIds.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TreeNodeIdsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TreeNodeIdsValidationError{}

// Validate checks the field values on QueryNodesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *QueryNodesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryNodesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryNodesRequestMultiError, or nil if none found.
func (m *QueryNodesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryNodesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IncludeParents

	// no validation rules for Limit

	// no validation rules for Offset

	// no validation rules for Network

	switch v := m.Source.(type) {
	case *QueryNodesRequest_OwnerIdentityPubkey:
		if v == nil {
			err := QueryNodesRequestValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for OwnerIdentityPubkey
	case *QueryNodesRequest_NodeIds:
		if v == nil {
			err := QueryNodesRequestValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNodeIds()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryNodesRequestValidationError{
						field:  "NodeIds",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryNodesRequestValidationError{
						field:  "NodeIds",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNodeIds()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryNodesRequestValidationError{
					field:  "NodeIds",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return QueryNodesRequestMultiError(errors)
	}

	return nil
}

// QueryNodesRequestMultiError is an error wrapping multiple validation errors
// returned by QueryNodesRequest.ValidateAll() if the designated constraints
// aren't met.
type QueryNodesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryNodesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryNodesRequestMultiError) AllErrors() []error { return m }

// QueryNodesRequestValidationError is the validation error returned by
// QueryNodesRequest.Validate if the designated constraints aren't met.
type QueryNodesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryNodesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryNodesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryNodesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryNodesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryNodesRequestValidationError) ErrorName() string {
	return "QueryNodesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryNodesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryNodesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryNodesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryNodesRequestValidationError{}

// Validate checks the field values on QueryNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryNodesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryNodesResponseMultiError, or nil if none found.
func (m *QueryNodesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryNodesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetNodes()))
		i := 0
		for key := range m.GetNodes() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetNodes()[key]
			_ = val

			// no validation rules for Nodes[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, QueryNodesResponseValidationError{
							field:  fmt.Sprintf("Nodes[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, QueryNodesResponseValidationError{
							field:  fmt.Sprintf("Nodes[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return QueryNodesResponseValidationError{
						field:  fmt.Sprintf("Nodes[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Offset

	if len(errors) > 0 {
		return QueryNodesResponseMultiError(errors)
	}

	return nil
}

// QueryNodesResponseMultiError is an error wrapping multiple validation errors
// returned by QueryNodesResponse.ValidateAll() if the designated constraints
// aren't met.
type QueryNodesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryNodesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryNodesResponseMultiError) AllErrors() []error { return m }

// QueryNodesResponseValidationError is the validation error returned by
// QueryNodesResponse.Validate if the designated constraints aren't met.
type QueryNodesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryNodesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryNodesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryNodesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryNodesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryNodesResponseValidationError) ErrorName() string {
	return "QueryNodesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryNodesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryNodesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryNodesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryNodesResponseValidationError{}

// Validate checks the field values on CancelTransferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelTransferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelTransferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelTransferRequestMultiError, or nil if none found.
func (m *CancelTransferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelTransferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for SenderIdentityPublicKey

	if len(errors) > 0 {
		return CancelTransferRequestMultiError(errors)
	}

	return nil
}

// CancelTransferRequestMultiError is an error wrapping multiple validation
// errors returned by CancelTransferRequest.ValidateAll() if the designated
// constraints aren't met.
type CancelTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelTransferRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelTransferRequestMultiError) AllErrors() []error { return m }

// CancelTransferRequestValidationError is the validation error returned by
// CancelTransferRequest.Validate if the designated constraints aren't met.
type CancelTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelTransferRequestValidationError) ErrorName() string {
	return "CancelTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CancelTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelTransferRequestValidationError{}

// Validate checks the field values on CancelTransferResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelTransferResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelTransferResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelTransferResponseMultiError, or nil if none found.
func (m *CancelTransferResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelTransferResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CancelTransferResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CancelTransferResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CancelTransferResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CancelTransferResponseMultiError(errors)
	}

	return nil
}

// CancelTransferResponseMultiError is an error wrapping multiple validation
// errors returned by CancelTransferResponse.ValidateAll() if the designated
// constraints aren't met.
type CancelTransferResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelTransferResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelTransferResponseMultiError) AllErrors() []error { return m }

// CancelTransferResponseValidationError is the validation error returned by
// CancelTransferResponse.Validate if the designated constraints aren't met.
type CancelTransferResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelTransferResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelTransferResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelTransferResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelTransferResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelTransferResponseValidationError) ErrorName() string {
	return "CancelTransferResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CancelTransferResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelTransferResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelTransferResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelTransferResponseValidationError{}

// Validate checks the field values on QueryUnusedDepositAddressesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *QueryUnusedDepositAddressesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryUnusedDepositAddressesRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// QueryUnusedDepositAddressesRequestMultiError, or nil if none found.
func (m *QueryUnusedDepositAddressesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryUnusedDepositAddressesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdentityPublicKey

	// no validation rules for Network

	// no validation rules for Limit

	// no validation rules for Offset

	if len(errors) > 0 {
		return QueryUnusedDepositAddressesRequestMultiError(errors)
	}

	return nil
}

// QueryUnusedDepositAddressesRequestMultiError is an error wrapping multiple
// validation errors returned by
// QueryUnusedDepositAddressesRequest.ValidateAll() if the designated
// constraints aren't met.
type QueryUnusedDepositAddressesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryUnusedDepositAddressesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryUnusedDepositAddressesRequestMultiError) AllErrors() []error { return m }

// QueryUnusedDepositAddressesRequestValidationError is the validation error
// returned by QueryUnusedDepositAddressesRequest.Validate if the designated
// constraints aren't met.
type QueryUnusedDepositAddressesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryUnusedDepositAddressesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryUnusedDepositAddressesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryUnusedDepositAddressesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryUnusedDepositAddressesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryUnusedDepositAddressesRequestValidationError) ErrorName() string {
	return "QueryUnusedDepositAddressesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryUnusedDepositAddressesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryUnusedDepositAddressesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryUnusedDepositAddressesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryUnusedDepositAddressesRequestValidationError{}

// Validate checks the field values on QueryStaticDepositAddressesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *QueryStaticDepositAddressesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryStaticDepositAddressesRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// QueryStaticDepositAddressesRequestMultiError, or nil if none found.
func (m *QueryStaticDepositAddressesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryStaticDepositAddressesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdentityPublicKey

	// no validation rules for Network

	// no validation rules for Limit

	// no validation rules for Offset

	if m.DepositAddress != nil {
		// no validation rules for DepositAddress
	}

	if len(errors) > 0 {
		return QueryStaticDepositAddressesRequestMultiError(errors)
	}

	return nil
}

// QueryStaticDepositAddressesRequestMultiError is an error wrapping multiple
// validation errors returned by
// QueryStaticDepositAddressesRequest.ValidateAll() if the designated
// constraints aren't met.
type QueryStaticDepositAddressesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryStaticDepositAddressesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryStaticDepositAddressesRequestMultiError) AllErrors() []error { return m }

// QueryStaticDepositAddressesRequestValidationError is the validation error
// returned by QueryStaticDepositAddressesRequest.Validate if the designated
// constraints aren't met.
type QueryStaticDepositAddressesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryStaticDepositAddressesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryStaticDepositAddressesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryStaticDepositAddressesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryStaticDepositAddressesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryStaticDepositAddressesRequestValidationError) ErrorName() string {
	return "QueryStaticDepositAddressesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryStaticDepositAddressesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryStaticDepositAddressesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryStaticDepositAddressesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryStaticDepositAddressesRequestValidationError{}

// Validate checks the field values on DepositAddressQueryResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DepositAddressQueryResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DepositAddressQueryResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DepositAddressQueryResultMultiError, or nil if none found.
func (m *DepositAddressQueryResult) ValidateAll() error {
	return m.validate(true)
}

func (m *DepositAddressQueryResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DepositAddress

	// no validation rules for UserSigningPublicKey

	// no validation rules for VerifyingPublicKey

	if m.LeafId != nil {

		if err := m._validateUuid(m.GetLeafId()); err != nil {
			err = DepositAddressQueryResultValidationError{
				field:  "LeafId",
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.ProofOfPossession != nil {

		if all {
			switch v := interface{}(m.GetProofOfPossession()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DepositAddressQueryResultValidationError{
						field:  "ProofOfPossession",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DepositAddressQueryResultValidationError{
						field:  "ProofOfPossession",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProofOfPossession()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DepositAddressQueryResultValidationError{
					field:  "ProofOfPossession",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DepositAddressQueryResultMultiError(errors)
	}

	return nil
}

func (m *DepositAddressQueryResult) _validateUuid(uuid string) error {
	if matched := _spark_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DepositAddressQueryResultMultiError is an error wrapping multiple validation
// errors returned by DepositAddressQueryResult.ValidateAll() if the
// designated constraints aren't met.
type DepositAddressQueryResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DepositAddressQueryResultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DepositAddressQueryResultMultiError) AllErrors() []error { return m }

// DepositAddressQueryResultValidationError is the validation error returned by
// DepositAddressQueryResult.Validate if the designated constraints aren't met.
type DepositAddressQueryResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DepositAddressQueryResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DepositAddressQueryResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DepositAddressQueryResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DepositAddressQueryResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DepositAddressQueryResultValidationError) ErrorName() string {
	return "DepositAddressQueryResultValidationError"
}

// Error satisfies the builtin error interface
func (e DepositAddressQueryResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDepositAddressQueryResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DepositAddressQueryResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DepositAddressQueryResultValidationError{}

// Validate checks the field values on QueryUnusedDepositAddressesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *QueryUnusedDepositAddressesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryUnusedDepositAddressesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// QueryUnusedDepositAddressesResponseMultiError, or nil if none found.
func (m *QueryUnusedDepositAddressesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryUnusedDepositAddressesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDepositAddresses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryUnusedDepositAddressesResponseValidationError{
						field:  fmt.Sprintf("DepositAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryUnusedDepositAddressesResponseValidationError{
						field:  fmt.Sprintf("DepositAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryUnusedDepositAddressesResponseValidationError{
					field:  fmt.Sprintf("DepositAddresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Offset

	if len(errors) > 0 {
		return QueryUnusedDepositAddressesResponseMultiError(errors)
	}

	return nil
}

// QueryUnusedDepositAddressesResponseMultiError is an error wrapping multiple
// validation errors returned by
// QueryUnusedDepositAddressesResponse.ValidateAll() if the designated
// constraints aren't met.
type QueryUnusedDepositAddressesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryUnusedDepositAddressesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryUnusedDepositAddressesResponseMultiError) AllErrors() []error { return m }

// QueryUnusedDepositAddressesResponseValidationError is the validation error
// returned by QueryUnusedDepositAddressesResponse.Validate if the designated
// constraints aren't met.
type QueryUnusedDepositAddressesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryUnusedDepositAddressesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryUnusedDepositAddressesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryUnusedDepositAddressesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryUnusedDepositAddressesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryUnusedDepositAddressesResponseValidationError) ErrorName() string {
	return "QueryUnusedDepositAddressesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryUnusedDepositAddressesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryUnusedDepositAddressesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryUnusedDepositAddressesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryUnusedDepositAddressesResponseValidationError{}

// Validate checks the field values on QueryStaticDepositAddressesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *QueryStaticDepositAddressesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryStaticDepositAddressesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// QueryStaticDepositAddressesResponseMultiError, or nil if none found.
func (m *QueryStaticDepositAddressesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryStaticDepositAddressesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDepositAddresses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryStaticDepositAddressesResponseValidationError{
						field:  fmt.Sprintf("DepositAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryStaticDepositAddressesResponseValidationError{
						field:  fmt.Sprintf("DepositAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryStaticDepositAddressesResponseValidationError{
					field:  fmt.Sprintf("DepositAddresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryStaticDepositAddressesResponseMultiError(errors)
	}

	return nil
}

// QueryStaticDepositAddressesResponseMultiError is an error wrapping multiple
// validation errors returned by
// QueryStaticDepositAddressesResponse.ValidateAll() if the designated
// constraints aren't met.
type QueryStaticDepositAddressesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryStaticDepositAddressesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryStaticDepositAddressesResponseMultiError) AllErrors() []error { return m }

// QueryStaticDepositAddressesResponseValidationError is the validation error
// returned by QueryStaticDepositAddressesResponse.Validate if the designated
// constraints aren't met.
type QueryStaticDepositAddressesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryStaticDepositAddressesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryStaticDepositAddressesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryStaticDepositAddressesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryStaticDepositAddressesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryStaticDepositAddressesResponseValidationError) ErrorName() string {
	return "QueryStaticDepositAddressesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryStaticDepositAddressesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryStaticDepositAddressesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryStaticDepositAddressesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryStaticDepositAddressesResponseValidationError{}

// Validate checks the field values on QueryBalanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryBalanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryBalanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryBalanceRequestMultiError, or nil if none found.
func (m *QueryBalanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryBalanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdentityPublicKey

	// no validation rules for Network

	if len(errors) > 0 {
		return QueryBalanceRequestMultiError(errors)
	}

	return nil
}

// QueryBalanceRequestMultiError is an error wrapping multiple validation
// errors returned by QueryBalanceRequest.ValidateAll() if the designated
// constraints aren't met.
type QueryBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryBalanceRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryBalanceRequestMultiError) AllErrors() []error { return m }

// QueryBalanceRequestValidationError is the validation error returned by
// QueryBalanceRequest.Validate if the designated constraints aren't met.
type QueryBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryBalanceRequestValidationError) ErrorName() string {
	return "QueryBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryBalanceRequestValidationError{}

// Validate checks the field values on QueryBalanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryBalanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryBalanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryBalanceResponseMultiError, or nil if none found.
func (m *QueryBalanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryBalanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Balance

	// no validation rules for NodeBalances

	if len(errors) > 0 {
		return QueryBalanceResponseMultiError(errors)
	}

	return nil
}

// QueryBalanceResponseMultiError is an error wrapping multiple validation
// errors returned by QueryBalanceResponse.ValidateAll() if the designated
// constraints aren't met.
type QueryBalanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryBalanceResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryBalanceResponseMultiError) AllErrors() []error { return m }

// QueryBalanceResponseValidationError is the validation error returned by
// QueryBalanceResponse.Validate if the designated constraints aren't met.
type QueryBalanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryBalanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryBalanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryBalanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryBalanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryBalanceResponseValidationError) ErrorName() string {
	return "QueryBalanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryBalanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryBalanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryBalanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryBalanceResponseValidationError{}

// Validate checks the field values on SparkAddress with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SparkAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SparkAddress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SparkAddressMultiError, or
// nil if none found.
func (m *SparkAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *SparkAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdentityPublicKey

	if all {
		switch v := interface{}(m.GetSparkInvoiceFields()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SparkAddressValidationError{
					field:  "SparkInvoiceFields",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SparkAddressValidationError{
					field:  "SparkInvoiceFields",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSparkInvoiceFields()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SparkAddressValidationError{
				field:  "SparkInvoiceFields",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Signature != nil {

		if len(m.GetSignature()) != 64 {
			err := SparkAddressValidationError{
				field:  "Signature",
				reason: "value length must be 64 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return SparkAddressMultiError(errors)
	}

	return nil
}

// SparkAddressMultiError is an error wrapping multiple validation errors
// returned by SparkAddress.ValidateAll() if the designated constraints aren't met.
type SparkAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SparkAddressMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SparkAddressMultiError) AllErrors() []error { return m }

// SparkAddressValidationError is the validation error returned by
// SparkAddress.Validate if the designated constraints aren't met.
type SparkAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SparkAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SparkAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SparkAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SparkAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SparkAddressValidationError) ErrorName() string { return "SparkAddressValidationError" }

// Error satisfies the builtin error interface
func (e SparkAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSparkAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SparkAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SparkAddressValidationError{}

// Validate checks the field values on SparkInvoiceFields with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SparkInvoiceFields) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SparkInvoiceFields with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SparkInvoiceFieldsMultiError, or nil if none found.
func (m *SparkInvoiceFields) ValidateAll() error {
	return m.validate(true)
}

func (m *SparkInvoiceFields) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	if len(m.GetId()) != 16 {
		err := SparkInvoiceFieldsValidationError{
			field:  "Id",
			reason: "value length must be 16 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	switch v := m.PaymentType.(type) {
	case *SparkInvoiceFields_TokensPayment:
		if v == nil {
			err := SparkInvoiceFieldsValidationError{
				field:  "PaymentType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTokensPayment()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SparkInvoiceFieldsValidationError{
						field:  "TokensPayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SparkInvoiceFieldsValidationError{
						field:  "TokensPayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTokensPayment()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SparkInvoiceFieldsValidationError{
					field:  "TokensPayment",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SparkInvoiceFields_SatsPayment:
		if v == nil {
			err := SparkInvoiceFieldsValidationError{
				field:  "PaymentType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSatsPayment()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SparkInvoiceFieldsValidationError{
						field:  "SatsPayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SparkInvoiceFieldsValidationError{
						field:  "SatsPayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSatsPayment()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SparkInvoiceFieldsValidationError{
					field:  "SatsPayment",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if m.Memo != nil {

		if len(m.GetMemo()) > 120 {
			err := SparkInvoiceFieldsValidationError{
				field:  "Memo",
				reason: "value length must be at most 120 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.SenderPublicKey != nil {

		if len(m.GetSenderPublicKey()) != 33 {
			err := SparkInvoiceFieldsValidationError{
				field:  "SenderPublicKey",
				reason: "value length must be 33 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.ExpiryTime != nil {

		if all {
			switch v := interface{}(m.GetExpiryTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SparkInvoiceFieldsValidationError{
						field:  "ExpiryTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SparkInvoiceFieldsValidationError{
						field:  "ExpiryTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExpiryTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SparkInvoiceFieldsValidationError{
					field:  "ExpiryTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SparkInvoiceFieldsMultiError(errors)
	}

	return nil
}

// SparkInvoiceFieldsMultiError is an error wrapping multiple validation errors
// returned by SparkInvoiceFields.ValidateAll() if the designated constraints
// aren't met.
type SparkInvoiceFieldsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SparkInvoiceFieldsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SparkInvoiceFieldsMultiError) AllErrors() []error { return m }

// SparkInvoiceFieldsValidationError is the validation error returned by
// SparkInvoiceFields.Validate if the designated constraints aren't met.
type SparkInvoiceFieldsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SparkInvoiceFieldsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SparkInvoiceFieldsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SparkInvoiceFieldsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SparkInvoiceFieldsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SparkInvoiceFieldsValidationError) ErrorName() string {
	return "SparkInvoiceFieldsValidationError"
}

// Error satisfies the builtin error interface
func (e SparkInvoiceFieldsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSparkInvoiceFields.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SparkInvoiceFieldsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SparkInvoiceFieldsValidationError{}

// Validate checks the field values on SatsPayment with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SatsPayment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SatsPayment with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SatsPaymentMultiError, or
// nil if none found.
func (m *SatsPayment) ValidateAll() error {
	return m.validate(true)
}

func (m *SatsPayment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Amount != nil {
		// no validation rules for Amount
	}

	if len(errors) > 0 {
		return SatsPaymentMultiError(errors)
	}

	return nil
}

// SatsPaymentMultiError is an error wrapping multiple validation errors
// returned by SatsPayment.ValidateAll() if the designated constraints aren't met.
type SatsPaymentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SatsPaymentMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SatsPaymentMultiError) AllErrors() []error { return m }

// SatsPaymentValidationError is the validation error returned by
// SatsPayment.Validate if the designated constraints aren't met.
type SatsPaymentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SatsPaymentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SatsPaymentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SatsPaymentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SatsPaymentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SatsPaymentValidationError) ErrorName() string { return "SatsPaymentValidationError" }

// Error satisfies the builtin error interface
func (e SatsPaymentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSatsPayment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SatsPaymentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SatsPaymentValidationError{}

// Validate checks the field values on TokensPayment with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TokensPayment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokensPayment with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TokensPaymentMultiError, or
// nil if none found.
func (m *TokensPayment) ValidateAll() error {
	return m.validate(true)
}

func (m *TokensPayment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.TokenIdentifier != nil {

		if len(m.GetTokenIdentifier()) != 32 {
			err := TokensPaymentValidationError{
				field:  "TokenIdentifier",
				reason: "value length must be 32 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Amount != nil {

		if len(m.GetAmount()) > 16 {
			err := TokensPaymentValidationError{
				field:  "Amount",
				reason: "value length must be at most 16 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return TokensPaymentMultiError(errors)
	}

	return nil
}

// TokensPaymentMultiError is an error wrapping multiple validation errors
// returned by TokensPayment.ValidateAll() if the designated constraints
// aren't met.
type TokensPaymentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokensPaymentMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokensPaymentMultiError) AllErrors() []error { return m }

// TokensPaymentValidationError is the validation error returned by
// TokensPayment.Validate if the designated constraints aren't met.
type TokensPaymentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokensPaymentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokensPaymentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokensPaymentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokensPaymentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokensPaymentValidationError) ErrorName() string { return "TokensPaymentValidationError" }

// Error satisfies the builtin error interface
func (e TokensPaymentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokensPayment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokensPaymentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokensPaymentValidationError{}

// Validate checks the field values on InitiateStaticDepositUtxoRefundRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *InitiateStaticDepositUtxoRefundRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// InitiateStaticDepositUtxoRefundRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// InitiateStaticDepositUtxoRefundRequestMultiError, or nil if none found.
func (m *InitiateStaticDepositUtxoRefundRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateStaticDepositUtxoRefundRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOnChainUtxo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateStaticDepositUtxoRefundRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateStaticDepositUtxoRefundRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOnChainUtxo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateStaticDepositUtxoRefundRequestValidationError{
				field:  "OnChainUtxo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateStaticDepositUtxoRefundRequestValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateStaticDepositUtxoRefundRequestValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateStaticDepositUtxoRefundRequestValidationError{
				field:  "RefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserSignature

	if len(errors) > 0 {
		return InitiateStaticDepositUtxoRefundRequestMultiError(errors)
	}

	return nil
}

// InitiateStaticDepositUtxoRefundRequestMultiError is an error wrapping
// multiple validation errors returned by
// InitiateStaticDepositUtxoRefundRequest.ValidateAll() if the designated
// constraints aren't met.
type InitiateStaticDepositUtxoRefundRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateStaticDepositUtxoRefundRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateStaticDepositUtxoRefundRequestMultiError) AllErrors() []error { return m }

// InitiateStaticDepositUtxoRefundRequestValidationError is the validation
// error returned by InitiateStaticDepositUtxoRefundRequest.Validate if the
// designated constraints aren't met.
type InitiateStaticDepositUtxoRefundRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateStaticDepositUtxoRefundRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateStaticDepositUtxoRefundRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateStaticDepositUtxoRefundRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateStaticDepositUtxoRefundRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateStaticDepositUtxoRefundRequestValidationError) ErrorName() string {
	return "InitiateStaticDepositUtxoRefundRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateStaticDepositUtxoRefundRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateStaticDepositUtxoRefundRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateStaticDepositUtxoRefundRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateStaticDepositUtxoRefundRequestValidationError{}

// Validate checks the field values on InitiateStaticDepositUtxoRefundResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *InitiateStaticDepositUtxoRefundResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// InitiateStaticDepositUtxoRefundResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// InitiateStaticDepositUtxoRefundResponseMultiError, or nil if none found.
func (m *InitiateStaticDepositUtxoRefundResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateStaticDepositUtxoRefundResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateStaticDepositUtxoRefundResponseValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateStaticDepositUtxoRefundResponseValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateStaticDepositUtxoRefundResponseValidationError{
				field:  "RefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDepositAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateStaticDepositUtxoRefundResponseValidationError{
					field:  "DepositAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateStaticDepositUtxoRefundResponseValidationError{
					field:  "DepositAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDepositAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateStaticDepositUtxoRefundResponseValidationError{
				field:  "DepositAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InitiateStaticDepositUtxoRefundResponseMultiError(errors)
	}

	return nil
}

// InitiateStaticDepositUtxoRefundResponseMultiError is an error wrapping
// multiple validation errors returned by
// InitiateStaticDepositUtxoRefundResponse.ValidateAll() if the designated
// constraints aren't met.
type InitiateStaticDepositUtxoRefundResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateStaticDepositUtxoRefundResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateStaticDepositUtxoRefundResponseMultiError) AllErrors() []error { return m }

// InitiateStaticDepositUtxoRefundResponseValidationError is the validation
// error returned by InitiateStaticDepositUtxoRefundResponse.Validate if the
// designated constraints aren't met.
type InitiateStaticDepositUtxoRefundResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateStaticDepositUtxoRefundResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateStaticDepositUtxoRefundResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateStaticDepositUtxoRefundResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateStaticDepositUtxoRefundResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateStaticDepositUtxoRefundResponseValidationError) ErrorName() string {
	return "InitiateStaticDepositUtxoRefundResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateStaticDepositUtxoRefundResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateStaticDepositUtxoRefundResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateStaticDepositUtxoRefundResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateStaticDepositUtxoRefundResponseValidationError{}

// Validate checks the field values on InitiateUtxoSwapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiateUtxoSwapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiateUtxoSwapRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiateUtxoSwapRequestMultiError, or nil if none found.
func (m *InitiateUtxoSwapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateUtxoSwapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOnChainUtxo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateUtxoSwapRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateUtxoSwapRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOnChainUtxo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateUtxoSwapRequestValidationError{
				field:  "OnChainUtxo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequestType

	// no validation rules for SspSignature

	// no validation rules for UserSignature

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateUtxoSwapRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateUtxoSwapRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateUtxoSwapRequestValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpendTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateUtxoSwapRequestValidationError{
					field:  "SpendTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateUtxoSwapRequestValidationError{
					field:  "SpendTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpendTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateUtxoSwapRequestValidationError{
				field:  "SpendTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Amount.(type) {
	case *InitiateUtxoSwapRequest_CreditAmountSats:
		if v == nil {
			err := InitiateUtxoSwapRequestValidationError{
				field:  "Amount",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for CreditAmountSats
	case *InitiateUtxoSwapRequest_MaxFeeSats:
		if v == nil {
			err := InitiateUtxoSwapRequestValidationError{
				field:  "Amount",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for MaxFeeSats
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return InitiateUtxoSwapRequestMultiError(errors)
	}

	return nil
}

// InitiateUtxoSwapRequestMultiError is an error wrapping multiple validation
// errors returned by InitiateUtxoSwapRequest.ValidateAll() if the designated
// constraints aren't met.
type InitiateUtxoSwapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateUtxoSwapRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateUtxoSwapRequestMultiError) AllErrors() []error { return m }

// InitiateUtxoSwapRequestValidationError is the validation error returned by
// InitiateUtxoSwapRequest.Validate if the designated constraints aren't met.
type InitiateUtxoSwapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateUtxoSwapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateUtxoSwapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateUtxoSwapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateUtxoSwapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateUtxoSwapRequestValidationError) ErrorName() string {
	return "InitiateUtxoSwapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateUtxoSwapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateUtxoSwapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateUtxoSwapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateUtxoSwapRequestValidationError{}

// Validate checks the field values on InitiateUtxoSwapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiateUtxoSwapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiateUtxoSwapResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiateUtxoSwapResponseMultiError, or nil if none found.
func (m *InitiateUtxoSwapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateUtxoSwapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpendTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateUtxoSwapResponseValidationError{
					field:  "SpendTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateUtxoSwapResponseValidationError{
					field:  "SpendTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpendTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateUtxoSwapResponseValidationError{
				field:  "SpendTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateUtxoSwapResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateUtxoSwapResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateUtxoSwapResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDepositAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateUtxoSwapResponseValidationError{
					field:  "DepositAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateUtxoSwapResponseValidationError{
					field:  "DepositAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDepositAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateUtxoSwapResponseValidationError{
				field:  "DepositAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InitiateUtxoSwapResponseMultiError(errors)
	}

	return nil
}

// InitiateUtxoSwapResponseMultiError is an error wrapping multiple validation
// errors returned by InitiateUtxoSwapResponse.ValidateAll() if the designated
// constraints aren't met.
type InitiateUtxoSwapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateUtxoSwapResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateUtxoSwapResponseMultiError) AllErrors() []error { return m }

// InitiateUtxoSwapResponseValidationError is the validation error returned by
// InitiateUtxoSwapResponse.Validate if the designated constraints aren't met.
type InitiateUtxoSwapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateUtxoSwapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateUtxoSwapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateUtxoSwapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateUtxoSwapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateUtxoSwapResponseValidationError) ErrorName() string {
	return "InitiateUtxoSwapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateUtxoSwapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateUtxoSwapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateUtxoSwapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateUtxoSwapResponseValidationError{}

// Validate checks the field values on ExitingTree with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExitingTree) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExitingTree with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExitingTreeMultiError, or
// nil if none found.
func (m *ExitingTree) ValidateAll() error {
	return m.validate(true)
}

func (m *ExitingTree) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TreeId

	if all {
		switch v := interface{}(m.GetUserSigningCommitment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExitingTreeValidationError{
					field:  "UserSigningCommitment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExitingTreeValidationError{
					field:  "UserSigningCommitment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserSigningCommitment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExitingTreeValidationError{
				field:  "UserSigningCommitment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Vin

	if len(errors) > 0 {
		return ExitingTreeMultiError(errors)
	}

	return nil
}

// ExitingTreeMultiError is an error wrapping multiple validation errors
// returned by ExitingTree.ValidateAll() if the designated constraints aren't met.
type ExitingTreeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExitingTreeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExitingTreeMultiError) AllErrors() []error { return m }

// ExitingTreeValidationError is the validation error returned by
// ExitingTree.Validate if the designated constraints aren't met.
type ExitingTreeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExitingTreeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExitingTreeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExitingTreeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExitingTreeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExitingTreeValidationError) ErrorName() string { return "ExitingTreeValidationError" }

// Error satisfies the builtin error interface
func (e ExitingTreeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExitingTree.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExitingTreeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExitingTreeValidationError{}

// Validate checks the field values on ExitSingleNodeTreeSigningResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExitSingleNodeTreeSigningResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExitSingleNodeTreeSigningResult with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ExitSingleNodeTreeSigningResultMultiError, or nil if none found.
func (m *ExitSingleNodeTreeSigningResult) ValidateAll() error {
	return m.validate(true)
}

func (m *ExitSingleNodeTreeSigningResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TreeId

	if all {
		switch v := interface{}(m.GetSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExitSingleNodeTreeSigningResultValidationError{
					field:  "SigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExitSingleNodeTreeSigningResultValidationError{
					field:  "SigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExitSingleNodeTreeSigningResultValidationError{
				field:  "SigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VerifyingKey

	if len(errors) > 0 {
		return ExitSingleNodeTreeSigningResultMultiError(errors)
	}

	return nil
}

// ExitSingleNodeTreeSigningResultMultiError is an error wrapping multiple
// validation errors returned by ExitSingleNodeTreeSigningResult.ValidateAll()
// if the designated constraints aren't met.
type ExitSingleNodeTreeSigningResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExitSingleNodeTreeSigningResultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExitSingleNodeTreeSigningResultMultiError) AllErrors() []error { return m }

// ExitSingleNodeTreeSigningResultValidationError is the validation error
// returned by ExitSingleNodeTreeSigningResult.Validate if the designated
// constraints aren't met.
type ExitSingleNodeTreeSigningResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExitSingleNodeTreeSigningResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExitSingleNodeTreeSigningResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExitSingleNodeTreeSigningResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExitSingleNodeTreeSigningResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExitSingleNodeTreeSigningResultValidationError) ErrorName() string {
	return "ExitSingleNodeTreeSigningResultValidationError"
}

// Error satisfies the builtin error interface
func (e ExitSingleNodeTreeSigningResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExitSingleNodeTreeSigningResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExitSingleNodeTreeSigningResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExitSingleNodeTreeSigningResultValidationError{}

// Validate checks the field values on BitcoinTransactionOutput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BitcoinTransactionOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BitcoinTransactionOutput with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BitcoinTransactionOutputMultiError, or nil if none found.
func (m *BitcoinTransactionOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *BitcoinTransactionOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	// no validation rules for PkScript

	if len(errors) > 0 {
		return BitcoinTransactionOutputMultiError(errors)
	}

	return nil
}

// BitcoinTransactionOutputMultiError is an error wrapping multiple validation
// errors returned by BitcoinTransactionOutput.ValidateAll() if the designated
// constraints aren't met.
type BitcoinTransactionOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BitcoinTransactionOutputMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BitcoinTransactionOutputMultiError) AllErrors() []error { return m }

// BitcoinTransactionOutputValidationError is the validation error returned by
// BitcoinTransactionOutput.Validate if the designated constraints aren't met.
type BitcoinTransactionOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BitcoinTransactionOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BitcoinTransactionOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BitcoinTransactionOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BitcoinTransactionOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BitcoinTransactionOutputValidationError) ErrorName() string {
	return "BitcoinTransactionOutputValidationError"
}

// Error satisfies the builtin error interface
func (e BitcoinTransactionOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBitcoinTransactionOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BitcoinTransactionOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BitcoinTransactionOutputValidationError{}

// Validate checks the field values on ExitSingleNodeTreesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExitSingleNodeTreesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExitSingleNodeTreesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExitSingleNodeTreesRequestMultiError, or nil if none found.
func (m *ExitSingleNodeTreesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExitSingleNodeTreesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerIdentityPublicKey

	for idx, item := range m.GetExitingTrees() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExitSingleNodeTreesRequestValidationError{
						field:  fmt.Sprintf("ExitingTrees[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExitSingleNodeTreesRequestValidationError{
						field:  fmt.Sprintf("ExitingTrees[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExitSingleNodeTreesRequestValidationError{
					field:  fmt.Sprintf("ExitingTrees[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RawTx

	for idx, item := range m.GetPreviousOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExitSingleNodeTreesRequestValidationError{
						field:  fmt.Sprintf("PreviousOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExitSingleNodeTreesRequestValidationError{
						field:  fmt.Sprintf("PreviousOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExitSingleNodeTreesRequestValidationError{
					field:  fmt.Sprintf("PreviousOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExitSingleNodeTreesRequestMultiError(errors)
	}

	return nil
}

// ExitSingleNodeTreesRequestMultiError is an error wrapping multiple
// validation errors returned by ExitSingleNodeTreesRequest.ValidateAll() if
// the designated constraints aren't met.
type ExitSingleNodeTreesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExitSingleNodeTreesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExitSingleNodeTreesRequestMultiError) AllErrors() []error { return m }

// ExitSingleNodeTreesRequestValidationError is the validation error returned
// by ExitSingleNodeTreesRequest.Validate if the designated constraints aren't met.
type ExitSingleNodeTreesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExitSingleNodeTreesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExitSingleNodeTreesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExitSingleNodeTreesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExitSingleNodeTreesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExitSingleNodeTreesRequestValidationError) ErrorName() string {
	return "ExitSingleNodeTreesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExitSingleNodeTreesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExitSingleNodeTreesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExitSingleNodeTreesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExitSingleNodeTreesRequestValidationError{}

// Validate checks the field values on ExitSingleNodeTreesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExitSingleNodeTreesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExitSingleNodeTreesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExitSingleNodeTreesResponseMultiError, or nil if none found.
func (m *ExitSingleNodeTreesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExitSingleNodeTreesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSigningResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExitSingleNodeTreesResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExitSingleNodeTreesResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExitSingleNodeTreesResponseValidationError{
					field:  fmt.Sprintf("SigningResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExitSingleNodeTreesResponseMultiError(errors)
	}

	return nil
}

// ExitSingleNodeTreesResponseMultiError is an error wrapping multiple
// validation errors returned by ExitSingleNodeTreesResponse.ValidateAll() if
// the designated constraints aren't met.
type ExitSingleNodeTreesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExitSingleNodeTreesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExitSingleNodeTreesResponseMultiError) AllErrors() []error { return m }

// ExitSingleNodeTreesResponseValidationError is the validation error returned
// by ExitSingleNodeTreesResponse.Validate if the designated constraints
// aren't met.
type ExitSingleNodeTreesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExitSingleNodeTreesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExitSingleNodeTreesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExitSingleNodeTreesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExitSingleNodeTreesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExitSingleNodeTreesResponseValidationError) ErrorName() string {
	return "ExitSingleNodeTreesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExitSingleNodeTreesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExitSingleNodeTreesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExitSingleNodeTreesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExitSingleNodeTreesResponseValidationError{}

// Validate checks the field values on InvestigateLeavesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InvestigateLeavesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvestigateLeavesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvestigateLeavesRequestMultiError, or nil if none found.
func (m *InvestigateLeavesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InvestigateLeavesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerIdentityPublicKey

	// no validation rules for TransferId

	if len(errors) > 0 {
		return InvestigateLeavesRequestMultiError(errors)
	}

	return nil
}

// InvestigateLeavesRequestMultiError is an error wrapping multiple validation
// errors returned by InvestigateLeavesRequest.ValidateAll() if the designated
// constraints aren't met.
type InvestigateLeavesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvestigateLeavesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvestigateLeavesRequestMultiError) AllErrors() []error { return m }

// InvestigateLeavesRequestValidationError is the validation error returned by
// InvestigateLeavesRequest.Validate if the designated constraints aren't met.
type InvestigateLeavesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvestigateLeavesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvestigateLeavesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvestigateLeavesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvestigateLeavesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvestigateLeavesRequestValidationError) ErrorName() string {
	return "InvestigateLeavesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InvestigateLeavesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvestigateLeavesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvestigateLeavesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvestigateLeavesRequestValidationError{}

// Validate checks the field values on QueryNodesDistributionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryNodesDistributionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryNodesDistributionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryNodesDistributionRequestMultiError, or nil if none found.
func (m *QueryNodesDistributionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryNodesDistributionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerIdentityPublicKey

	if len(errors) > 0 {
		return QueryNodesDistributionRequestMultiError(errors)
	}

	return nil
}

// QueryNodesDistributionRequestMultiError is an error wrapping multiple
// validation errors returned by QueryNodesDistributionRequest.ValidateAll()
// if the designated constraints aren't met.
type QueryNodesDistributionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryNodesDistributionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryNodesDistributionRequestMultiError) AllErrors() []error { return m }

// QueryNodesDistributionRequestValidationError is the validation error
// returned by QueryNodesDistributionRequest.Validate if the designated
// constraints aren't met.
type QueryNodesDistributionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryNodesDistributionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryNodesDistributionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryNodesDistributionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryNodesDistributionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryNodesDistributionRequestValidationError) ErrorName() string {
	return "QueryNodesDistributionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryNodesDistributionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryNodesDistributionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryNodesDistributionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryNodesDistributionRequestValidationError{}

// Validate checks the field values on QueryNodesDistributionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryNodesDistributionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryNodesDistributionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryNodesDistributionResponseMultiError, or nil if none found.
func (m *QueryNodesDistributionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryNodesDistributionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeDistribution

	if len(errors) > 0 {
		return QueryNodesDistributionResponseMultiError(errors)
	}

	return nil
}

// QueryNodesDistributionResponseMultiError is an error wrapping multiple
// validation errors returned by QueryNodesDistributionResponse.ValidateAll()
// if the designated constraints aren't met.
type QueryNodesDistributionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryNodesDistributionResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryNodesDistributionResponseMultiError) AllErrors() []error { return m }

// QueryNodesDistributionResponseValidationError is the validation error
// returned by QueryNodesDistributionResponse.Validate if the designated
// constraints aren't met.
type QueryNodesDistributionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryNodesDistributionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryNodesDistributionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryNodesDistributionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryNodesDistributionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryNodesDistributionResponseValidationError) ErrorName() string {
	return "QueryNodesDistributionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryNodesDistributionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryNodesDistributionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryNodesDistributionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryNodesDistributionResponseValidationError{}

// Validate checks the field values on QueryNodesByValueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryNodesByValueRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryNodesByValueRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryNodesByValueRequestMultiError, or nil if none found.
func (m *QueryNodesByValueRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryNodesByValueRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerIdentityPublicKey

	// no validation rules for Value

	// no validation rules for Offset

	// no validation rules for Limit

	if len(errors) > 0 {
		return QueryNodesByValueRequestMultiError(errors)
	}

	return nil
}

// QueryNodesByValueRequestMultiError is an error wrapping multiple validation
// errors returned by QueryNodesByValueRequest.ValidateAll() if the designated
// constraints aren't met.
type QueryNodesByValueRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryNodesByValueRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryNodesByValueRequestMultiError) AllErrors() []error { return m }

// QueryNodesByValueRequestValidationError is the validation error returned by
// QueryNodesByValueRequest.Validate if the designated constraints aren't met.
type QueryNodesByValueRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryNodesByValueRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryNodesByValueRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryNodesByValueRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryNodesByValueRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryNodesByValueRequestValidationError) ErrorName() string {
	return "QueryNodesByValueRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryNodesByValueRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryNodesByValueRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryNodesByValueRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryNodesByValueRequestValidationError{}

// Validate checks the field values on QueryNodesByValueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryNodesByValueResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryNodesByValueResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryNodesByValueResponseMultiError, or nil if none found.
func (m *QueryNodesByValueResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryNodesByValueResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetNodes()))
		i := 0
		for key := range m.GetNodes() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetNodes()[key]
			_ = val

			// no validation rules for Nodes[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, QueryNodesByValueResponseValidationError{
							field:  fmt.Sprintf("Nodes[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, QueryNodesByValueResponseValidationError{
							field:  fmt.Sprintf("Nodes[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return QueryNodesByValueResponseValidationError{
						field:  fmt.Sprintf("Nodes[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Offset

	if len(errors) > 0 {
		return QueryNodesByValueResponseMultiError(errors)
	}

	return nil
}

// QueryNodesByValueResponseMultiError is an error wrapping multiple validation
// errors returned by QueryNodesByValueResponse.ValidateAll() if the
// designated constraints aren't met.
type QueryNodesByValueResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryNodesByValueResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryNodesByValueResponseMultiError) AllErrors() []error { return m }

// QueryNodesByValueResponseValidationError is the validation error returned by
// QueryNodesByValueResponse.Validate if the designated constraints aren't met.
type QueryNodesByValueResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryNodesByValueResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryNodesByValueResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryNodesByValueResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryNodesByValueResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryNodesByValueResponseValidationError) ErrorName() string {
	return "QueryNodesByValueResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryNodesByValueResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryNodesByValueResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryNodesByValueResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryNodesByValueResponseValidationError{}

// Validate checks the field values on GetUtxosForAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUtxosForAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUtxosForAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUtxosForAddressRequestMultiError, or nil if none found.
func (m *GetUtxosForAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUtxosForAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for Offset

	// no validation rules for Limit

	// no validation rules for Network

	// no validation rules for ExcludeClaimed

	if len(errors) > 0 {
		return GetUtxosForAddressRequestMultiError(errors)
	}

	return nil
}

// GetUtxosForAddressRequestMultiError is an error wrapping multiple validation
// errors returned by GetUtxosForAddressRequest.ValidateAll() if the
// designated constraints aren't met.
type GetUtxosForAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUtxosForAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUtxosForAddressRequestMultiError) AllErrors() []error { return m }

// GetUtxosForAddressRequestValidationError is the validation error returned by
// GetUtxosForAddressRequest.Validate if the designated constraints aren't met.
type GetUtxosForAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUtxosForAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUtxosForAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUtxosForAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUtxosForAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUtxosForAddressRequestValidationError) ErrorName() string {
	return "GetUtxosForAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUtxosForAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUtxosForAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUtxosForAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUtxosForAddressRequestValidationError{}

// Validate checks the field values on GetUtxosForAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUtxosForAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUtxosForAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUtxosForAddressResponseMultiError, or nil if none found.
func (m *GetUtxosForAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUtxosForAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUtxos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUtxosForAddressResponseValidationError{
						field:  fmt.Sprintf("Utxos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUtxosForAddressResponseValidationError{
						field:  fmt.Sprintf("Utxos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUtxosForAddressResponseValidationError{
					field:  fmt.Sprintf("Utxos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Offset

	if len(errors) > 0 {
		return GetUtxosForAddressResponseMultiError(errors)
	}

	return nil
}

// GetUtxosForAddressResponseMultiError is an error wrapping multiple
// validation errors returned by GetUtxosForAddressResponse.ValidateAll() if
// the designated constraints aren't met.
type GetUtxosForAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUtxosForAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUtxosForAddressResponseMultiError) AllErrors() []error { return m }

// GetUtxosForAddressResponseValidationError is the validation error returned
// by GetUtxosForAddressResponse.Validate if the designated constraints aren't met.
type GetUtxosForAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUtxosForAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUtxosForAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUtxosForAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUtxosForAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUtxosForAddressResponseValidationError) ErrorName() string {
	return "GetUtxosForAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUtxosForAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUtxosForAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUtxosForAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUtxosForAddressResponseValidationError{}

// Validate checks the field values on QuerySparkInvoicesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QuerySparkInvoicesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QuerySparkInvoicesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QuerySparkInvoicesRequestMultiError, or nil if none found.
func (m *QuerySparkInvoicesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QuerySparkInvoicesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for Offset

	if len(errors) > 0 {
		return QuerySparkInvoicesRequestMultiError(errors)
	}

	return nil
}

// QuerySparkInvoicesRequestMultiError is an error wrapping multiple validation
// errors returned by QuerySparkInvoicesRequest.ValidateAll() if the
// designated constraints aren't met.
type QuerySparkInvoicesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuerySparkInvoicesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuerySparkInvoicesRequestMultiError) AllErrors() []error { return m }

// QuerySparkInvoicesRequestValidationError is the validation error returned by
// QuerySparkInvoicesRequest.Validate if the designated constraints aren't met.
type QuerySparkInvoicesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuerySparkInvoicesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuerySparkInvoicesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuerySparkInvoicesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuerySparkInvoicesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuerySparkInvoicesRequestValidationError) ErrorName() string {
	return "QuerySparkInvoicesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QuerySparkInvoicesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuerySparkInvoicesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuerySparkInvoicesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuerySparkInvoicesRequestValidationError{}

// Validate checks the field values on QuerySparkInvoicesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QuerySparkInvoicesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QuerySparkInvoicesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QuerySparkInvoicesResponseMultiError, or nil if none found.
func (m *QuerySparkInvoicesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QuerySparkInvoicesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Offset

	for idx, item := range m.GetInvoiceStatuses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QuerySparkInvoicesResponseValidationError{
						field:  fmt.Sprintf("InvoiceStatuses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QuerySparkInvoicesResponseValidationError{
						field:  fmt.Sprintf("InvoiceStatuses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QuerySparkInvoicesResponseValidationError{
					field:  fmt.Sprintf("InvoiceStatuses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QuerySparkInvoicesResponseMultiError(errors)
	}

	return nil
}

// QuerySparkInvoicesResponseMultiError is an error wrapping multiple
// validation errors returned by QuerySparkInvoicesResponse.ValidateAll() if
// the designated constraints aren't met.
type QuerySparkInvoicesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuerySparkInvoicesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuerySparkInvoicesResponseMultiError) AllErrors() []error { return m }

// QuerySparkInvoicesResponseValidationError is the validation error returned
// by QuerySparkInvoicesResponse.Validate if the designated constraints aren't met.
type QuerySparkInvoicesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuerySparkInvoicesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuerySparkInvoicesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuerySparkInvoicesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuerySparkInvoicesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuerySparkInvoicesResponseValidationError) ErrorName() string {
	return "QuerySparkInvoicesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QuerySparkInvoicesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuerySparkInvoicesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuerySparkInvoicesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuerySparkInvoicesResponseValidationError{}

// Validate checks the field values on InvoiceResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InvoiceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvoiceResponseMultiError, or nil if none found.
func (m *InvoiceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Invoice

	// no validation rules for Status

	if len(errors) > 0 {
		return InvoiceResponseMultiError(errors)
	}

	return nil
}

// InvoiceResponseMultiError is an error wrapping multiple validation errors
// returned by InvoiceResponse.ValidateAll() if the designated constraints
// aren't met.
type InvoiceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceResponseMultiError) AllErrors() []error { return m }

// InvoiceResponseValidationError is the validation error returned by
// InvoiceResponse.Validate if the designated constraints aren't met.
type InvoiceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceResponseValidationError) ErrorName() string { return "InvoiceResponseValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceResponseValidationError{}
