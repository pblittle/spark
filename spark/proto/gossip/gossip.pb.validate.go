// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: gossip.proto

package gossip

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	spark "github.com/lightsparkdev/spark/proto/spark"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = spark.Network(0)
)

// Validate checks the field values on GossipMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GossipMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GossipMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GossipMessageMultiError, or
// nil if none found.
func (m *GossipMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *GossipMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MessageId

	switch v := m.Message.(type) {
	case *GossipMessage_CancelTransfer:
		if v == nil {
			err := GossipMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCancelTransfer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "CancelTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "CancelTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCancelTransfer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageValidationError{
					field:  "CancelTransfer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GossipMessage_SettleSenderKeyTweak:
		if v == nil {
			err := GossipMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSettleSenderKeyTweak()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "SettleSenderKeyTweak",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "SettleSenderKeyTweak",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSettleSenderKeyTweak()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageValidationError{
					field:  "SettleSenderKeyTweak",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GossipMessage_RollbackTransfer:
		if v == nil {
			err := GossipMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRollbackTransfer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "RollbackTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "RollbackTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRollbackTransfer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageValidationError{
					field:  "RollbackTransfer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GossipMessage_MarkTreesExited:
		if v == nil {
			err := GossipMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMarkTreesExited()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "MarkTreesExited",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "MarkTreesExited",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMarkTreesExited()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageValidationError{
					field:  "MarkTreesExited",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GossipMessage_FinalizeTreeCreation:
		if v == nil {
			err := GossipMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFinalizeTreeCreation()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "FinalizeTreeCreation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "FinalizeTreeCreation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFinalizeTreeCreation()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageValidationError{
					field:  "FinalizeTreeCreation",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GossipMessage_FinalizeTransfer:
		if v == nil {
			err := GossipMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFinalizeTransfer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "FinalizeTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "FinalizeTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFinalizeTransfer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageValidationError{
					field:  "FinalizeTransfer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GossipMessage_FinalizeRefreshTimelock:
		if v == nil {
			err := GossipMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFinalizeRefreshTimelock()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "FinalizeRefreshTimelock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "FinalizeRefreshTimelock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFinalizeRefreshTimelock()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageValidationError{
					field:  "FinalizeRefreshTimelock",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GossipMessage_FinalizeExtendLeaf:
		if v == nil {
			err := GossipMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFinalizeExtendLeaf()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "FinalizeExtendLeaf",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "FinalizeExtendLeaf",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFinalizeExtendLeaf()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageValidationError{
					field:  "FinalizeExtendLeaf",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GossipMessage_RollbackUtxoSwap:
		if v == nil {
			err := GossipMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRollbackUtxoSwap()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "RollbackUtxoSwap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "RollbackUtxoSwap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRollbackUtxoSwap()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageValidationError{
					field:  "RollbackUtxoSwap",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GossipMessage_DepositCleanup:
		if v == nil {
			err := GossipMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDepositCleanup()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "DepositCleanup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "DepositCleanup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDepositCleanup()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageValidationError{
					field:  "DepositCleanup",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GossipMessage_Preimage:
		if v == nil {
			err := GossipMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPreimage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "Preimage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "Preimage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPreimage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageValidationError{
					field:  "Preimage",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GossipMessage_FinalizeRefundTimelock:
		if v == nil {
			err := GossipMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFinalizeRefundTimelock()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "FinalizeRefundTimelock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "FinalizeRefundTimelock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFinalizeRefundTimelock()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageValidationError{
					field:  "FinalizeRefundTimelock",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GossipMessage_FinalizeNodeTimelock:
		if v == nil {
			err := GossipMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFinalizeNodeTimelock()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "FinalizeNodeTimelock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageValidationError{
						field:  "FinalizeNodeTimelock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFinalizeNodeTimelock()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageValidationError{
					field:  "FinalizeNodeTimelock",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return GossipMessageMultiError(errors)
	}

	return nil
}

// GossipMessageMultiError is an error wrapping multiple validation errors
// returned by GossipMessage.ValidateAll() if the designated constraints
// aren't met.
type GossipMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GossipMessageMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GossipMessageMultiError) AllErrors() []error { return m }

// GossipMessageValidationError is the validation error returned by
// GossipMessage.Validate if the designated constraints aren't met.
type GossipMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GossipMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GossipMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GossipMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GossipMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GossipMessageValidationError) ErrorName() string { return "GossipMessageValidationError" }

// Error satisfies the builtin error interface
func (e GossipMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGossipMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GossipMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GossipMessageValidationError{}

// Validate checks the field values on GossipMessageCancelTransfer with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GossipMessageCancelTransfer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GossipMessageCancelTransfer with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GossipMessageCancelTransferMultiError, or nil if none found.
func (m *GossipMessageCancelTransfer) ValidateAll() error {
	return m.validate(true)
}

func (m *GossipMessageCancelTransfer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	if len(errors) > 0 {
		return GossipMessageCancelTransferMultiError(errors)
	}

	return nil
}

// GossipMessageCancelTransferMultiError is an error wrapping multiple
// validation errors returned by GossipMessageCancelTransfer.ValidateAll() if
// the designated constraints aren't met.
type GossipMessageCancelTransferMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GossipMessageCancelTransferMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GossipMessageCancelTransferMultiError) AllErrors() []error { return m }

// GossipMessageCancelTransferValidationError is the validation error returned
// by GossipMessageCancelTransfer.Validate if the designated constraints
// aren't met.
type GossipMessageCancelTransferValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GossipMessageCancelTransferValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GossipMessageCancelTransferValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GossipMessageCancelTransferValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GossipMessageCancelTransferValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GossipMessageCancelTransferValidationError) ErrorName() string {
	return "GossipMessageCancelTransferValidationError"
}

// Error satisfies the builtin error interface
func (e GossipMessageCancelTransferValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGossipMessageCancelTransfer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GossipMessageCancelTransferValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GossipMessageCancelTransferValidationError{}

// Validate checks the field values on GossipMessageRollbackTransfer with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GossipMessageRollbackTransfer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GossipMessageRollbackTransfer with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GossipMessageRollbackTransferMultiError, or nil if none found.
func (m *GossipMessageRollbackTransfer) ValidateAll() error {
	return m.validate(true)
}

func (m *GossipMessageRollbackTransfer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	if len(errors) > 0 {
		return GossipMessageRollbackTransferMultiError(errors)
	}

	return nil
}

// GossipMessageRollbackTransferMultiError is an error wrapping multiple
// validation errors returned by GossipMessageRollbackTransfer.ValidateAll()
// if the designated constraints aren't met.
type GossipMessageRollbackTransferMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GossipMessageRollbackTransferMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GossipMessageRollbackTransferMultiError) AllErrors() []error { return m }

// GossipMessageRollbackTransferValidationError is the validation error
// returned by GossipMessageRollbackTransfer.Validate if the designated
// constraints aren't met.
type GossipMessageRollbackTransferValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GossipMessageRollbackTransferValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GossipMessageRollbackTransferValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GossipMessageRollbackTransferValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GossipMessageRollbackTransferValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GossipMessageRollbackTransferValidationError) ErrorName() string {
	return "GossipMessageRollbackTransferValidationError"
}

// Error satisfies the builtin error interface
func (e GossipMessageRollbackTransferValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGossipMessageRollbackTransfer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GossipMessageRollbackTransferValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GossipMessageRollbackTransferValidationError{}

// Validate checks the field values on GossipMessageSettleSenderKeyTweak with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GossipMessageSettleSenderKeyTweak) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GossipMessageSettleSenderKeyTweak
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GossipMessageSettleSenderKeyTweakMultiError, or nil if none found.
func (m *GossipMessageSettleSenderKeyTweak) ValidateAll() error {
	return m.validate(true)
}

func (m *GossipMessageSettleSenderKeyTweak) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	{
		sorted_keys := make([]string, len(m.GetSenderKeyTweakProofs()))
		i := 0
		for key := range m.GetSenderKeyTweakProofs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSenderKeyTweakProofs()[key]
			_ = val

			// no validation rules for SenderKeyTweakProofs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GossipMessageSettleSenderKeyTweakValidationError{
							field:  fmt.Sprintf("SenderKeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GossipMessageSettleSenderKeyTweakValidationError{
							field:  fmt.Sprintf("SenderKeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GossipMessageSettleSenderKeyTweakValidationError{
						field:  fmt.Sprintf("SenderKeyTweakProofs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return GossipMessageSettleSenderKeyTweakMultiError(errors)
	}

	return nil
}

// GossipMessageSettleSenderKeyTweakMultiError is an error wrapping multiple
// validation errors returned by
// GossipMessageSettleSenderKeyTweak.ValidateAll() if the designated
// constraints aren't met.
type GossipMessageSettleSenderKeyTweakMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GossipMessageSettleSenderKeyTweakMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GossipMessageSettleSenderKeyTweakMultiError) AllErrors() []error { return m }

// GossipMessageSettleSenderKeyTweakValidationError is the validation error
// returned by GossipMessageSettleSenderKeyTweak.Validate if the designated
// constraints aren't met.
type GossipMessageSettleSenderKeyTweakValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GossipMessageSettleSenderKeyTweakValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GossipMessageSettleSenderKeyTweakValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GossipMessageSettleSenderKeyTweakValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GossipMessageSettleSenderKeyTweakValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GossipMessageSettleSenderKeyTweakValidationError) ErrorName() string {
	return "GossipMessageSettleSenderKeyTweakValidationError"
}

// Error satisfies the builtin error interface
func (e GossipMessageSettleSenderKeyTweakValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGossipMessageSettleSenderKeyTweak.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GossipMessageSettleSenderKeyTweakValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GossipMessageSettleSenderKeyTweakValidationError{}

// Validate checks the field values on GossipMessageMarkTreesExited with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GossipMessageMarkTreesExited) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GossipMessageMarkTreesExited with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GossipMessageMarkTreesExitedMultiError, or nil if none found.
func (m *GossipMessageMarkTreesExited) ValidateAll() error {
	return m.validate(true)
}

func (m *GossipMessageMarkTreesExited) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GossipMessageMarkTreesExitedMultiError(errors)
	}

	return nil
}

// GossipMessageMarkTreesExitedMultiError is an error wrapping multiple
// validation errors returned by GossipMessageMarkTreesExited.ValidateAll() if
// the designated constraints aren't met.
type GossipMessageMarkTreesExitedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GossipMessageMarkTreesExitedMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GossipMessageMarkTreesExitedMultiError) AllErrors() []error { return m }

// GossipMessageMarkTreesExitedValidationError is the validation error returned
// by GossipMessageMarkTreesExited.Validate if the designated constraints
// aren't met.
type GossipMessageMarkTreesExitedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GossipMessageMarkTreesExitedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GossipMessageMarkTreesExitedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GossipMessageMarkTreesExitedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GossipMessageMarkTreesExitedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GossipMessageMarkTreesExitedValidationError) ErrorName() string {
	return "GossipMessageMarkTreesExitedValidationError"
}

// Error satisfies the builtin error interface
func (e GossipMessageMarkTreesExitedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGossipMessageMarkTreesExited.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GossipMessageMarkTreesExitedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GossipMessageMarkTreesExitedValidationError{}

// Validate checks the field values on GossipMessageFinalizeTreeCreation with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GossipMessageFinalizeTreeCreation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GossipMessageFinalizeTreeCreation
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GossipMessageFinalizeTreeCreationMultiError, or nil if none found.
func (m *GossipMessageFinalizeTreeCreation) ValidateAll() error {
	return m.validate(true)
}

func (m *GossipMessageFinalizeTreeCreation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInternalNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageFinalizeTreeCreationValidationError{
						field:  fmt.Sprintf("InternalNodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageFinalizeTreeCreationValidationError{
						field:  fmt.Sprintf("InternalNodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageFinalizeTreeCreationValidationError{
					field:  fmt.Sprintf("InternalNodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ProtoNetwork

	if len(errors) > 0 {
		return GossipMessageFinalizeTreeCreationMultiError(errors)
	}

	return nil
}

// GossipMessageFinalizeTreeCreationMultiError is an error wrapping multiple
// validation errors returned by
// GossipMessageFinalizeTreeCreation.ValidateAll() if the designated
// constraints aren't met.
type GossipMessageFinalizeTreeCreationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GossipMessageFinalizeTreeCreationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GossipMessageFinalizeTreeCreationMultiError) AllErrors() []error { return m }

// GossipMessageFinalizeTreeCreationValidationError is the validation error
// returned by GossipMessageFinalizeTreeCreation.Validate if the designated
// constraints aren't met.
type GossipMessageFinalizeTreeCreationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GossipMessageFinalizeTreeCreationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GossipMessageFinalizeTreeCreationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GossipMessageFinalizeTreeCreationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GossipMessageFinalizeTreeCreationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GossipMessageFinalizeTreeCreationValidationError) ErrorName() string {
	return "GossipMessageFinalizeTreeCreationValidationError"
}

// Error satisfies the builtin error interface
func (e GossipMessageFinalizeTreeCreationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGossipMessageFinalizeTreeCreation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GossipMessageFinalizeTreeCreationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GossipMessageFinalizeTreeCreationValidationError{}

// Validate checks the field values on GossipMessageFinalizeTransfer with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GossipMessageFinalizeTransfer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GossipMessageFinalizeTransfer with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GossipMessageFinalizeTransferMultiError, or nil if none found.
func (m *GossipMessageFinalizeTransfer) ValidateAll() error {
	return m.validate(true)
}

func (m *GossipMessageFinalizeTransfer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	for idx, item := range m.GetInternalNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageFinalizeTransferValidationError{
						field:  fmt.Sprintf("InternalNodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageFinalizeTransferValidationError{
						field:  fmt.Sprintf("InternalNodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageFinalizeTransferValidationError{
					field:  fmt.Sprintf("InternalNodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCompletionTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GossipMessageFinalizeTransferValidationError{
					field:  "CompletionTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GossipMessageFinalizeTransferValidationError{
					field:  "CompletionTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompletionTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GossipMessageFinalizeTransferValidationError{
				field:  "CompletionTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GossipMessageFinalizeTransferMultiError(errors)
	}

	return nil
}

// GossipMessageFinalizeTransferMultiError is an error wrapping multiple
// validation errors returned by GossipMessageFinalizeTransfer.ValidateAll()
// if the designated constraints aren't met.
type GossipMessageFinalizeTransferMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GossipMessageFinalizeTransferMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GossipMessageFinalizeTransferMultiError) AllErrors() []error { return m }

// GossipMessageFinalizeTransferValidationError is the validation error
// returned by GossipMessageFinalizeTransfer.Validate if the designated
// constraints aren't met.
type GossipMessageFinalizeTransferValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GossipMessageFinalizeTransferValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GossipMessageFinalizeTransferValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GossipMessageFinalizeTransferValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GossipMessageFinalizeTransferValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GossipMessageFinalizeTransferValidationError) ErrorName() string {
	return "GossipMessageFinalizeTransferValidationError"
}

// Error satisfies the builtin error interface
func (e GossipMessageFinalizeTransferValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGossipMessageFinalizeTransfer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GossipMessageFinalizeTransferValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GossipMessageFinalizeTransferValidationError{}

// Validate checks the field values on GossipMessageFinalizeRefreshTimelock
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GossipMessageFinalizeRefreshTimelock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GossipMessageFinalizeRefreshTimelock
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GossipMessageFinalizeRefreshTimelockMultiError, or nil if none found.
func (m *GossipMessageFinalizeRefreshTimelock) ValidateAll() error {
	return m.validate(true)
}

func (m *GossipMessageFinalizeRefreshTimelock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInternalNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageFinalizeRefreshTimelockValidationError{
						field:  fmt.Sprintf("InternalNodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageFinalizeRefreshTimelockValidationError{
						field:  fmt.Sprintf("InternalNodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageFinalizeRefreshTimelockValidationError{
					field:  fmt.Sprintf("InternalNodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GossipMessageFinalizeRefreshTimelockMultiError(errors)
	}

	return nil
}

// GossipMessageFinalizeRefreshTimelockMultiError is an error wrapping multiple
// validation errors returned by
// GossipMessageFinalizeRefreshTimelock.ValidateAll() if the designated
// constraints aren't met.
type GossipMessageFinalizeRefreshTimelockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GossipMessageFinalizeRefreshTimelockMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GossipMessageFinalizeRefreshTimelockMultiError) AllErrors() []error { return m }

// GossipMessageFinalizeRefreshTimelockValidationError is the validation error
// returned by GossipMessageFinalizeRefreshTimelock.Validate if the designated
// constraints aren't met.
type GossipMessageFinalizeRefreshTimelockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GossipMessageFinalizeRefreshTimelockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GossipMessageFinalizeRefreshTimelockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GossipMessageFinalizeRefreshTimelockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GossipMessageFinalizeRefreshTimelockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GossipMessageFinalizeRefreshTimelockValidationError) ErrorName() string {
	return "GossipMessageFinalizeRefreshTimelockValidationError"
}

// Error satisfies the builtin error interface
func (e GossipMessageFinalizeRefreshTimelockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGossipMessageFinalizeRefreshTimelock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GossipMessageFinalizeRefreshTimelockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GossipMessageFinalizeRefreshTimelockValidationError{}

// Validate checks the field values on GossipMessageFinalizeExtendLeaf with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GossipMessageFinalizeExtendLeaf) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GossipMessageFinalizeExtendLeaf with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GossipMessageFinalizeExtendLeafMultiError, or nil if none found.
func (m *GossipMessageFinalizeExtendLeaf) ValidateAll() error {
	return m.validate(true)
}

func (m *GossipMessageFinalizeExtendLeaf) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInternalNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GossipMessageFinalizeExtendLeafValidationError{
						field:  fmt.Sprintf("InternalNodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GossipMessageFinalizeExtendLeafValidationError{
						field:  fmt.Sprintf("InternalNodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GossipMessageFinalizeExtendLeafValidationError{
					field:  fmt.Sprintf("InternalNodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GossipMessageFinalizeExtendLeafMultiError(errors)
	}

	return nil
}

// GossipMessageFinalizeExtendLeafMultiError is an error wrapping multiple
// validation errors returned by GossipMessageFinalizeExtendLeaf.ValidateAll()
// if the designated constraints aren't met.
type GossipMessageFinalizeExtendLeafMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GossipMessageFinalizeExtendLeafMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GossipMessageFinalizeExtendLeafMultiError) AllErrors() []error { return m }

// GossipMessageFinalizeExtendLeafValidationError is the validation error
// returned by GossipMessageFinalizeExtendLeaf.Validate if the designated
// constraints aren't met.
type GossipMessageFinalizeExtendLeafValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GossipMessageFinalizeExtendLeafValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GossipMessageFinalizeExtendLeafValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GossipMessageFinalizeExtendLeafValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GossipMessageFinalizeExtendLeafValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GossipMessageFinalizeExtendLeafValidationError) ErrorName() string {
	return "GossipMessageFinalizeExtendLeafValidationError"
}

// Error satisfies the builtin error interface
func (e GossipMessageFinalizeExtendLeafValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGossipMessageFinalizeExtendLeaf.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GossipMessageFinalizeExtendLeafValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GossipMessageFinalizeExtendLeafValidationError{}

// Validate checks the field values on GossipMessageFinalizeRenewRefundTimelock
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GossipMessageFinalizeRenewRefundTimelock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GossipMessageFinalizeRenewRefundTimelock with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GossipMessageFinalizeRenewRefundTimelockMultiError, or nil if none found.
func (m *GossipMessageFinalizeRenewRefundTimelock) ValidateAll() error {
	return m.validate(true)
}

func (m *GossipMessageFinalizeRenewRefundTimelock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GossipMessageFinalizeRenewRefundTimelockValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GossipMessageFinalizeRenewRefundTimelockValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GossipMessageFinalizeRenewRefundTimelockValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GossipMessageFinalizeRenewRefundTimelockMultiError(errors)
	}

	return nil
}

// GossipMessageFinalizeRenewRefundTimelockMultiError is an error wrapping
// multiple validation errors returned by
// GossipMessageFinalizeRenewRefundTimelock.ValidateAll() if the designated
// constraints aren't met.
type GossipMessageFinalizeRenewRefundTimelockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GossipMessageFinalizeRenewRefundTimelockMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GossipMessageFinalizeRenewRefundTimelockMultiError) AllErrors() []error { return m }

// GossipMessageFinalizeRenewRefundTimelockValidationError is the validation
// error returned by GossipMessageFinalizeRenewRefundTimelock.Validate if the
// designated constraints aren't met.
type GossipMessageFinalizeRenewRefundTimelockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GossipMessageFinalizeRenewRefundTimelockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GossipMessageFinalizeRenewRefundTimelockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GossipMessageFinalizeRenewRefundTimelockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GossipMessageFinalizeRenewRefundTimelockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GossipMessageFinalizeRenewRefundTimelockValidationError) ErrorName() string {
	return "GossipMessageFinalizeRenewRefundTimelockValidationError"
}

// Error satisfies the builtin error interface
func (e GossipMessageFinalizeRenewRefundTimelockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGossipMessageFinalizeRenewRefundTimelock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GossipMessageFinalizeRenewRefundTimelockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GossipMessageFinalizeRenewRefundTimelockValidationError{}

// Validate checks the field values on GossipMessageFinalizeRenewNodeTimelock
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GossipMessageFinalizeRenewNodeTimelock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GossipMessageFinalizeRenewNodeTimelock with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// GossipMessageFinalizeRenewNodeTimelockMultiError, or nil if none found.
func (m *GossipMessageFinalizeRenewNodeTimelock) ValidateAll() error {
	return m.validate(true)
}

func (m *GossipMessageFinalizeRenewNodeTimelock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSplitNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GossipMessageFinalizeRenewNodeTimelockValidationError{
					field:  "SplitNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GossipMessageFinalizeRenewNodeTimelockValidationError{
					field:  "SplitNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSplitNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GossipMessageFinalizeRenewNodeTimelockValidationError{
				field:  "SplitNode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GossipMessageFinalizeRenewNodeTimelockValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GossipMessageFinalizeRenewNodeTimelockValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GossipMessageFinalizeRenewNodeTimelockValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GossipMessageFinalizeRenewNodeTimelockMultiError(errors)
	}

	return nil
}

// GossipMessageFinalizeRenewNodeTimelockMultiError is an error wrapping
// multiple validation errors returned by
// GossipMessageFinalizeRenewNodeTimelock.ValidateAll() if the designated
// constraints aren't met.
type GossipMessageFinalizeRenewNodeTimelockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GossipMessageFinalizeRenewNodeTimelockMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GossipMessageFinalizeRenewNodeTimelockMultiError) AllErrors() []error { return m }

// GossipMessageFinalizeRenewNodeTimelockValidationError is the validation
// error returned by GossipMessageFinalizeRenewNodeTimelock.Validate if the
// designated constraints aren't met.
type GossipMessageFinalizeRenewNodeTimelockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GossipMessageFinalizeRenewNodeTimelockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GossipMessageFinalizeRenewNodeTimelockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GossipMessageFinalizeRenewNodeTimelockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GossipMessageFinalizeRenewNodeTimelockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GossipMessageFinalizeRenewNodeTimelockValidationError) ErrorName() string {
	return "GossipMessageFinalizeRenewNodeTimelockValidationError"
}

// Error satisfies the builtin error interface
func (e GossipMessageFinalizeRenewNodeTimelockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGossipMessageFinalizeRenewNodeTimelock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GossipMessageFinalizeRenewNodeTimelockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GossipMessageFinalizeRenewNodeTimelockValidationError{}

// Validate checks the field values on GossipMessageRollbackUtxoSwap with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GossipMessageRollbackUtxoSwap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GossipMessageRollbackUtxoSwap with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GossipMessageRollbackUtxoSwapMultiError, or nil if none found.
func (m *GossipMessageRollbackUtxoSwap) ValidateAll() error {
	return m.validate(true)
}

func (m *GossipMessageRollbackUtxoSwap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOnChainUtxo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GossipMessageRollbackUtxoSwapValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GossipMessageRollbackUtxoSwapValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOnChainUtxo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GossipMessageRollbackUtxoSwapValidationError{
				field:  "OnChainUtxo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Signature

	// no validation rules for CoordinatorPublicKey

	if len(errors) > 0 {
		return GossipMessageRollbackUtxoSwapMultiError(errors)
	}

	return nil
}

// GossipMessageRollbackUtxoSwapMultiError is an error wrapping multiple
// validation errors returned by GossipMessageRollbackUtxoSwap.ValidateAll()
// if the designated constraints aren't met.
type GossipMessageRollbackUtxoSwapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GossipMessageRollbackUtxoSwapMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GossipMessageRollbackUtxoSwapMultiError) AllErrors() []error { return m }

// GossipMessageRollbackUtxoSwapValidationError is the validation error
// returned by GossipMessageRollbackUtxoSwap.Validate if the designated
// constraints aren't met.
type GossipMessageRollbackUtxoSwapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GossipMessageRollbackUtxoSwapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GossipMessageRollbackUtxoSwapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GossipMessageRollbackUtxoSwapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GossipMessageRollbackUtxoSwapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GossipMessageRollbackUtxoSwapValidationError) ErrorName() string {
	return "GossipMessageRollbackUtxoSwapValidationError"
}

// Error satisfies the builtin error interface
func (e GossipMessageRollbackUtxoSwapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGossipMessageRollbackUtxoSwap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GossipMessageRollbackUtxoSwapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GossipMessageRollbackUtxoSwapValidationError{}

// Validate checks the field values on GossipMessageDepositCleanup with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GossipMessageDepositCleanup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GossipMessageDepositCleanup with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GossipMessageDepositCleanupMultiError, or nil if none found.
func (m *GossipMessageDepositCleanup) ValidateAll() error {
	return m.validate(true)
}

func (m *GossipMessageDepositCleanup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TreeId

	if len(errors) > 0 {
		return GossipMessageDepositCleanupMultiError(errors)
	}

	return nil
}

// GossipMessageDepositCleanupMultiError is an error wrapping multiple
// validation errors returned by GossipMessageDepositCleanup.ValidateAll() if
// the designated constraints aren't met.
type GossipMessageDepositCleanupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GossipMessageDepositCleanupMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GossipMessageDepositCleanupMultiError) AllErrors() []error { return m }

// GossipMessageDepositCleanupValidationError is the validation error returned
// by GossipMessageDepositCleanup.Validate if the designated constraints
// aren't met.
type GossipMessageDepositCleanupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GossipMessageDepositCleanupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GossipMessageDepositCleanupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GossipMessageDepositCleanupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GossipMessageDepositCleanupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GossipMessageDepositCleanupValidationError) ErrorName() string {
	return "GossipMessageDepositCleanupValidationError"
}

// Error satisfies the builtin error interface
func (e GossipMessageDepositCleanupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGossipMessageDepositCleanup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GossipMessageDepositCleanupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GossipMessageDepositCleanupValidationError{}

// Validate checks the field values on GossipMessagePreimage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GossipMessagePreimage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GossipMessagePreimage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GossipMessagePreimageMultiError, or nil if none found.
func (m *GossipMessagePreimage) ValidateAll() error {
	return m.validate(true)
}

func (m *GossipMessagePreimage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Preimage

	// no validation rules for PaymentHash

	if len(errors) > 0 {
		return GossipMessagePreimageMultiError(errors)
	}

	return nil
}

// GossipMessagePreimageMultiError is an error wrapping multiple validation
// errors returned by GossipMessagePreimage.ValidateAll() if the designated
// constraints aren't met.
type GossipMessagePreimageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GossipMessagePreimageMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GossipMessagePreimageMultiError) AllErrors() []error { return m }

// GossipMessagePreimageValidationError is the validation error returned by
// GossipMessagePreimage.Validate if the designated constraints aren't met.
type GossipMessagePreimageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GossipMessagePreimageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GossipMessagePreimageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GossipMessagePreimageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GossipMessagePreimageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GossipMessagePreimageValidationError) ErrorName() string {
	return "GossipMessagePreimageValidationError"
}

// Error satisfies the builtin error interface
func (e GossipMessagePreimageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGossipMessagePreimage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GossipMessagePreimageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GossipMessagePreimageValidationError{}
