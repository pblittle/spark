// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: spark_token.proto

package spark_token

import (
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	spark "github.com/lightsparkdev/spark/proto/spark"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TokenTransactionType int32

const (
	TokenTransactionType_TOKEN_TRANSACTION_TYPE_UNSPECIFIED TokenTransactionType = 0
	TokenTransactionType_TOKEN_TRANSACTION_TYPE_CREATE      TokenTransactionType = 1
	TokenTransactionType_TOKEN_TRANSACTION_TYPE_MINT        TokenTransactionType = 2
	TokenTransactionType_TOKEN_TRANSACTION_TYPE_TRANSFER    TokenTransactionType = 3
)

// Enum value maps for TokenTransactionType.
var (
	TokenTransactionType_name = map[int32]string{
		0: "TOKEN_TRANSACTION_TYPE_UNSPECIFIED",
		1: "TOKEN_TRANSACTION_TYPE_CREATE",
		2: "TOKEN_TRANSACTION_TYPE_MINT",
		3: "TOKEN_TRANSACTION_TYPE_TRANSFER",
	}
	TokenTransactionType_value = map[string]int32{
		"TOKEN_TRANSACTION_TYPE_UNSPECIFIED": 0,
		"TOKEN_TRANSACTION_TYPE_CREATE":      1,
		"TOKEN_TRANSACTION_TYPE_MINT":        2,
		"TOKEN_TRANSACTION_TYPE_TRANSFER":    3,
	}
)

func (x TokenTransactionType) Enum() *TokenTransactionType {
	p := new(TokenTransactionType)
	*p = x
	return p
}

func (x TokenTransactionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TokenTransactionType) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_token_proto_enumTypes[0].Descriptor()
}

func (TokenTransactionType) Type() protoreflect.EnumType {
	return &file_spark_token_proto_enumTypes[0]
}

func (x TokenTransactionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TokenTransactionType.Descriptor instead.
func (TokenTransactionType) EnumDescriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{0}
}

type CommitStatus int32

const (
	CommitStatus_COMMIT_UNSPECIFIED CommitStatus = 0
	CommitStatus_COMMIT_PROCESSING  CommitStatus = 1
	CommitStatus_COMMIT_FINALIZED   CommitStatus = 2
)

// Enum value maps for CommitStatus.
var (
	CommitStatus_name = map[int32]string{
		0: "COMMIT_UNSPECIFIED",
		1: "COMMIT_PROCESSING",
		2: "COMMIT_FINALIZED",
	}
	CommitStatus_value = map[string]int32{
		"COMMIT_UNSPECIFIED": 0,
		"COMMIT_PROCESSING":  1,
		"COMMIT_FINALIZED":   2,
	}
)

func (x CommitStatus) Enum() *CommitStatus {
	p := new(CommitStatus)
	*p = x
	return p
}

func (x CommitStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CommitStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_token_proto_enumTypes[1].Descriptor()
}

func (CommitStatus) Type() protoreflect.EnumType {
	return &file_spark_token_proto_enumTypes[1]
}

func (x CommitStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CommitStatus.Descriptor instead.
func (CommitStatus) EnumDescriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{1}
}

type TokenTransactionStatus int32

const (
	TokenTransactionStatus_TOKEN_TRANSACTION_STARTED           TokenTransactionStatus = 0
	TokenTransactionStatus_TOKEN_TRANSACTION_SIGNED            TokenTransactionStatus = 1
	TokenTransactionStatus_TOKEN_TRANSACTION_REVEALED          TokenTransactionStatus = 5
	TokenTransactionStatus_TOKEN_TRANSACTION_FINALIZED         TokenTransactionStatus = 2
	TokenTransactionStatus_TOKEN_TRANSACTION_STARTED_CANCELLED TokenTransactionStatus = 3
	TokenTransactionStatus_TOKEN_TRANSACTION_SIGNED_CANCELLED  TokenTransactionStatus = 4
	TokenTransactionStatus_TOKEN_TRANSACTION_UNKNOWN           TokenTransactionStatus = 10
)

// Enum value maps for TokenTransactionStatus.
var (
	TokenTransactionStatus_name = map[int32]string{
		0:  "TOKEN_TRANSACTION_STARTED",
		1:  "TOKEN_TRANSACTION_SIGNED",
		5:  "TOKEN_TRANSACTION_REVEALED",
		2:  "TOKEN_TRANSACTION_FINALIZED",
		3:  "TOKEN_TRANSACTION_STARTED_CANCELLED",
		4:  "TOKEN_TRANSACTION_SIGNED_CANCELLED",
		10: "TOKEN_TRANSACTION_UNKNOWN",
	}
	TokenTransactionStatus_value = map[string]int32{
		"TOKEN_TRANSACTION_STARTED":           0,
		"TOKEN_TRANSACTION_SIGNED":            1,
		"TOKEN_TRANSACTION_REVEALED":          5,
		"TOKEN_TRANSACTION_FINALIZED":         2,
		"TOKEN_TRANSACTION_STARTED_CANCELLED": 3,
		"TOKEN_TRANSACTION_SIGNED_CANCELLED":  4,
		"TOKEN_TRANSACTION_UNKNOWN":           10,
	}
)

func (x TokenTransactionStatus) Enum() *TokenTransactionStatus {
	p := new(TokenTransactionStatus)
	*p = x
	return p
}

func (x TokenTransactionStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TokenTransactionStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_token_proto_enumTypes[2].Descriptor()
}

func (TokenTransactionStatus) Type() protoreflect.EnumType {
	return &file_spark_token_proto_enumTypes[2]
}

func (x TokenTransactionStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TokenTransactionStatus.Descriptor instead.
func (TokenTransactionStatus) EnumDescriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{2}
}

// This proto is constructed by the wallet to specify leaves it wants to spend
// as part of the token transaction.
type TokenOutputToSpend struct {
	state                    protoimpl.MessageState `protogen:"open.v1"`
	PrevTokenTransactionHash []byte                 `protobuf:"bytes,1,opt,name=prev_token_transaction_hash,json=prevTokenTransactionHash,proto3" json:"prev_token_transaction_hash,omitempty"`
	PrevTokenTransactionVout uint32                 `protobuf:"varint,2,opt,name=prev_token_transaction_vout,json=prevTokenTransactionVout,proto3" json:"prev_token_transaction_vout,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *TokenOutputToSpend) Reset() {
	*x = TokenOutputToSpend{}
	mi := &file_spark_token_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenOutputToSpend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenOutputToSpend) ProtoMessage() {}

func (x *TokenOutputToSpend) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenOutputToSpend.ProtoReflect.Descriptor instead.
func (*TokenOutputToSpend) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{0}
}

func (x *TokenOutputToSpend) GetPrevTokenTransactionHash() []byte {
	if x != nil {
		return x.PrevTokenTransactionHash
	}
	return nil
}

func (x *TokenOutputToSpend) GetPrevTokenTransactionVout() uint32 {
	if x != nil {
		return x.PrevTokenTransactionVout
	}
	return 0
}

type TokenTransferInput struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	OutputsToSpend []*TokenOutputToSpend  `protobuf:"bytes,1,rep,name=outputs_to_spend,json=outputsToSpend,proto3" json:"outputs_to_spend,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TokenTransferInput) Reset() {
	*x = TokenTransferInput{}
	mi := &file_spark_token_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransferInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransferInput) ProtoMessage() {}

func (x *TokenTransferInput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransferInput.ProtoReflect.Descriptor instead.
func (*TokenTransferInput) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{1}
}

func (x *TokenTransferInput) GetOutputsToSpend() []*TokenOutputToSpend {
	if x != nil {
		return x.OutputsToSpend
	}
	return nil
}

type TokenMintInput struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	IssuerPublicKey []byte                 `protobuf:"bytes,1,opt,name=issuer_public_key,json=issuerPublicKey,proto3" json:"issuer_public_key,omitempty"`
	TokenIdentifier []byte                 `protobuf:"bytes,2,opt,name=token_identifier,json=tokenIdentifier,proto3,oneof" json:"token_identifier,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TokenMintInput) Reset() {
	*x = TokenMintInput{}
	mi := &file_spark_token_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenMintInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenMintInput) ProtoMessage() {}

func (x *TokenMintInput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenMintInput.ProtoReflect.Descriptor instead.
func (*TokenMintInput) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{2}
}

func (x *TokenMintInput) GetIssuerPublicKey() []byte {
	if x != nil {
		return x.IssuerPublicKey
	}
	return nil
}

func (x *TokenMintInput) GetTokenIdentifier() []byte {
	if x != nil {
		return x.TokenIdentifier
	}
	return nil
}

type TokenCreateInput struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	IssuerPublicKey         []byte                 `protobuf:"bytes,1,opt,name=issuer_public_key,json=issuerPublicKey,proto3" json:"issuer_public_key,omitempty"`
	TokenName               string                 `protobuf:"bytes,2,opt,name=token_name,json=tokenName,proto3" json:"token_name,omitempty"`       // No minimum length because a single utf-8 character can be 3 bytes.
	TokenTicker             string                 `protobuf:"bytes,3,opt,name=token_ticker,json=tokenTicker,proto3" json:"token_ticker,omitempty"` // No minimum length because a single utf-8 character can be 3 bytes.
	Decimals                uint32                 `protobuf:"varint,4,opt,name=decimals,proto3" json:"decimals,omitempty"`
	MaxSupply               []byte                 `protobuf:"bytes,5,opt,name=max_supply,json=maxSupply,proto3" json:"max_supply,omitempty"` // Decoded uint128
	IsFreezable             bool                   `protobuf:"varint,6,opt,name=is_freezable,json=isFreezable,proto3" json:"is_freezable,omitempty"`
	CreationEntityPublicKey []byte                 `protobuf:"bytes,7,opt,name=creation_entity_public_key,json=creationEntityPublicKey,proto3,oneof" json:"creation_entity_public_key,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *TokenCreateInput) Reset() {
	*x = TokenCreateInput{}
	mi := &file_spark_token_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenCreateInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenCreateInput) ProtoMessage() {}

func (x *TokenCreateInput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenCreateInput.ProtoReflect.Descriptor instead.
func (*TokenCreateInput) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{3}
}

func (x *TokenCreateInput) GetIssuerPublicKey() []byte {
	if x != nil {
		return x.IssuerPublicKey
	}
	return nil
}

func (x *TokenCreateInput) GetTokenName() string {
	if x != nil {
		return x.TokenName
	}
	return ""
}

func (x *TokenCreateInput) GetTokenTicker() string {
	if x != nil {
		return x.TokenTicker
	}
	return ""
}

func (x *TokenCreateInput) GetDecimals() uint32 {
	if x != nil {
		return x.Decimals
	}
	return 0
}

func (x *TokenCreateInput) GetMaxSupply() []byte {
	if x != nil {
		return x.MaxSupply
	}
	return nil
}

func (x *TokenCreateInput) GetIsFreezable() bool {
	if x != nil {
		return x.IsFreezable
	}
	return false
}

func (x *TokenCreateInput) GetCreationEntityPublicKey() []byte {
	if x != nil {
		return x.CreationEntityPublicKey
	}
	return nil
}

// This proto is constructed by the wallet to specify outputs it wants to create
// as part of a token transaction. Output id and revocation public key should
// remain unfilled so that the SE can fill them as part of the
// StartTokenTransaction() call.
type TokenOutput struct {
	state                         protoimpl.MessageState `protogen:"open.v1"`
	Id                            *string                `protobuf:"bytes,1,opt,name=id,proto3,oneof" json:"id,omitempty"`
	OwnerPublicKey                []byte                 `protobuf:"bytes,2,opt,name=owner_public_key,json=ownerPublicKey,proto3" json:"owner_public_key,omitempty"`
	RevocationCommitment          []byte                 `protobuf:"bytes,3,opt,name=revocation_commitment,json=revocationCommitment,proto3,oneof" json:"revocation_commitment,omitempty"`
	WithdrawBondSats              *uint64                `protobuf:"varint,4,opt,name=withdraw_bond_sats,json=withdrawBondSats,proto3,oneof" json:"withdraw_bond_sats,omitempty"`
	WithdrawRelativeBlockLocktime *uint64                `protobuf:"varint,5,opt,name=withdraw_relative_block_locktime,json=withdrawRelativeBlockLocktime,proto3,oneof" json:"withdraw_relative_block_locktime,omitempty"`
	TokenPublicKey                []byte                 `protobuf:"bytes,6,opt,name=token_public_key,json=tokenPublicKey,proto3,oneof" json:"token_public_key,omitempty"`
	TokenIdentifier               []byte                 `protobuf:"bytes,8,opt,name=token_identifier,json=tokenIdentifier,proto3,oneof" json:"token_identifier,omitempty"`
	TokenAmount                   []byte                 `protobuf:"bytes,7,opt,name=token_amount,json=tokenAmount,proto3" json:"token_amount,omitempty"` // Decoded uint128
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *TokenOutput) Reset() {
	*x = TokenOutput{}
	mi := &file_spark_token_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenOutput) ProtoMessage() {}

func (x *TokenOutput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenOutput.ProtoReflect.Descriptor instead.
func (*TokenOutput) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{4}
}

func (x *TokenOutput) GetId() string {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return ""
}

func (x *TokenOutput) GetOwnerPublicKey() []byte {
	if x != nil {
		return x.OwnerPublicKey
	}
	return nil
}

func (x *TokenOutput) GetRevocationCommitment() []byte {
	if x != nil {
		return x.RevocationCommitment
	}
	return nil
}

func (x *TokenOutput) GetWithdrawBondSats() uint64 {
	if x != nil && x.WithdrawBondSats != nil {
		return *x.WithdrawBondSats
	}
	return 0
}

func (x *TokenOutput) GetWithdrawRelativeBlockLocktime() uint64 {
	if x != nil && x.WithdrawRelativeBlockLocktime != nil {
		return *x.WithdrawRelativeBlockLocktime
	}
	return 0
}

func (x *TokenOutput) GetTokenPublicKey() []byte {
	if x != nil {
		return x.TokenPublicKey
	}
	return nil
}

func (x *TokenOutput) GetTokenIdentifier() []byte {
	if x != nil {
		return x.TokenIdentifier
	}
	return nil
}

func (x *TokenOutput) GetTokenAmount() []byte {
	if x != nil {
		return x.TokenAmount
	}
	return nil
}

// This proto is constructed by the wallet and is the core transaction data
// structure. This proto is deterministically hashed to generate the
// token_transaction_hash that is cooperatively signed by the SO group to
// confirm a token transaction.
type TokenTransaction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// For mint transactions issuer_public_key will be specified without any
	// outputs_to_spend. For transfer transactions the token amount in the input
	// leaves must match the token amount in the output leaves.
	Version uint32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// Types that are valid to be assigned to TokenInputs:
	//
	//	*TokenTransaction_MintInput
	//	*TokenTransaction_TransferInput
	//	*TokenTransaction_CreateInput
	TokenInputs                     isTokenTransaction_TokenInputs `protobuf_oneof:"token_inputs"`
	TokenOutputs                    []*TokenOutput                 `protobuf:"bytes,4,rep,name=token_outputs,json=tokenOutputs,proto3" json:"token_outputs,omitempty"`
	SparkOperatorIdentityPublicKeys [][]byte                       `protobuf:"bytes,5,rep,name=spark_operator_identity_public_keys,json=sparkOperatorIdentityPublicKeys,proto3" json:"spark_operator_identity_public_keys,omitempty"`
	// Server-set expiry time. The server calculates this by adding the client's
	// requested validity_duration_seconds to the server's current time when
	// creating the final transaction.
	ExpiryTime *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=expiry_time,json=expiryTime,proto3" json:"expiry_time,omitempty"`
	Network    spark.Network          `protobuf:"varint,7,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"`
	// The timestamp of when the client created the transaction. This is used to
	// determine which transaction should win in a race condition. Earlier
	// timestamps win over later ones.
	ClientCreatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=client_created_timestamp,json=clientCreatedTimestamp,proto3" json:"client_created_timestamp,omitempty"`
	// The spark invoices this transaction fulfills.
	InvoiceAttachments []*InvoiceAttachment `protobuf:"bytes,10,rep,name=invoice_attachments,json=invoiceAttachments,proto3" json:"invoice_attachments,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *TokenTransaction) Reset() {
	*x = TokenTransaction{}
	mi := &file_spark_token_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransaction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransaction) ProtoMessage() {}

func (x *TokenTransaction) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransaction.ProtoReflect.Descriptor instead.
func (*TokenTransaction) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{5}
}

func (x *TokenTransaction) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *TokenTransaction) GetTokenInputs() isTokenTransaction_TokenInputs {
	if x != nil {
		return x.TokenInputs
	}
	return nil
}

func (x *TokenTransaction) GetMintInput() *TokenMintInput {
	if x != nil {
		if x, ok := x.TokenInputs.(*TokenTransaction_MintInput); ok {
			return x.MintInput
		}
	}
	return nil
}

func (x *TokenTransaction) GetTransferInput() *TokenTransferInput {
	if x != nil {
		if x, ok := x.TokenInputs.(*TokenTransaction_TransferInput); ok {
			return x.TransferInput
		}
	}
	return nil
}

func (x *TokenTransaction) GetCreateInput() *TokenCreateInput {
	if x != nil {
		if x, ok := x.TokenInputs.(*TokenTransaction_CreateInput); ok {
			return x.CreateInput
		}
	}
	return nil
}

func (x *TokenTransaction) GetTokenOutputs() []*TokenOutput {
	if x != nil {
		return x.TokenOutputs
	}
	return nil
}

func (x *TokenTransaction) GetSparkOperatorIdentityPublicKeys() [][]byte {
	if x != nil {
		return x.SparkOperatorIdentityPublicKeys
	}
	return nil
}

func (x *TokenTransaction) GetExpiryTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiryTime
	}
	return nil
}

func (x *TokenTransaction) GetNetwork() spark.Network {
	if x != nil {
		return x.Network
	}
	return spark.Network(0)
}

func (x *TokenTransaction) GetClientCreatedTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.ClientCreatedTimestamp
	}
	return nil
}

func (x *TokenTransaction) GetInvoiceAttachments() []*InvoiceAttachment {
	if x != nil {
		return x.InvoiceAttachments
	}
	return nil
}

type isTokenTransaction_TokenInputs interface {
	isTokenTransaction_TokenInputs()
}

type TokenTransaction_MintInput struct {
	MintInput *TokenMintInput `protobuf:"bytes,2,opt,name=mint_input,json=mintInput,proto3,oneof"`
}

type TokenTransaction_TransferInput struct {
	TransferInput *TokenTransferInput `protobuf:"bytes,3,opt,name=transfer_input,json=transferInput,proto3,oneof"`
}

type TokenTransaction_CreateInput struct {
	CreateInput *TokenCreateInput `protobuf:"bytes,8,opt,name=create_input,json=createInput,proto3,oneof"`
}

func (*TokenTransaction_MintInput) isTokenTransaction_TokenInputs() {}

func (*TokenTransaction_TransferInput) isTokenTransaction_TokenInputs() {}

func (*TokenTransaction_CreateInput) isTokenTransaction_TokenInputs() {}

type InvoiceAttachment struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SparkInvoice  string                 `protobuf:"bytes,1,opt,name=spark_invoice,json=sparkInvoice,proto3" json:"spark_invoice,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InvoiceAttachment) Reset() {
	*x = InvoiceAttachment{}
	mi := &file_spark_token_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InvoiceAttachment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InvoiceAttachment) ProtoMessage() {}

func (x *InvoiceAttachment) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InvoiceAttachment.ProtoReflect.Descriptor instead.
func (*InvoiceAttachment) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{6}
}

func (x *InvoiceAttachment) GetSparkInvoice() string {
	if x != nil {
		return x.SparkInvoice
	}
	return ""
}

type SignatureWithIndex struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This is a Schnorr or ECDSA DER signature which can be between 64 and 73
	// bytes.
	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	// The index of the TTXO associated with this signature.
	InputIndex    uint32 `protobuf:"varint,2,opt,name=input_index,json=inputIndex,proto3" json:"input_index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SignatureWithIndex) Reset() {
	*x = SignatureWithIndex{}
	mi := &file_spark_token_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignatureWithIndex) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignatureWithIndex) ProtoMessage() {}

func (x *SignatureWithIndex) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignatureWithIndex.ProtoReflect.Descriptor instead.
func (*SignatureWithIndex) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{7}
}

func (x *SignatureWithIndex) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *SignatureWithIndex) GetInputIndex() uint32 {
	if x != nil {
		return x.InputIndex
	}
	return 0
}

// A group of signatures for the input TTXOs binding them to the final token
// transaction hash. This bundle of signatures is specific to a given operator.
type InputTtxoSignaturesPerOperator struct {
	state                     protoimpl.MessageState `protogen:"open.v1"`
	TtxoSignatures            []*SignatureWithIndex  `protobuf:"bytes,1,rep,name=ttxo_signatures,json=ttxoSignatures,proto3" json:"ttxo_signatures,omitempty"`
	OperatorIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=operator_identity_public_key,json=operatorIdentityPublicKey,proto3" json:"operator_identity_public_key,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *InputTtxoSignaturesPerOperator) Reset() {
	*x = InputTtxoSignaturesPerOperator{}
	mi := &file_spark_token_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InputTtxoSignaturesPerOperator) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InputTtxoSignaturesPerOperator) ProtoMessage() {}

func (x *InputTtxoSignaturesPerOperator) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InputTtxoSignaturesPerOperator.ProtoReflect.Descriptor instead.
func (*InputTtxoSignaturesPerOperator) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{8}
}

func (x *InputTtxoSignaturesPerOperator) GetTtxoSignatures() []*SignatureWithIndex {
	if x != nil {
		return x.TtxoSignatures
	}
	return nil
}

func (x *InputTtxoSignaturesPerOperator) GetOperatorIdentityPublicKey() []byte {
	if x != nil {
		return x.OperatorIdentityPublicKey
	}
	return nil
}

// === Start Transaction ===
type StartTransactionRequest struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	IdentityPublicKey       []byte                 `protobuf:"bytes,1,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	PartialTokenTransaction *TokenTransaction      `protobuf:"bytes,2,opt,name=partial_token_transaction,json=partialTokenTransaction,proto3" json:"partial_token_transaction,omitempty"`
	// Filled by signing the partial token transaction hash with the
	// owner/issuer private key. For mint transactions this will be one
	// signature for the input issuer_public_key For transfer transactions this
	// will be one for each output for the output owner_public_key
	PartialTokenTransactionOwnerSignatures []*SignatureWithIndex `protobuf:"bytes,3,rep,name=partial_token_transaction_owner_signatures,json=partialTokenTransactionOwnerSignatures,proto3" json:"partial_token_transaction_owner_signatures,omitempty"`
	// How long the transaction should be valid for, in seconds.
	// The server will set the actual expiry_time in the final transaction based
	// on this duration. Must be within [1, 300] seconds.
	ValidityDurationSeconds uint64 `protobuf:"varint,4,opt,name=validity_duration_seconds,json=validityDurationSeconds,proto3" json:"validity_duration_seconds,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *StartTransactionRequest) Reset() {
	*x = StartTransactionRequest{}
	mi := &file_spark_token_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTransactionRequest) ProtoMessage() {}

func (x *StartTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTransactionRequest.ProtoReflect.Descriptor instead.
func (*StartTransactionRequest) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{9}
}

func (x *StartTransactionRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *StartTransactionRequest) GetPartialTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.PartialTokenTransaction
	}
	return nil
}

func (x *StartTransactionRequest) GetPartialTokenTransactionOwnerSignatures() []*SignatureWithIndex {
	if x != nil {
		return x.PartialTokenTransactionOwnerSignatures
	}
	return nil
}

func (x *StartTransactionRequest) GetValidityDurationSeconds() uint64 {
	if x != nil {
		return x.ValidityDurationSeconds
	}
	return 0
}

type StartTransactionResponse struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	FinalTokenTransaction *TokenTransaction      `protobuf:"bytes,1,opt,name=final_token_transaction,json=finalTokenTransaction,proto3" json:"final_token_transaction,omitempty"`
	KeyshareInfo          *spark.SigningKeyshare `protobuf:"bytes,2,opt,name=keyshare_info,json=keyshareInfo,proto3" json:"keyshare_info,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *StartTransactionResponse) Reset() {
	*x = StartTransactionResponse{}
	mi := &file_spark_token_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTransactionResponse) ProtoMessage() {}

func (x *StartTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTransactionResponse.ProtoReflect.Descriptor instead.
func (*StartTransactionResponse) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{10}
}

func (x *StartTransactionResponse) GetFinalTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.FinalTokenTransaction
	}
	return nil
}

func (x *StartTransactionResponse) GetKeyshareInfo() *spark.SigningKeyshare {
	if x != nil {
		return x.KeyshareInfo
	}
	return nil
}

type CommitTransactionRequest struct {
	state                          protoimpl.MessageState            `protogen:"open.v1"`
	FinalTokenTransaction          *TokenTransaction                 `protobuf:"bytes,1,opt,name=final_token_transaction,json=finalTokenTransaction,proto3" json:"final_token_transaction,omitempty"`
	FinalTokenTransactionHash      []byte                            `protobuf:"bytes,2,opt,name=final_token_transaction_hash,json=finalTokenTransactionHash,proto3" json:"final_token_transaction_hash,omitempty"`
	InputTtxoSignaturesPerOperator []*InputTtxoSignaturesPerOperator `protobuf:"bytes,3,rep,name=input_ttxo_signatures_per_operator,json=inputTtxoSignaturesPerOperator,proto3" json:"input_ttxo_signatures_per_operator,omitempty"`
	OwnerIdentityPublicKey         []byte                            `protobuf:"bytes,4,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	unknownFields                  protoimpl.UnknownFields
	sizeCache                      protoimpl.SizeCache
}

func (x *CommitTransactionRequest) Reset() {
	*x = CommitTransactionRequest{}
	mi := &file_spark_token_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitTransactionRequest) ProtoMessage() {}

func (x *CommitTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitTransactionRequest.ProtoReflect.Descriptor instead.
func (*CommitTransactionRequest) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{11}
}

func (x *CommitTransactionRequest) GetFinalTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.FinalTokenTransaction
	}
	return nil
}

func (x *CommitTransactionRequest) GetFinalTokenTransactionHash() []byte {
	if x != nil {
		return x.FinalTokenTransactionHash
	}
	return nil
}

func (x *CommitTransactionRequest) GetInputTtxoSignaturesPerOperator() []*InputTtxoSignaturesPerOperator {
	if x != nil {
		return x.InputTtxoSignaturesPerOperator
	}
	return nil
}

func (x *CommitTransactionRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

type CommitProgress struct {
	state                         protoimpl.MessageState `protogen:"open.v1"`
	CommittedOperatorPublicKeys   [][]byte               `protobuf:"bytes,1,rep,name=committed_operator_public_keys,json=committedOperatorPublicKeys,proto3" json:"committed_operator_public_keys,omitempty"`
	UncommittedOperatorPublicKeys [][]byte               `protobuf:"bytes,2,rep,name=uncommitted_operator_public_keys,json=uncommittedOperatorPublicKeys,proto3" json:"uncommitted_operator_public_keys,omitempty"`
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *CommitProgress) Reset() {
	*x = CommitProgress{}
	mi := &file_spark_token_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitProgress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitProgress) ProtoMessage() {}

func (x *CommitProgress) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitProgress.ProtoReflect.Descriptor instead.
func (*CommitProgress) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{12}
}

func (x *CommitProgress) GetCommittedOperatorPublicKeys() [][]byte {
	if x != nil {
		return x.CommittedOperatorPublicKeys
	}
	return nil
}

func (x *CommitProgress) GetUncommittedOperatorPublicKeys() [][]byte {
	if x != nil {
		return x.UncommittedOperatorPublicKeys
	}
	return nil
}

type CommitTransactionResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	CommitStatus   CommitStatus           `protobuf:"varint,1,opt,name=commit_status,json=commitStatus,proto3,enum=spark_token.CommitStatus" json:"commit_status,omitempty"`
	CommitProgress *CommitProgress        `protobuf:"bytes,2,opt,name=commit_progress,json=commitProgress,proto3" json:"commit_progress,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *CommitTransactionResponse) Reset() {
	*x = CommitTransactionResponse{}
	mi := &file_spark_token_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitTransactionResponse) ProtoMessage() {}

func (x *CommitTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitTransactionResponse.ProtoReflect.Descriptor instead.
func (*CommitTransactionResponse) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{13}
}

func (x *CommitTransactionResponse) GetCommitStatus() CommitStatus {
	if x != nil {
		return x.CommitStatus
	}
	return CommitStatus_COMMIT_UNSPECIFIED
}

func (x *CommitTransactionResponse) GetCommitProgress() *CommitProgress {
	if x != nil {
		return x.CommitProgress
	}
	return nil
}

type QueryTokenMetadataRequest struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	TokenIdentifiers [][]byte               `protobuf:"bytes,1,rep,name=token_identifiers,json=tokenIdentifiers,proto3" json:"token_identifiers,omitempty"`
	IssuerPublicKeys [][]byte               `protobuf:"bytes,2,rep,name=issuer_public_keys,json=issuerPublicKeys,proto3" json:"issuer_public_keys,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *QueryTokenMetadataRequest) Reset() {
	*x = QueryTokenMetadataRequest{}
	mi := &file_spark_token_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTokenMetadataRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTokenMetadataRequest) ProtoMessage() {}

func (x *QueryTokenMetadataRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTokenMetadataRequest.ProtoReflect.Descriptor instead.
func (*QueryTokenMetadataRequest) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{14}
}

func (x *QueryTokenMetadataRequest) GetTokenIdentifiers() [][]byte {
	if x != nil {
		return x.TokenIdentifiers
	}
	return nil
}

func (x *QueryTokenMetadataRequest) GetIssuerPublicKeys() [][]byte {
	if x != nil {
		return x.IssuerPublicKeys
	}
	return nil
}

type TokenMetadata struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	IssuerPublicKey         []byte                 `protobuf:"bytes,1,opt,name=issuer_public_key,json=issuerPublicKey,proto3" json:"issuer_public_key,omitempty"`
	TokenName               string                 `protobuf:"bytes,2,opt,name=token_name,json=tokenName,proto3" json:"token_name,omitempty"`
	TokenTicker             string                 `protobuf:"bytes,3,opt,name=token_ticker,json=tokenTicker,proto3" json:"token_ticker,omitempty"`
	Decimals                uint32                 `protobuf:"varint,4,opt,name=decimals,proto3" json:"decimals,omitempty"`
	MaxSupply               []byte                 `protobuf:"bytes,5,opt,name=max_supply,json=maxSupply,proto3" json:"max_supply,omitempty"` // Decoded uint128
	IsFreezable             bool                   `protobuf:"varint,6,opt,name=is_freezable,json=isFreezable,proto3" json:"is_freezable,omitempty"`
	CreationEntityPublicKey []byte                 `protobuf:"bytes,7,opt,name=creation_entity_public_key,json=creationEntityPublicKey,proto3,oneof" json:"creation_entity_public_key,omitempty"`
	TokenIdentifier         []byte                 `protobuf:"bytes,8,opt,name=token_identifier,json=tokenIdentifier,proto3" json:"token_identifier,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *TokenMetadata) Reset() {
	*x = TokenMetadata{}
	mi := &file_spark_token_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenMetadata) ProtoMessage() {}

func (x *TokenMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenMetadata.ProtoReflect.Descriptor instead.
func (*TokenMetadata) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{15}
}

func (x *TokenMetadata) GetIssuerPublicKey() []byte {
	if x != nil {
		return x.IssuerPublicKey
	}
	return nil
}

func (x *TokenMetadata) GetTokenName() string {
	if x != nil {
		return x.TokenName
	}
	return ""
}

func (x *TokenMetadata) GetTokenTicker() string {
	if x != nil {
		return x.TokenTicker
	}
	return ""
}

func (x *TokenMetadata) GetDecimals() uint32 {
	if x != nil {
		return x.Decimals
	}
	return 0
}

func (x *TokenMetadata) GetMaxSupply() []byte {
	if x != nil {
		return x.MaxSupply
	}
	return nil
}

func (x *TokenMetadata) GetIsFreezable() bool {
	if x != nil {
		return x.IsFreezable
	}
	return false
}

func (x *TokenMetadata) GetCreationEntityPublicKey() []byte {
	if x != nil {
		return x.CreationEntityPublicKey
	}
	return nil
}

func (x *TokenMetadata) GetTokenIdentifier() []byte {
	if x != nil {
		return x.TokenIdentifier
	}
	return nil
}

type QueryTokenMetadataResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TokenMetadata []*TokenMetadata       `protobuf:"bytes,1,rep,name=token_metadata,json=tokenMetadata,proto3" json:"token_metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryTokenMetadataResponse) Reset() {
	*x = QueryTokenMetadataResponse{}
	mi := &file_spark_token_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTokenMetadataResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTokenMetadataResponse) ProtoMessage() {}

func (x *QueryTokenMetadataResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTokenMetadataResponse.ProtoReflect.Descriptor instead.
func (*QueryTokenMetadataResponse) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{16}
}

func (x *QueryTokenMetadataResponse) GetTokenMetadata() []*TokenMetadata {
	if x != nil {
		return x.TokenMetadata
	}
	return nil
}

type QueryTokenOutputsRequest struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	OwnerPublicKeys [][]byte               `protobuf:"bytes,1,rep,name=owner_public_keys,json=ownerPublicKeys,proto3" json:"owner_public_keys,omitempty"`
	// Optionally provide issuer public keys or token identifiers. If both are not set return outputs for all tokens.
	IssuerPublicKeys [][]byte      `protobuf:"bytes,2,rep,name=issuer_public_keys,json=issuerPublicKeys,proto3" json:"issuer_public_keys,omitempty"`
	TokenIdentifiers [][]byte      `protobuf:"bytes,4,rep,name=token_identifiers,json=tokenIdentifiers,proto3" json:"token_identifiers,omitempty"`
	Network          spark.Network `protobuf:"varint,3,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"` // defaults to mainnet when no network is provided.
	// For pagination
	PageRequest   *spark.PageRequest `protobuf:"bytes,5,opt,name=page_request,json=pageRequest,proto3" json:"page_request,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryTokenOutputsRequest) Reset() {
	*x = QueryTokenOutputsRequest{}
	mi := &file_spark_token_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTokenOutputsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTokenOutputsRequest) ProtoMessage() {}

func (x *QueryTokenOutputsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTokenOutputsRequest.ProtoReflect.Descriptor instead.
func (*QueryTokenOutputsRequest) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{17}
}

func (x *QueryTokenOutputsRequest) GetOwnerPublicKeys() [][]byte {
	if x != nil {
		return x.OwnerPublicKeys
	}
	return nil
}

func (x *QueryTokenOutputsRequest) GetIssuerPublicKeys() [][]byte {
	if x != nil {
		return x.IssuerPublicKeys
	}
	return nil
}

func (x *QueryTokenOutputsRequest) GetTokenIdentifiers() [][]byte {
	if x != nil {
		return x.TokenIdentifiers
	}
	return nil
}

func (x *QueryTokenOutputsRequest) GetNetwork() spark.Network {
	if x != nil {
		return x.Network
	}
	return spark.Network(0)
}

func (x *QueryTokenOutputsRequest) GetPageRequest() *spark.PageRequest {
	if x != nil {
		return x.PageRequest
	}
	return nil
}

// Request constraints are combined using an AND relation.
type QueryTokenTransactionsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Returns transactions that have one of these output ids in the input or output.
	OutputIds []string `protobuf:"bytes,1,rep,name=output_ids,json=outputIds,proto3" json:"output_ids,omitempty"`
	// Returns transactions that have this owner public key as the sender or receiver in one or more of the input/output leaves.
	OwnerPublicKeys [][]byte `protobuf:"bytes,2,rep,name=owner_public_keys,json=ownerPublicKeys,proto3" json:"owner_public_keys,omitempty"`
	// Returns transactions that related to this token public key.
	IssuerPublicKeys [][]byte `protobuf:"bytes,3,rep,name=issuer_public_keys,json=issuerPublicKeys,proto3" json:"issuer_public_keys,omitempty"`
	// Returns transactions that related to this token identifier.
	TokenIdentifiers [][]byte `protobuf:"bytes,7,rep,name=token_identifiers,json=tokenIdentifiers,proto3" json:"token_identifiers,omitempty"`
	// Returns transactions that match the provided transaction hashes.
	TokenTransactionHashes [][]byte `protobuf:"bytes,4,rep,name=token_transaction_hashes,json=tokenTransactionHashes,proto3" json:"token_transaction_hashes,omitempty"`
	Limit                  int64    `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset                 int64    `protobuf:"varint,6,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *QueryTokenTransactionsRequest) Reset() {
	*x = QueryTokenTransactionsRequest{}
	mi := &file_spark_token_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTokenTransactionsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTokenTransactionsRequest) ProtoMessage() {}

func (x *QueryTokenTransactionsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTokenTransactionsRequest.ProtoReflect.Descriptor instead.
func (*QueryTokenTransactionsRequest) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{18}
}

func (x *QueryTokenTransactionsRequest) GetOutputIds() []string {
	if x != nil {
		return x.OutputIds
	}
	return nil
}

func (x *QueryTokenTransactionsRequest) GetOwnerPublicKeys() [][]byte {
	if x != nil {
		return x.OwnerPublicKeys
	}
	return nil
}

func (x *QueryTokenTransactionsRequest) GetIssuerPublicKeys() [][]byte {
	if x != nil {
		return x.IssuerPublicKeys
	}
	return nil
}

func (x *QueryTokenTransactionsRequest) GetTokenIdentifiers() [][]byte {
	if x != nil {
		return x.TokenIdentifiers
	}
	return nil
}

func (x *QueryTokenTransactionsRequest) GetTokenTransactionHashes() [][]byte {
	if x != nil {
		return x.TokenTransactionHashes
	}
	return nil
}

func (x *QueryTokenTransactionsRequest) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *QueryTokenTransactionsRequest) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type QueryTokenTransactionsResponse struct {
	state                       protoimpl.MessageState        `protogen:"open.v1"`
	TokenTransactionsWithStatus []*TokenTransactionWithStatus `protobuf:"bytes,1,rep,name=token_transactions_with_status,json=tokenTransactionsWithStatus,proto3" json:"token_transactions_with_status,omitempty"`
	Offset                      int64                         `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields               protoimpl.UnknownFields
	sizeCache                   protoimpl.SizeCache
}

func (x *QueryTokenTransactionsResponse) Reset() {
	*x = QueryTokenTransactionsResponse{}
	mi := &file_spark_token_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTokenTransactionsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTokenTransactionsResponse) ProtoMessage() {}

func (x *QueryTokenTransactionsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTokenTransactionsResponse.ProtoReflect.Descriptor instead.
func (*QueryTokenTransactionsResponse) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{19}
}

func (x *QueryTokenTransactionsResponse) GetTokenTransactionsWithStatus() []*TokenTransactionWithStatus {
	if x != nil {
		return x.TokenTransactionsWithStatus
	}
	return nil
}

func (x *QueryTokenTransactionsResponse) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type OutputWithPreviousTransactionData struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	Output                  *TokenOutput           `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	PreviousTransactionHash []byte                 `protobuf:"bytes,2,opt,name=previous_transaction_hash,json=previousTransactionHash,proto3" json:"previous_transaction_hash,omitempty"`
	PreviousTransactionVout uint32                 `protobuf:"varint,3,opt,name=previous_transaction_vout,json=previousTransactionVout,proto3" json:"previous_transaction_vout,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *OutputWithPreviousTransactionData) Reset() {
	*x = OutputWithPreviousTransactionData{}
	mi := &file_spark_token_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutputWithPreviousTransactionData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutputWithPreviousTransactionData) ProtoMessage() {}

func (x *OutputWithPreviousTransactionData) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutputWithPreviousTransactionData.ProtoReflect.Descriptor instead.
func (*OutputWithPreviousTransactionData) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{20}
}

func (x *OutputWithPreviousTransactionData) GetOutput() *TokenOutput {
	if x != nil {
		return x.Output
	}
	return nil
}

func (x *OutputWithPreviousTransactionData) GetPreviousTransactionHash() []byte {
	if x != nil {
		return x.PreviousTransactionHash
	}
	return nil
}

func (x *OutputWithPreviousTransactionData) GetPreviousTransactionVout() uint32 {
	if x != nil {
		return x.PreviousTransactionVout
	}
	return 0
}

type QueryTokenOutputsResponse struct {
	state                              protoimpl.MessageState               `protogen:"open.v1"`
	OutputsWithPreviousTransactionData []*OutputWithPreviousTransactionData `protobuf:"bytes,1,rep,name=outputs_with_previous_transaction_data,json=outputsWithPreviousTransactionData,proto3" json:"outputs_with_previous_transaction_data,omitempty"`
	PageResponse                       *spark.PageResponse                  `protobuf:"bytes,2,opt,name=page_response,json=pageResponse,proto3" json:"page_response,omitempty"`
	unknownFields                      protoimpl.UnknownFields
	sizeCache                          protoimpl.SizeCache
}

func (x *QueryTokenOutputsResponse) Reset() {
	*x = QueryTokenOutputsResponse{}
	mi := &file_spark_token_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTokenOutputsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTokenOutputsResponse) ProtoMessage() {}

func (x *QueryTokenOutputsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTokenOutputsResponse.ProtoReflect.Descriptor instead.
func (*QueryTokenOutputsResponse) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{21}
}

func (x *QueryTokenOutputsResponse) GetOutputsWithPreviousTransactionData() []*OutputWithPreviousTransactionData {
	if x != nil {
		return x.OutputsWithPreviousTransactionData
	}
	return nil
}

func (x *QueryTokenOutputsResponse) GetPageResponse() *spark.PageResponse {
	if x != nil {
		return x.PageResponse
	}
	return nil
}

type SpentTokenOutputMetadata struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	OutputId         string                 `protobuf:"bytes,1,opt,name=output_id,json=outputId,proto3" json:"output_id,omitempty"`
	RevocationSecret []byte                 `protobuf:"bytes,2,opt,name=revocation_secret,json=revocationSecret,proto3" json:"revocation_secret,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *SpentTokenOutputMetadata) Reset() {
	*x = SpentTokenOutputMetadata{}
	mi := &file_spark_token_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpentTokenOutputMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpentTokenOutputMetadata) ProtoMessage() {}

func (x *SpentTokenOutputMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpentTokenOutputMetadata.ProtoReflect.Descriptor instead.
func (*SpentTokenOutputMetadata) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{22}
}

func (x *SpentTokenOutputMetadata) GetOutputId() string {
	if x != nil {
		return x.OutputId
	}
	return ""
}

func (x *SpentTokenOutputMetadata) GetRevocationSecret() []byte {
	if x != nil {
		return x.RevocationSecret
	}
	return nil
}

type TokenTransactionConfirmationMetadata struct {
	state                     protoimpl.MessageState      `protogen:"open.v1"`
	SpentTokenOutputsMetadata []*SpentTokenOutputMetadata `protobuf:"bytes,1,rep,name=spent_token_outputs_metadata,json=spentTokenOutputsMetadata,proto3" json:"spent_token_outputs_metadata,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *TokenTransactionConfirmationMetadata) Reset() {
	*x = TokenTransactionConfirmationMetadata{}
	mi := &file_spark_token_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransactionConfirmationMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransactionConfirmationMetadata) ProtoMessage() {}

func (x *TokenTransactionConfirmationMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransactionConfirmationMetadata.ProtoReflect.Descriptor instead.
func (*TokenTransactionConfirmationMetadata) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{23}
}

func (x *TokenTransactionConfirmationMetadata) GetSpentTokenOutputsMetadata() []*SpentTokenOutputMetadata {
	if x != nil {
		return x.SpentTokenOutputsMetadata
	}
	return nil
}

type TokenTransactionWithStatus struct {
	state                protoimpl.MessageState                `protogen:"open.v1"`
	TokenTransaction     *TokenTransaction                     `protobuf:"bytes,1,opt,name=token_transaction,json=tokenTransaction,proto3" json:"token_transaction,omitempty"`
	Status               TokenTransactionStatus                `protobuf:"varint,2,opt,name=status,proto3,enum=spark_token.TokenTransactionStatus" json:"status,omitempty"`
	ConfirmationMetadata *TokenTransactionConfirmationMetadata `protobuf:"bytes,3,opt,name=confirmation_metadata,json=confirmationMetadata,proto3" json:"confirmation_metadata,omitempty"`
	// In rare cases the above reconstructed token transaction may not match the original token transaction due to:
	// a) a pre-empted transfer transaction having its input TTXOs remapped to the newer transaction
	// b) proto migrations or field deprecations resulting in missing/swapped fields (eg. token public key -> token identifier)
	// Include the original hash to ensure clients can reconcile this transaction with the original if needed.
	TokenTransactionHash []byte `protobuf:"bytes,4,opt,name=token_transaction_hash,json=tokenTransactionHash,proto3" json:"token_transaction_hash,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *TokenTransactionWithStatus) Reset() {
	*x = TokenTransactionWithStatus{}
	mi := &file_spark_token_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransactionWithStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransactionWithStatus) ProtoMessage() {}

func (x *TokenTransactionWithStatus) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransactionWithStatus.ProtoReflect.Descriptor instead.
func (*TokenTransactionWithStatus) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{24}
}

func (x *TokenTransactionWithStatus) GetTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.TokenTransaction
	}
	return nil
}

func (x *TokenTransactionWithStatus) GetStatus() TokenTransactionStatus {
	if x != nil {
		return x.Status
	}
	return TokenTransactionStatus_TOKEN_TRANSACTION_STARTED
}

func (x *TokenTransactionWithStatus) GetConfirmationMetadata() *TokenTransactionConfirmationMetadata {
	if x != nil {
		return x.ConfirmationMetadata
	}
	return nil
}

func (x *TokenTransactionWithStatus) GetTokenTransactionHash() []byte {
	if x != nil {
		return x.TokenTransactionHash
	}
	return nil
}

type FreezeTokensPayload struct {
	state                     protoimpl.MessageState `protogen:"open.v1"`
	Version                   uint32                 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	OwnerPublicKey            []byte                 `protobuf:"bytes,2,opt,name=owner_public_key,json=ownerPublicKey,proto3" json:"owner_public_key,omitempty"`
	TokenPublicKey            []byte                 `protobuf:"bytes,3,opt,name=token_public_key,json=tokenPublicKey,proto3,oneof" json:"token_public_key,omitempty"`
	TokenIdentifier           []byte                 `protobuf:"bytes,4,opt,name=token_identifier,json=tokenIdentifier,proto3,oneof" json:"token_identifier,omitempty"`
	IssuerProvidedTimestamp   uint64                 `protobuf:"varint,5,opt,name=issuer_provided_timestamp,json=issuerProvidedTimestamp,proto3" json:"issuer_provided_timestamp,omitempty"`
	OperatorIdentityPublicKey []byte                 `protobuf:"bytes,6,opt,name=operator_identity_public_key,json=operatorIdentityPublicKey,proto3" json:"operator_identity_public_key,omitempty"`
	// Set to false when requesting a freeze.
	ShouldUnfreeze bool `protobuf:"varint,7,opt,name=should_unfreeze,json=shouldUnfreeze,proto3" json:"should_unfreeze,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *FreezeTokensPayload) Reset() {
	*x = FreezeTokensPayload{}
	mi := &file_spark_token_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreezeTokensPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreezeTokensPayload) ProtoMessage() {}

func (x *FreezeTokensPayload) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreezeTokensPayload.ProtoReflect.Descriptor instead.
func (*FreezeTokensPayload) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{25}
}

func (x *FreezeTokensPayload) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *FreezeTokensPayload) GetOwnerPublicKey() []byte {
	if x != nil {
		return x.OwnerPublicKey
	}
	return nil
}

func (x *FreezeTokensPayload) GetTokenPublicKey() []byte {
	if x != nil {
		return x.TokenPublicKey
	}
	return nil
}

func (x *FreezeTokensPayload) GetTokenIdentifier() []byte {
	if x != nil {
		return x.TokenIdentifier
	}
	return nil
}

func (x *FreezeTokensPayload) GetIssuerProvidedTimestamp() uint64 {
	if x != nil {
		return x.IssuerProvidedTimestamp
	}
	return 0
}

func (x *FreezeTokensPayload) GetOperatorIdentityPublicKey() []byte {
	if x != nil {
		return x.OperatorIdentityPublicKey
	}
	return nil
}

func (x *FreezeTokensPayload) GetShouldUnfreeze() bool {
	if x != nil {
		return x.ShouldUnfreeze
	}
	return false
}

type FreezeTokensRequest struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	FreezeTokensPayload *FreezeTokensPayload   `protobuf:"bytes,1,opt,name=freeze_tokens_payload,json=freezeTokensPayload,proto3" json:"freeze_tokens_payload,omitempty"`
	// This is a Schnorr or ECDSA DER signature which can be between 64 and 73 bytes.
	IssuerSignature []byte `protobuf:"bytes,2,opt,name=issuer_signature,json=issuerSignature,proto3" json:"issuer_signature,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *FreezeTokensRequest) Reset() {
	*x = FreezeTokensRequest{}
	mi := &file_spark_token_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreezeTokensRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreezeTokensRequest) ProtoMessage() {}

func (x *FreezeTokensRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreezeTokensRequest.ProtoReflect.Descriptor instead.
func (*FreezeTokensRequest) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{26}
}

func (x *FreezeTokensRequest) GetFreezeTokensPayload() *FreezeTokensPayload {
	if x != nil {
		return x.FreezeTokensPayload
	}
	return nil
}

func (x *FreezeTokensRequest) GetIssuerSignature() []byte {
	if x != nil {
		return x.IssuerSignature
	}
	return nil
}

type FreezeTokensResponse struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	ImpactedOutputIds   []string               `protobuf:"bytes,1,rep,name=impacted_output_ids,json=impactedOutputIds,proto3" json:"impacted_output_ids,omitempty"`
	ImpactedTokenAmount []byte                 `protobuf:"bytes,2,opt,name=impacted_token_amount,json=impactedTokenAmount,proto3" json:"impacted_token_amount,omitempty"` // Decoded uint128
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *FreezeTokensResponse) Reset() {
	*x = FreezeTokensResponse{}
	mi := &file_spark_token_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreezeTokensResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreezeTokensResponse) ProtoMessage() {}

func (x *FreezeTokensResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_token_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreezeTokensResponse.ProtoReflect.Descriptor instead.
func (*FreezeTokensResponse) Descriptor() ([]byte, []int) {
	return file_spark_token_proto_rawDescGZIP(), []int{27}
}

func (x *FreezeTokensResponse) GetImpactedOutputIds() []string {
	if x != nil {
		return x.ImpactedOutputIds
	}
	return nil
}

func (x *FreezeTokensResponse) GetImpactedTokenAmount() []byte {
	if x != nil {
		return x.ImpactedTokenAmount
	}
	return nil
}

var File_spark_token_proto protoreflect.FileDescriptor

const file_spark_token_proto_rawDesc = "" +
	"\n" +
	"\x11spark_token.proto\x12\vspark_token\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\vspark.proto\x1a\x17validate/validate.proto\"\x9b\x01\n" +
	"\x12TokenOutputToSpend\x12F\n" +
	"\x1bprev_token_transaction_hash\x18\x01 \x01(\fB\a\xfaB\x04z\x02h R\x18prevTokenTransactionHash\x12=\n" +
	"\x1bprev_token_transaction_vout\x18\x02 \x01(\rR\x18prevTokenTransactionVout\"_\n" +
	"\x12TokenTransferInput\x12I\n" +
	"\x10outputs_to_spend\x18\x01 \x03(\v2\x1f.spark_token.TokenOutputToSpendR\x0eoutputsToSpend\"\x93\x01\n" +
	"\x0eTokenMintInput\x123\n" +
	"\x11issuer_public_key\x18\x01 \x01(\fB\a\xfaB\x04z\x02h!R\x0fissuerPublicKey\x127\n" +
	"\x10token_identifier\x18\x02 \x01(\fB\a\xfaB\x04z\x02h H\x00R\x0ftokenIdentifier\x88\x01\x01B\x13\n" +
	"\x11_token_identifier\"\xf6\x02\n" +
	"\x10TokenCreateInput\x123\n" +
	"\x11issuer_public_key\x18\x01 \x01(\fB\a\xfaB\x04z\x02h!R\x0fissuerPublicKey\x12&\n" +
	"\n" +
	"token_name\x18\x02 \x01(\tB\a\xfaB\x04r\x02\x18\x14R\ttokenName\x12*\n" +
	"\ftoken_ticker\x18\x03 \x01(\tB\a\xfaB\x04r\x02\x18\x06R\vtokenTicker\x12$\n" +
	"\bdecimals\x18\x04 \x01(\rB\b\xfaB\x05*\x03\x18\xff\x01R\bdecimals\x12&\n" +
	"\n" +
	"max_supply\x18\x05 \x01(\fB\a\xfaB\x04z\x02h\x10R\tmaxSupply\x12!\n" +
	"\fis_freezable\x18\x06 \x01(\bR\visFreezable\x12I\n" +
	"\x1acreation_entity_public_key\x18\a \x01(\fB\a\xfaB\x04z\x02h!H\x00R\x17creationEntityPublicKey\x88\x01\x01B\x1d\n" +
	"\x1b_creation_entity_public_key\"\xc7\x04\n" +
	"\vTokenOutput\x12\x1d\n" +
	"\x02id\x18\x01 \x01(\tB\b\xfaB\x05r\x03\xb0\x01\x01H\x00R\x02id\x88\x01\x01\x121\n" +
	"\x10owner_public_key\x18\x02 \x01(\fB\a\xfaB\x04z\x02h!R\x0eownerPublicKey\x12A\n" +
	"\x15revocation_commitment\x18\x03 \x01(\fB\a\xfaB\x04z\x02h!H\x01R\x14revocationCommitment\x88\x01\x01\x121\n" +
	"\x12withdraw_bond_sats\x18\x04 \x01(\x04H\x02R\x10withdrawBondSats\x88\x01\x01\x12L\n" +
	" withdraw_relative_block_locktime\x18\x05 \x01(\x04H\x03R\x1dwithdrawRelativeBlockLocktime\x88\x01\x01\x126\n" +
	"\x10token_public_key\x18\x06 \x01(\fB\a\xfaB\x04z\x02h!H\x04R\x0etokenPublicKey\x88\x01\x01\x127\n" +
	"\x10token_identifier\x18\b \x01(\fB\a\xfaB\x04z\x02h H\x05R\x0ftokenIdentifier\x88\x01\x01\x12*\n" +
	"\ftoken_amount\x18\a \x01(\fB\a\xfaB\x04z\x02h\x10R\vtokenAmountB\x05\n" +
	"\x03_idB\x18\n" +
	"\x16_revocation_commitmentB\x15\n" +
	"\x13_withdraw_bond_satsB#\n" +
	"!_withdraw_relative_block_locktimeB\x13\n" +
	"\x11_token_public_keyB\x13\n" +
	"\x11_token_identifier\"\xbb\x05\n" +
	"\x10TokenTransaction\x12\x18\n" +
	"\aversion\x18\x01 \x01(\rR\aversion\x12<\n" +
	"\n" +
	"mint_input\x18\x02 \x01(\v2\x1b.spark_token.TokenMintInputH\x00R\tmintInput\x12H\n" +
	"\x0etransfer_input\x18\x03 \x01(\v2\x1f.spark_token.TokenTransferInputH\x00R\rtransferInput\x12B\n" +
	"\fcreate_input\x18\b \x01(\v2\x1d.spark_token.TokenCreateInputH\x00R\vcreateInput\x12=\n" +
	"\rtoken_outputs\x18\x04 \x03(\v2\x18.spark_token.TokenOutputR\ftokenOutputs\x12Z\n" +
	"#spark_operator_identity_public_keys\x18\x05 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x1fsparkOperatorIdentityPublicKeys\x12;\n" +
	"\vexpiry_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"expiryTime\x122\n" +
	"\anetwork\x18\a \x01(\x0e2\x0e.spark.NetworkB\b\xfaB\x05\x82\x01\x02 \x00R\anetwork\x12T\n" +
	"\x18client_created_timestamp\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\x16clientCreatedTimestamp\x12O\n" +
	"\x13invoice_attachments\x18\n" +
	" \x03(\v2\x1e.spark_token.InvoiceAttachmentR\x12invoiceAttachmentsB\x0e\n" +
	"\ftoken_inputs\"8\n" +
	"\x11InvoiceAttachment\x12#\n" +
	"\rspark_invoice\x18\x01 \x01(\tR\fsparkInvoice\"^\n" +
	"\x12SignatureWithIndex\x12'\n" +
	"\tsignature\x18\x01 \x01(\fB\t\xfaB\x06z\x04\x10@\x18IR\tsignature\x12\x1f\n" +
	"\vinput_index\x18\x02 \x01(\rR\n" +
	"inputIndex\"\xb4\x01\n" +
	"\x1eInputTtxoSignaturesPerOperator\x12H\n" +
	"\x0fttxo_signatures\x18\x01 \x03(\v2\x1f.spark_token.SignatureWithIndexR\x0ettxoSignatures\x12H\n" +
	"\x1coperator_identity_public_key\x18\x02 \x01(\fB\a\xfaB\x04z\x02h!R\x19operatorIdentityPublicKey\"\xf2\x02\n" +
	"\x17StartTransactionRequest\x127\n" +
	"\x13identity_public_key\x18\x01 \x01(\fB\a\xfaB\x04z\x02h!R\x11identityPublicKey\x12Y\n" +
	"\x19partial_token_transaction\x18\x02 \x01(\v2\x1d.spark_token.TokenTransactionR\x17partialTokenTransaction\x12{\n" +
	"*partial_token_transaction_owner_signatures\x18\x03 \x03(\v2\x1f.spark_token.SignatureWithIndexR&partialTokenTransactionOwnerSignatures\x12F\n" +
	"\x19validity_duration_seconds\x18\x04 \x01(\x04B\n" +
	"\xfaB\a2\x05\x18\xac\x02(\x01R\x17validityDurationSeconds\"\xae\x01\n" +
	"\x18StartTransactionResponse\x12U\n" +
	"\x17final_token_transaction\x18\x01 \x01(\v2\x1d.spark_token.TokenTransactionR\x15finalTokenTransaction\x12;\n" +
	"\rkeyshare_info\x18\x02 \x01(\v2\x16.spark.SigningKeyshareR\fkeyshareInfo\"\xf8\x02\n" +
	"\x18CommitTransactionRequest\x12U\n" +
	"\x17final_token_transaction\x18\x01 \x01(\v2\x1d.spark_token.TokenTransactionR\x15finalTokenTransaction\x12H\n" +
	"\x1cfinal_token_transaction_hash\x18\x02 \x01(\fB\a\xfaB\x04z\x02h R\x19finalTokenTransactionHash\x12w\n" +
	"\"input_ttxo_signatures_per_operator\x18\x03 \x03(\v2+.spark_token.InputTtxoSignaturesPerOperatorR\x1einputTtxoSignaturesPerOperator\x12B\n" +
	"\x19owner_identity_public_key\x18\x04 \x01(\fB\a\xfaB\x04z\x02h!R\x16ownerIdentityPublicKey\"\xba\x01\n" +
	"\x0eCommitProgress\x12Q\n" +
	"\x1ecommitted_operator_public_keys\x18\x01 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x1bcommittedOperatorPublicKeys\x12U\n" +
	" uncommitted_operator_public_keys\x18\x02 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x1duncommittedOperatorPublicKeys\"\xa1\x01\n" +
	"\x19CommitTransactionResponse\x12>\n" +
	"\rcommit_status\x18\x01 \x01(\x0e2\x19.spark_token.CommitStatusR\fcommitStatus\x12D\n" +
	"\x0fcommit_progress\x18\x02 \x01(\v2\x1b.spark_token.CommitProgressR\x0ecommitProgress\"\x92\x01\n" +
	"\x19QueryTokenMetadataRequest\x129\n" +
	"\x11token_identifiers\x18\x01 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h R\x10tokenIdentifiers\x12:\n" +
	"\x12issuer_public_keys\x18\x02 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x10issuerPublicKeys\"\xa7\x03\n" +
	"\rTokenMetadata\x123\n" +
	"\x11issuer_public_key\x18\x01 \x01(\fB\a\xfaB\x04z\x02h!R\x0fissuerPublicKey\x12&\n" +
	"\n" +
	"token_name\x18\x02 \x01(\tB\a\xfaB\x04r\x02\x18\x14R\ttokenName\x12*\n" +
	"\ftoken_ticker\x18\x03 \x01(\tB\a\xfaB\x04r\x02\x18\x06R\vtokenTicker\x12$\n" +
	"\bdecimals\x18\x04 \x01(\rB\b\xfaB\x05*\x03\x18\xff\x01R\bdecimals\x12&\n" +
	"\n" +
	"max_supply\x18\x05 \x01(\fB\a\xfaB\x04z\x02h\x10R\tmaxSupply\x12!\n" +
	"\fis_freezable\x18\x06 \x01(\bR\visFreezable\x12I\n" +
	"\x1acreation_entity_public_key\x18\a \x01(\fB\a\xfaB\x04z\x02h!H\x00R\x17creationEntityPublicKey\x88\x01\x01\x122\n" +
	"\x10token_identifier\x18\b \x01(\fB\a\xfaB\x04z\x02h R\x0ftokenIdentifierB\x1d\n" +
	"\x1b_creation_entity_public_key\"_\n" +
	"\x1aQueryTokenMetadataResponse\x12A\n" +
	"\x0etoken_metadata\x18\x01 \x03(\v2\x1a.spark_token.TokenMetadataR\rtokenMetadata\"\xac\x02\n" +
	"\x18QueryTokenOutputsRequest\x128\n" +
	"\x11owner_public_keys\x18\x01 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x0fownerPublicKeys\x12:\n" +
	"\x12issuer_public_keys\x18\x02 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x10issuerPublicKeys\x129\n" +
	"\x11token_identifiers\x18\x04 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h R\x10tokenIdentifiers\x12(\n" +
	"\anetwork\x18\x03 \x01(\x0e2\x0e.spark.NetworkR\anetwork\x125\n" +
	"\fpage_request\x18\x05 \x01(\v2\x12.spark.PageRequestR\vpageRequest\"\xf4\x02\n" +
	"\x1dQueryTokenTransactionsRequest\x12,\n" +
	"\n" +
	"output_ids\x18\x01 \x03(\tB\r\xfaB\n" +
	"\x92\x01\a\"\x05r\x03\xb0\x01\x01R\toutputIds\x128\n" +
	"\x11owner_public_keys\x18\x02 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x0fownerPublicKeys\x12:\n" +
	"\x12issuer_public_keys\x18\x03 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x10issuerPublicKeys\x129\n" +
	"\x11token_identifiers\x18\a \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h R\x10tokenIdentifiers\x12F\n" +
	"\x18token_transaction_hashes\x18\x04 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h R\x16tokenTransactionHashes\x12\x14\n" +
	"\x05limit\x18\x05 \x01(\x03R\x05limit\x12\x16\n" +
	"\x06offset\x18\x06 \x01(\x03R\x06offset\"\xa6\x01\n" +
	"\x1eQueryTokenTransactionsResponse\x12l\n" +
	"\x1etoken_transactions_with_status\x18\x01 \x03(\v2'.spark_token.TokenTransactionWithStatusR\x1btokenTransactionsWithStatus\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x03R\x06offset\"\xd6\x01\n" +
	"!OutputWithPreviousTransactionData\x120\n" +
	"\x06output\x18\x01 \x01(\v2\x18.spark_token.TokenOutputR\x06output\x12C\n" +
	"\x19previous_transaction_hash\x18\x02 \x01(\fB\a\xfaB\x04z\x02h R\x17previousTransactionHash\x12:\n" +
	"\x19previous_transaction_vout\x18\x03 \x01(\rR\x17previousTransactionVout\"\xda\x01\n" +
	"\x19QueryTokenOutputsResponse\x12\x82\x01\n" +
	"&outputs_with_previous_transaction_data\x18\x01 \x03(\v2..spark_token.OutputWithPreviousTransactionDataR\"outputsWithPreviousTransactionData\x128\n" +
	"\rpage_response\x18\x02 \x01(\v2\x13.spark.PageResponseR\fpageResponse\"d\n" +
	"\x18SpentTokenOutputMetadata\x12\x1b\n" +
	"\toutput_id\x18\x01 \x01(\tR\boutputId\x12+\n" +
	"\x11revocation_secret\x18\x02 \x01(\fR\x10revocationSecret\"\x8e\x01\n" +
	"$TokenTransactionConfirmationMetadata\x12f\n" +
	"\x1cspent_token_outputs_metadata\x18\x01 \x03(\v2%.spark_token.SpentTokenOutputMetadataR\x19spentTokenOutputsMetadata\"\xcc\x02\n" +
	"\x1aTokenTransactionWithStatus\x12J\n" +
	"\x11token_transaction\x18\x01 \x01(\v2\x1d.spark_token.TokenTransactionR\x10tokenTransaction\x12;\n" +
	"\x06status\x18\x02 \x01(\x0e2#.spark_token.TokenTransactionStatusR\x06status\x12f\n" +
	"\x15confirmation_metadata\x18\x03 \x01(\v21.spark_token.TokenTransactionConfirmationMetadataR\x14confirmationMetadata\x12=\n" +
	"\x16token_transaction_hash\x18\x04 \x01(\fB\a\xfaB\x04z\x02h R\x14tokenTransactionHash\"\xac\x03\n" +
	"\x13FreezeTokensPayload\x12\x18\n" +
	"\aversion\x18\x01 \x01(\rR\aversion\x121\n" +
	"\x10owner_public_key\x18\x02 \x01(\fB\a\xfaB\x04z\x02h!R\x0eownerPublicKey\x126\n" +
	"\x10token_public_key\x18\x03 \x01(\fB\a\xfaB\x04z\x02h!H\x00R\x0etokenPublicKey\x88\x01\x01\x127\n" +
	"\x10token_identifier\x18\x04 \x01(\fB\a\xfaB\x04z\x02h H\x01R\x0ftokenIdentifier\x88\x01\x01\x12:\n" +
	"\x19issuer_provided_timestamp\x18\x05 \x01(\x04R\x17issuerProvidedTimestamp\x12H\n" +
	"\x1coperator_identity_public_key\x18\x06 \x01(\fB\a\xfaB\x04z\x02h!R\x19operatorIdentityPublicKey\x12'\n" +
	"\x0fshould_unfreeze\x18\a \x01(\bR\x0eshouldUnfreezeB\x13\n" +
	"\x11_token_public_keyB\x13\n" +
	"\x11_token_identifier\"\xa1\x01\n" +
	"\x13FreezeTokensRequest\x12T\n" +
	"\x15freeze_tokens_payload\x18\x01 \x01(\v2 .spark_token.FreezeTokensPayloadR\x13freezeTokensPayload\x124\n" +
	"\x10issuer_signature\x18\x02 \x01(\fB\t\xfaB\x06z\x04\x10@\x18IR\x0fissuerSignature\"\x89\x01\n" +
	"\x14FreezeTokensResponse\x12=\n" +
	"\x13impacted_output_ids\x18\x01 \x03(\tB\r\xfaB\n" +
	"\x92\x01\a\"\x05r\x03\xb0\x01\x01R\x11impactedOutputIds\x122\n" +
	"\x15impacted_token_amount\x18\x02 \x01(\fR\x13impactedTokenAmount*\xa7\x01\n" +
	"\x14TokenTransactionType\x12&\n" +
	"\"TOKEN_TRANSACTION_TYPE_UNSPECIFIED\x10\x00\x12!\n" +
	"\x1dTOKEN_TRANSACTION_TYPE_CREATE\x10\x01\x12\x1f\n" +
	"\x1bTOKEN_TRANSACTION_TYPE_MINT\x10\x02\x12#\n" +
	"\x1fTOKEN_TRANSACTION_TYPE_TRANSFER\x10\x03*S\n" +
	"\fCommitStatus\x12\x16\n" +
	"\x12COMMIT_UNSPECIFIED\x10\x00\x12\x15\n" +
	"\x11COMMIT_PROCESSING\x10\x01\x12\x14\n" +
	"\x10COMMIT_FINALIZED\x10\x02*\x86\x02\n" +
	"\x16TokenTransactionStatus\x12\x1d\n" +
	"\x19TOKEN_TRANSACTION_STARTED\x10\x00\x12\x1c\n" +
	"\x18TOKEN_TRANSACTION_SIGNED\x10\x01\x12\x1e\n" +
	"\x1aTOKEN_TRANSACTION_REVEALED\x10\x05\x12\x1f\n" +
	"\x1bTOKEN_TRANSACTION_FINALIZED\x10\x02\x12'\n" +
	"#TOKEN_TRANSACTION_STARTED_CANCELLED\x10\x03\x12&\n" +
	"\"TOKEN_TRANSACTION_SIGNED_CANCELLED\x10\x04\x12\x1d\n" +
	"\x19TOKEN_TRANSACTION_UNKNOWN\x10\n" +
	"2\x80\x05\n" +
	"\x11SparkTokenService\x12b\n" +
	"\x11start_transaction\x12$.spark_token.StartTransactionRequest\x1a%.spark_token.StartTransactionResponse\"\x00\x12e\n" +
	"\x12commit_transaction\x12%.spark_token.CommitTransactionRequest\x1a&.spark_token.CommitTransactionResponse\"\x00\x12i\n" +
	"\x14query_token_metadata\x12&.spark_token.QueryTokenMetadataRequest\x1a'.spark_token.QueryTokenMetadataResponse\"\x00\x12u\n" +
	"\x18query_token_transactions\x12*.spark_token.QueryTokenTransactionsRequest\x1a+.spark_token.QueryTokenTransactionsResponse\"\x00\x12f\n" +
	"\x13query_token_outputs\x12%.spark_token.QueryTokenOutputsRequest\x1a&.spark_token.QueryTokenOutputsResponse\"\x00\x12V\n" +
	"\rfreeze_tokens\x12 .spark_token.FreezeTokensRequest\x1a!.spark_token.FreezeTokensResponse\"\x00B2Z0github.com/lightsparkdev/spark/proto/spark_tokenb\x06proto3"

var (
	file_spark_token_proto_rawDescOnce sync.Once
	file_spark_token_proto_rawDescData []byte
)

func file_spark_token_proto_rawDescGZIP() []byte {
	file_spark_token_proto_rawDescOnce.Do(func() {
		file_spark_token_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_spark_token_proto_rawDesc), len(file_spark_token_proto_rawDesc)))
	})
	return file_spark_token_proto_rawDescData
}

var file_spark_token_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_spark_token_proto_msgTypes = make([]protoimpl.MessageInfo, 28)
var file_spark_token_proto_goTypes = []any{
	(TokenTransactionType)(0),                    // 0: spark_token.TokenTransactionType
	(CommitStatus)(0),                            // 1: spark_token.CommitStatus
	(TokenTransactionStatus)(0),                  // 2: spark_token.TokenTransactionStatus
	(*TokenOutputToSpend)(nil),                   // 3: spark_token.TokenOutputToSpend
	(*TokenTransferInput)(nil),                   // 4: spark_token.TokenTransferInput
	(*TokenMintInput)(nil),                       // 5: spark_token.TokenMintInput
	(*TokenCreateInput)(nil),                     // 6: spark_token.TokenCreateInput
	(*TokenOutput)(nil),                          // 7: spark_token.TokenOutput
	(*TokenTransaction)(nil),                     // 8: spark_token.TokenTransaction
	(*InvoiceAttachment)(nil),                    // 9: spark_token.InvoiceAttachment
	(*SignatureWithIndex)(nil),                   // 10: spark_token.SignatureWithIndex
	(*InputTtxoSignaturesPerOperator)(nil),       // 11: spark_token.InputTtxoSignaturesPerOperator
	(*StartTransactionRequest)(nil),              // 12: spark_token.StartTransactionRequest
	(*StartTransactionResponse)(nil),             // 13: spark_token.StartTransactionResponse
	(*CommitTransactionRequest)(nil),             // 14: spark_token.CommitTransactionRequest
	(*CommitProgress)(nil),                       // 15: spark_token.CommitProgress
	(*CommitTransactionResponse)(nil),            // 16: spark_token.CommitTransactionResponse
	(*QueryTokenMetadataRequest)(nil),            // 17: spark_token.QueryTokenMetadataRequest
	(*TokenMetadata)(nil),                        // 18: spark_token.TokenMetadata
	(*QueryTokenMetadataResponse)(nil),           // 19: spark_token.QueryTokenMetadataResponse
	(*QueryTokenOutputsRequest)(nil),             // 20: spark_token.QueryTokenOutputsRequest
	(*QueryTokenTransactionsRequest)(nil),        // 21: spark_token.QueryTokenTransactionsRequest
	(*QueryTokenTransactionsResponse)(nil),       // 22: spark_token.QueryTokenTransactionsResponse
	(*OutputWithPreviousTransactionData)(nil),    // 23: spark_token.OutputWithPreviousTransactionData
	(*QueryTokenOutputsResponse)(nil),            // 24: spark_token.QueryTokenOutputsResponse
	(*SpentTokenOutputMetadata)(nil),             // 25: spark_token.SpentTokenOutputMetadata
	(*TokenTransactionConfirmationMetadata)(nil), // 26: spark_token.TokenTransactionConfirmationMetadata
	(*TokenTransactionWithStatus)(nil),           // 27: spark_token.TokenTransactionWithStatus
	(*FreezeTokensPayload)(nil),                  // 28: spark_token.FreezeTokensPayload
	(*FreezeTokensRequest)(nil),                  // 29: spark_token.FreezeTokensRequest
	(*FreezeTokensResponse)(nil),                 // 30: spark_token.FreezeTokensResponse
	(*timestamppb.Timestamp)(nil),                // 31: google.protobuf.Timestamp
	(spark.Network)(0),                           // 32: spark.Network
	(*spark.SigningKeyshare)(nil),                // 33: spark.SigningKeyshare
	(*spark.PageRequest)(nil),                    // 34: spark.PageRequest
	(*spark.PageResponse)(nil),                   // 35: spark.PageResponse
}
var file_spark_token_proto_depIdxs = []int32{
	3,  // 0: spark_token.TokenTransferInput.outputs_to_spend:type_name -> spark_token.TokenOutputToSpend
	5,  // 1: spark_token.TokenTransaction.mint_input:type_name -> spark_token.TokenMintInput
	4,  // 2: spark_token.TokenTransaction.transfer_input:type_name -> spark_token.TokenTransferInput
	6,  // 3: spark_token.TokenTransaction.create_input:type_name -> spark_token.TokenCreateInput
	7,  // 4: spark_token.TokenTransaction.token_outputs:type_name -> spark_token.TokenOutput
	31, // 5: spark_token.TokenTransaction.expiry_time:type_name -> google.protobuf.Timestamp
	32, // 6: spark_token.TokenTransaction.network:type_name -> spark.Network
	31, // 7: spark_token.TokenTransaction.client_created_timestamp:type_name -> google.protobuf.Timestamp
	9,  // 8: spark_token.TokenTransaction.invoice_attachments:type_name -> spark_token.InvoiceAttachment
	10, // 9: spark_token.InputTtxoSignaturesPerOperator.ttxo_signatures:type_name -> spark_token.SignatureWithIndex
	8,  // 10: spark_token.StartTransactionRequest.partial_token_transaction:type_name -> spark_token.TokenTransaction
	10, // 11: spark_token.StartTransactionRequest.partial_token_transaction_owner_signatures:type_name -> spark_token.SignatureWithIndex
	8,  // 12: spark_token.StartTransactionResponse.final_token_transaction:type_name -> spark_token.TokenTransaction
	33, // 13: spark_token.StartTransactionResponse.keyshare_info:type_name -> spark.SigningKeyshare
	8,  // 14: spark_token.CommitTransactionRequest.final_token_transaction:type_name -> spark_token.TokenTransaction
	11, // 15: spark_token.CommitTransactionRequest.input_ttxo_signatures_per_operator:type_name -> spark_token.InputTtxoSignaturesPerOperator
	1,  // 16: spark_token.CommitTransactionResponse.commit_status:type_name -> spark_token.CommitStatus
	15, // 17: spark_token.CommitTransactionResponse.commit_progress:type_name -> spark_token.CommitProgress
	18, // 18: spark_token.QueryTokenMetadataResponse.token_metadata:type_name -> spark_token.TokenMetadata
	32, // 19: spark_token.QueryTokenOutputsRequest.network:type_name -> spark.Network
	34, // 20: spark_token.QueryTokenOutputsRequest.page_request:type_name -> spark.PageRequest
	27, // 21: spark_token.QueryTokenTransactionsResponse.token_transactions_with_status:type_name -> spark_token.TokenTransactionWithStatus
	7,  // 22: spark_token.OutputWithPreviousTransactionData.output:type_name -> spark_token.TokenOutput
	23, // 23: spark_token.QueryTokenOutputsResponse.outputs_with_previous_transaction_data:type_name -> spark_token.OutputWithPreviousTransactionData
	35, // 24: spark_token.QueryTokenOutputsResponse.page_response:type_name -> spark.PageResponse
	25, // 25: spark_token.TokenTransactionConfirmationMetadata.spent_token_outputs_metadata:type_name -> spark_token.SpentTokenOutputMetadata
	8,  // 26: spark_token.TokenTransactionWithStatus.token_transaction:type_name -> spark_token.TokenTransaction
	2,  // 27: spark_token.TokenTransactionWithStatus.status:type_name -> spark_token.TokenTransactionStatus
	26, // 28: spark_token.TokenTransactionWithStatus.confirmation_metadata:type_name -> spark_token.TokenTransactionConfirmationMetadata
	28, // 29: spark_token.FreezeTokensRequest.freeze_tokens_payload:type_name -> spark_token.FreezeTokensPayload
	12, // 30: spark_token.SparkTokenService.start_transaction:input_type -> spark_token.StartTransactionRequest
	14, // 31: spark_token.SparkTokenService.commit_transaction:input_type -> spark_token.CommitTransactionRequest
	17, // 32: spark_token.SparkTokenService.query_token_metadata:input_type -> spark_token.QueryTokenMetadataRequest
	21, // 33: spark_token.SparkTokenService.query_token_transactions:input_type -> spark_token.QueryTokenTransactionsRequest
	20, // 34: spark_token.SparkTokenService.query_token_outputs:input_type -> spark_token.QueryTokenOutputsRequest
	29, // 35: spark_token.SparkTokenService.freeze_tokens:input_type -> spark_token.FreezeTokensRequest
	13, // 36: spark_token.SparkTokenService.start_transaction:output_type -> spark_token.StartTransactionResponse
	16, // 37: spark_token.SparkTokenService.commit_transaction:output_type -> spark_token.CommitTransactionResponse
	19, // 38: spark_token.SparkTokenService.query_token_metadata:output_type -> spark_token.QueryTokenMetadataResponse
	22, // 39: spark_token.SparkTokenService.query_token_transactions:output_type -> spark_token.QueryTokenTransactionsResponse
	24, // 40: spark_token.SparkTokenService.query_token_outputs:output_type -> spark_token.QueryTokenOutputsResponse
	30, // 41: spark_token.SparkTokenService.freeze_tokens:output_type -> spark_token.FreezeTokensResponse
	36, // [36:42] is the sub-list for method output_type
	30, // [30:36] is the sub-list for method input_type
	30, // [30:30] is the sub-list for extension type_name
	30, // [30:30] is the sub-list for extension extendee
	0,  // [0:30] is the sub-list for field type_name
}

func init() { file_spark_token_proto_init() }
func file_spark_token_proto_init() {
	if File_spark_token_proto != nil {
		return
	}
	file_spark_token_proto_msgTypes[2].OneofWrappers = []any{}
	file_spark_token_proto_msgTypes[3].OneofWrappers = []any{}
	file_spark_token_proto_msgTypes[4].OneofWrappers = []any{}
	file_spark_token_proto_msgTypes[5].OneofWrappers = []any{
		(*TokenTransaction_MintInput)(nil),
		(*TokenTransaction_TransferInput)(nil),
		(*TokenTransaction_CreateInput)(nil),
	}
	file_spark_token_proto_msgTypes[15].OneofWrappers = []any{}
	file_spark_token_proto_msgTypes[25].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_spark_token_proto_rawDesc), len(file_spark_token_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   28,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_spark_token_proto_goTypes,
		DependencyIndexes: file_spark_token_proto_depIdxs,
		EnumInfos:         file_spark_token_proto_enumTypes,
		MessageInfos:      file_spark_token_proto_msgTypes,
	}.Build()
	File_spark_token_proto = out.File
	file_spark_token_proto_goTypes = nil
	file_spark_token_proto_depIdxs = nil
}
