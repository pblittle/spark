syntax = "proto3";

package spark;

option go_package = "github.com/lightsparkdev/spark/proto/spark";
import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "validate/validate.proto";
import "common.proto";

service SparkService {
    rpc generate_deposit_address(GenerateDepositAddressRequest) returns (GenerateDepositAddressResponse) {}

    // Generates a new static deposit address of the user or returns the existing one for the specified network.
    rpc generate_static_deposit_address(GenerateStaticDepositAddressRequest) returns (GenerateStaticDepositAddressResponse) {}

    rpc start_deposit_tree_creation(StartDepositTreeCreationRequest) returns (StartDepositTreeCreationResponse) {}
    // This is deprecated, please use start_deposit_tree_creation instead.
    rpc start_tree_creation(StartTreeCreationRequest) returns (StartTreeCreationResponse) {
        option deprecated = true;
    }
    rpc finalize_node_signatures(FinalizeNodeSignaturesRequest) returns (FinalizeNodeSignaturesResponse) {}

    rpc start_transfer(StartTransferRequest) returns (StartTransferResponse) {}
    // This is deprecated, please use finalize_transfer_with_transfer_package instead.
    rpc finalize_transfer(FinalizeTransferRequest) returns (FinalizeTransferResponse) {
        option deprecated = true;
    }
    rpc finalize_transfer_with_transfer_package(FinalizeTransferWithTransferPackageRequest) returns (FinalizeTransferResponse) {}
    rpc cancel_transfer(CancelTransferRequest) returns (CancelTransferResponse) {}

    rpc query_pending_transfers(TransferFilter) returns (QueryTransfersResponse) {}
    rpc query_all_transfers(TransferFilter) returns (QueryTransfersResponse) {}
    rpc claim_transfer_tweak_keys(ClaimTransferTweakKeysRequest) returns (google.protobuf.Empty) {}
    rpc claim_transfer_sign_refunds(ClaimTransferSignRefundsRequest) returns (ClaimTransferSignRefundsResponse) {}
    rpc store_preimage_share(StorePreimageShareRequest) returns (google.protobuf.Empty) {}
    rpc get_signing_commitments(GetSigningCommitmentsRequest) returns (GetSigningCommitmentsResponse) {}
    rpc cooperative_exit(CooperativeExitRequest) returns (CooperativeExitResponse) {}
    rpc initiate_preimage_swap(InitiatePreimageSwapRequest) returns (InitiatePreimageSwapResponse) {}
    rpc provide_preimage(ProvidePreimageRequest) returns (ProvidePreimageResponse) {}
    // This is the exact same as start_transfer, but expresses to the SO
    // this transfer is specifically for a leaf swap.
    rpc start_leaf_swap(StartTransferRequest) returns (StartTransferResponse) {}
    // This is deprecated, please use counter_leaf_swap instead.
    rpc leaf_swap(CounterLeafSwapRequest) returns (CounterLeafSwapResponse) {
        option deprecated = true;
    }
    // This is the exact same as start_leaf_swap, but signs with
    // an adaptor public key after a counterparty has begun the swap via start_leaf_swap.
    rpc counter_leaf_swap(CounterLeafSwapRequest) returns (CounterLeafSwapResponse) {}
    rpc refresh_timelock(RefreshTimelockRequest) returns (RefreshTimelockResponse) {}
    rpc extend_leaf(ExtendLeafRequest) returns (ExtendLeafResponse) {}

    rpc get_signing_operator_list(google.protobuf.Empty) returns (GetSigningOperatorListResponse) {}

    rpc query_nodes(QueryNodesRequest) returns (QueryNodesResponse) {}
    rpc query_nodes_distribution(QueryNodesDistributionRequest) returns (QueryNodesDistributionResponse) {}
    rpc query_nodes_by_value(QueryNodesByValueRequest) returns (QueryNodesByValueResponse) {}

    rpc query_balance(QueryBalanceRequest) returns (QueryBalanceResponse) {}

    rpc query_user_signed_refunds(QueryUserSignedRefundsRequest) returns (QueryUserSignedRefundsResponse) {}

    // Token RPCs
    rpc start_token_transaction(StartTokenTransactionRequest) returns (StartTokenTransactionResponse) {}
    rpc sign_token_transaction(SignTokenTransactionRequest) returns (SignTokenTransactionResponse) {}
    rpc finalize_token_transaction(FinalizeTokenTransactionRequest) returns (google.protobuf.Empty) {}
    rpc freeze_tokens(FreezeTokensRequest) returns (FreezeTokensResponse) {}
    rpc query_token_outputs(QueryTokenOutputsRequest) returns (QueryTokenOutputsResponse) {}
    rpc query_token_transactions(QueryTokenTransactionsRequest) returns (QueryTokenTransactionsResponse) {}

    rpc return_lightning_payment(ReturnLightningPaymentRequest) returns (google.protobuf.Empty) {}


    rpc query_unused_deposit_addresses(QueryUnusedDepositAddressesRequest) returns (QueryUnusedDepositAddressesResponse) {}
    rpc query_static_deposit_addresses(QueryStaticDepositAddressesRequest) returns (QueryStaticDepositAddressesResponse) {}

    rpc subscribe_to_events(SubscribeToEventsRequest) returns (stream SubscribeToEventsResponse) {}

    // Signs the provided refund transaction which spends the UTXO from a static
    // deposit address. If successful, the UTXO will no longer be available to claim on
    // the Spark network, and the refund transaction must be broadcasted on L1 to claim
    // the funds. Returns an error if the UTXO has already been claimed.
    rpc initiate_static_deposit_utxo_refund(InitiateStaticDepositUtxoRefundRequest) returns (InitiateStaticDepositUtxoRefundResponse) {}

    // DEPRECATED: This unified method is being split for better clarity and type safety
    // 
    // For swap operations: Use spark_ssp_internal.initiate_static_deposit_utxo_swap()
    // For refund operations: Use initiate_static_deposit_utxo_refund()
    rpc initiate_utxo_swap(InitiateUtxoSwapRequest) returns (InitiateUtxoSwapResponse) {
        option deprecated = true;
    }

    rpc exit_single_node_trees(ExitSingleNodeTreesRequest) returns (ExitSingleNodeTreesResponse) {}

    // The following endpoints enforce inclusion of Direct Transactions used
    // for unilateral exits
    rpc cooperative_exit_v2(CooperativeExitRequest) returns (CooperativeExitResponse) {}
    rpc extend_leaf_v2(ExtendLeafRequest) returns (ExtendLeafResponse) {}
    rpc claim_transfer_sign_refunds_v2(ClaimTransferSignRefundsRequest) returns (ClaimTransferSignRefundsResponse) {}
    rpc finalize_node_signatures_v2(FinalizeNodeSignaturesRequest) returns (FinalizeNodeSignaturesResponse) {}
    rpc initiate_preimage_swap_v2(InitiatePreimageSwapRequest) returns (InitiatePreimageSwapResponse) {}
    rpc start_leaf_swap_v2(StartTransferRequest) returns (StartTransferResponse) {}
    rpc counter_leaf_swap_v2(CounterLeafSwapRequest) returns (CounterLeafSwapResponse) {}
    rpc start_transfer_v2(StartTransferRequest) returns (StartTransferResponse) {}
    rpc refresh_timelock_v2(RefreshTimelockRequest) returns (RefreshTimelockResponse) {}

    rpc get_utxos_for_address(GetUtxosForAddressRequest) returns (GetUtxosForAddressResponse) {}

    rpc query_spark_invoices(QuerySparkInvoicesRequest) returns (QuerySparkInvoicesResponse) {}
}

message SubscribeToEventsRequest {
    bytes identity_public_key = 10;
}

message SubscribeToEventsResponse {
    oneof event {
        TransferEvent transfer = 1;
        DepositEvent deposit = 2;
        ConnectedEvent connected = 3;
    }
}

message ConnectedEvent { }

message TransferEvent {
    Transfer transfer = 10;
}

message DepositEvent {
    TreeNode deposit = 10;
}

/**
 * Network is the network type of the bitcoin network.
 */
enum Network {
    UNSPECIFIED = 0;
    MAINNET = 1;
    REGTEST = 2;
    TESTNET = 3;
    SIGNET = 4;
}

message PageRequest {
    int32 page_size = 1;
    string cursor = 2;
    Direction direction = 3;
}

enum Direction {
    NEXT = 0;
    PREVIOUS = 1;
}

message PageResponse {
    bool has_next_page = 1;
    bool has_previous_page = 2;
    string next_cursor = 3;
    string previous_cursor = 4;
}

/**
 * DepositAddressProof is the proof of possession of the deposit address.
 * When a user wants to generate a deposit address, they are sending their public key to the SE,
 * and the SE will respond with an address of user's public key + SE's public key.
 *
 * In the trusty deposit flow, user will need to know that this address is valid, and no single SE
 * can generate this address.
 *
 * The SE will need to sign the address with their identity keys, and have a proof of possession of
 * the signing key piece that the SE holds.
 */
message DepositAddressProof {
    // The signatures of the address by the SE's identity keys.
    map<string, bytes> address_signatures = 1;
    // The proof of possession of the signing key piece by the SE.
    bytes proof_of_possession_signature = 2;
}

/**
 * GenerateDepositAddressRequest is the request to generate a deposit address.
 * The user will send their public key to the SE, and the SE will respond with an address of user's
 * public key + SE's public key.
 */
message GenerateDepositAddressRequest {
    // The signing public key of the user.
    bytes signing_public_key = 1;
    // The identity public key of the user.
    bytes identity_public_key = 2;
    // The network of the bitcoin network.
    Network network = 3 [(validate.rules).enum = {not_in: [0]}];
    // The UUID to use for the created TreeNode
    optional string leaf_id = 4 [(validate.rules).string.uuid = true];
    // Generate static deposit address
    optional bool is_static = 5;
}

/**
 * Address is the address of the user's public key + SE's public key.
 */
message Address {
    // The p2tr address of the user's public key + SE's public key.
    string address = 1;
    // The verifying key of the address, which is user's public key + SE's public key.
    bytes verifying_key = 2;
    // The proof of possession of the address by the SE.
    DepositAddressProof deposit_address_proof = 3;
    // Is it a static deposit address
    bool is_static = 5;
}

/**
 * GenerateDepositAddressResponse is the response to the request to generate a deposit address.
 */
message GenerateDepositAddressResponse {
    Address deposit_address = 1;
}

/**
 * GenerateStaticDepositAddressRequest is the request to generate a static deposit address.
 */
message GenerateStaticDepositAddressRequest {
    // The signing public key of the user.
    bytes signing_public_key = 1 [(validate.rules).bytes.len = 33];
    // The identity public key of the user.
    bytes identity_public_key = 2 [(validate.rules).bytes.len = 33];
    // The network of the bitcoin network.
    Network network = 3 [(validate.rules).enum = {not_in: [0]}];
}

/**
 * GenerateStaticDepositAddressResponse is the response to the request to generate a static deposit address.
 */
message GenerateStaticDepositAddressResponse {
    Address deposit_address = 1;
}

/**
 * UTXO represents a utxo on the bitcoin network.
 * The UTXO is used to create a tree on Spark, it can also be an off-chain utxo so that the user
 * can create the tree first and the broadcast the transaction.
 */
message UTXO {
    // The raw transaction of the utxo (optional).
    bytes raw_tx = 1;
    // The vout of the raw transaction for the utxo, which will be used to create the tree. Required.
    uint32 vout = 2;
    // The network of the bitcoin network. Required.
    Network network = 3 [(validate.rules).enum = {not_in: [0]}];
    // Transaction ID. Required, but older code may not provide it.
    bytes txid = 4;
}

/**
 * NodeOutput represents a node on the tree.
 * This is similar to a UTXO, which is used to create a subtree on Spark. But instead of using
 * a utxo, a existing node on the tree is used as the utxo.
 */
message NodeOutput {
    // The id of the node.
    string node_id = 1;
    // The vout of the raw transaction for the node, which will be used to create the tree.
    uint32 vout = 2;
}

/**
 * SigningJob is the job for signing a transaction.
 * The signing job is used to sign a bitcoin transaction using Spark FROST.
 */
message SigningJob {
    // The signing public key of the user.
    bytes signing_public_key = 1;
    // The unsigned raw transaction to be signed.
    bytes raw_tx = 2;
    // The signing nonce commitment of the user.
    common.SigningCommitment signing_nonce_commitment = 3;
}

/**
 * SigningKeyshare is the keyshare information of the SE keyshare group.
 */
message SigningKeyshare {
    // The identifiers of the owners of the keyshare.
    repeated string owner_identifiers = 1;
    // The threshold of the keyshare.
    uint32 threshold = 2;
    // The public key of the keyshare.
    bytes public_key = 3;
    // The public shares of the keyshare.
    map<string, bytes> public_shares = 4;
    // The latest update time of the keyshare.
    google.protobuf.Timestamp updated_time = 5;
}

/**
 * SigningResult is the result of the signing job from the SE keyshare group.
 * It contains all the information for user to sign their part. After user signs, the signature
 * can be aggregated to form the final signature.
 */
message SigningResult {
    // The public keys of the SE keyshare group.
    map<string, bytes> public_keys = 1;
    // The signing nonce commitments of the SE keyshare group.
    map<string, common.SigningCommitment> signing_nonce_commitments = 2;
    // The signature shares of the SE keyshare group.
    map<string, bytes> signature_shares = 3;
    // The keyshare information of the SE keyshare group.
    SigningKeyshare signing_keyshare = 4;
}

/**
 * NodeSignatureShares is the signature shares for a node on the tree.
 * For each tree node, the verifying key stays the same for both transactions.
 */
message NodeSignatureShares {
    // The id of the node.
    string node_id = 1;
    // The signing result of the node's transaction. This transaction is to pay to self.
    SigningResult node_tx_signing_result = 2;
    // The signing result of the node's refund transaction. This transaction is to pay to the user.
    SigningResult refund_tx_signing_result = 3;
    // The verifying key of the node.
    bytes verifying_key = 4;
    // The signing result of the node's transaction. This transaction is to pay to self.
    SigningResult direct_node_tx_signing_result = 5;
    // The signing result of the node's direct refund transaction. This transaction is to broadcast for the SO.
    SigningResult direct_refund_tx_signing_result = 6;
    // The signing result of the node's direct from cpfp refund transaction. This transaction is to broadcast for the SO.
    SigningResult direct_from_cpfp_refund_tx_signing_result = 7;
}

/**
 * NodeSignatures is the final signatures for a node on the tree.
 * It contains the signature for the node's transaction and refund transaction.
 */
message NodeSignatures {
    // The id of the node.
    string node_id = 1;
    // The final signature of the node's cpfp transaction. This transaction is to pay to self.
    bytes node_tx_signature = 2;
    // The final signature of the node's cpfp refund transaction. This transaction is to pay to the user.
    bytes refund_tx_signature = 3;
    // The final signature of the node's direct transaction. This transaction is to pay for the watchtower.
    bytes direct_node_tx_signature = 4;
    // The final signature of the node's direct refund transaction. This transaction is to pay for the watchtower.
    bytes direct_refund_tx_signature = 5;
    // The final signature of the node's direct from cpfp refund transaction. This transaction is to pay for the watchtower.
    bytes direct_from_cpfp_refund_tx_signature = 6;
}

/**
 * StartTreeCreationRequest is the request to start the tree creation for a tree root node.
 */
message StartTreeCreationRequest {
    // The identity public key of the user.
    bytes identity_public_key = 1;
    // The on-chain utxo to be used to be spent by the root node.
    UTXO on_chain_utxo = 2;
    // The signing job for the root node's cpfp transaction.
    SigningJob root_tx_signing_job = 3;
    // The signing job for the root node's cpfp refund transaction.
    SigningJob refund_tx_signing_job = 4;
    // The signing job for the root node's direct transaction.
    SigningJob direct_root_tx_signing_job = 5;
    // The signing job for the root node's direct refund transaction
    SigningJob direct_refund_tx_signing_job = 6;
    // The signing job for the root node's direct refund transaction
    SigningJob direct_from_cpfp_refund_tx_signing_job = 7;
}

/**
 * StartTreeCreationResponse is the response to the request to start the tree creation for a tree root node.
 */
message StartTreeCreationResponse {
    // The id of the tree.
    string tree_id = 1;
    // The signature shares for the root node.
    NodeSignatureShares root_node_signature_shares = 2;
}

/**
 * StartDepositTreeCreationRequest is the request to start the tree creation for a tree root node.
 */
message StartDepositTreeCreationRequest {
    // The identity public key of the user.
    bytes identity_public_key = 1;
    // The on-chain utxo to be used to be spent by the root node.
    UTXO on_chain_utxo = 2;
    // The signing job for the root node's transaction.
    SigningJob root_tx_signing_job = 3;
    // The signing job for the root node's refund transaction.
    SigningJob refund_tx_signing_job = 4;
    // The direct signing job for the root node's transaction.
    SigningJob direct_root_tx_signing_job = 5;
    // The signing job for the root node's direct refund transaction.
    SigningJob direct_refund_tx_signing_job = 6;
    // The signing job for the root node's direct from cpfp refund transaction.
    SigningJob direct_from_cpfp_refund_tx_signing_job = 7;
}

/**
 * StartDepositTreeCreationResponse is the response to the request to start the tree creation for a tree root node.
 */
message StartDepositTreeCreationResponse {
    // The id of the tree.
    string tree_id = 1;
    // The signature shares for the root node.
    NodeSignatureShares root_node_signature_shares = 2;
}

// This proto is constructed by the wallet to specify leaves it wants to spend as
// part of the token transaction.
message TokenOutputToSpend {
    bytes prev_token_transaction_hash = 1 [(validate.rules).bytes.len = 32];
    uint32 prev_token_transaction_vout = 2;
}

message TokenTransferInput {
    repeated TokenOutputToSpend outputs_to_spend = 1;
}

message TokenMintInput {
    bytes issuer_public_key = 1 [(validate.rules).bytes.len = 33];
    // Issuer provided timestamp of when the transaction was signed/constructed.
    // Helps provide idempotency and ensures that each mint input signature is unique
    // as long as multiple mint signatures are not happening at the same time. Also gives a
    // potentially useful data point for when the issuer authorized from their
    // perspective.  Note that we have no way of proving this is accurate.
    // TODO: Consider whether implementing generic idempotency controls and/or a
    // random nonce would be favorable to populating this field.
    uint64 issuer_provided_timestamp = 2;
    optional bytes token_identifier = 3 [(validate.rules).bytes.len = 32];
}

message TokenCreateInput {
    bytes issuer_public_key = 1 [(validate.rules).bytes.len = 33];
    string token_name = 2 [(validate.rules).string = {max_len: 20}]; // No minimum length because a single utf-8 character can be 3 bytes.
    string token_ticker = 3 [(validate.rules).string = {max_len: 6}]; // No minimum length because a single utf-8 character can be 3 bytes.
    uint32 decimals = 4 [(validate.rules).uint32.lte = 255];
    bytes max_supply = 5 [(validate.rules).bytes.len = 16]; // Decoded uint128
    bool is_freezable = 6;
    optional bytes creation_entity_public_key = 7 [(validate.rules).bytes.len = 33];
}

// This proto is constructed by the wallet to specify outputs it wants to create
// as part of a token transaction. Output id and revocation public key should remain unfilled
// so that the SE can fill them as part of the StartTokenTransaction() call.
message TokenOutput {
    optional string id = 1 [(validate.rules).string.uuid = true];
    bytes owner_public_key = 2 [(validate.rules).bytes.len = 33];
    optional bytes revocation_commitment = 3 [(validate.rules).bytes.len = 33];
    optional uint64 withdraw_bond_sats = 4;
    optional uint64 withdraw_relative_block_locktime = 5;
    optional bytes token_public_key = 6 [(validate.rules).bytes = {len: 33}]; 
    optional bytes token_identifier = 8 [(validate.rules).bytes.len = 32];
    bytes token_amount = 7 [(validate.rules).bytes.len = 16];  // Decoded uint128
}

// This proto is constructed by the wallet and is the core transaction data structure.
// This proto is deterministically hashed to generate the token_transaction_hash that
// is cooperatively signed by the SO group to confirm a token transaction.
message TokenTransaction {
    oneof token_inputs {
        TokenMintInput mint_input = 1;
        TokenTransferInput transfer_input = 2;
        TokenCreateInput create_input = 5;
    }   
    repeated TokenOutput token_outputs = 3;
    repeated bytes spark_operator_identity_public_keys = 4 [(validate.rules).repeated.items.bytes.len = 33];
    Network network = 10 [(validate.rules).enum = {not_in: [0]}];
}

enum TokenTransactionStatus {
    TOKEN_TRANSACTION_STARTED = 0;
    TOKEN_TRANSACTION_SIGNED = 1;
    TOKEN_TRANSACTION_REVEALED = 5;
    TOKEN_TRANSACTION_FINALIZED = 2;
    TOKEN_TRANSACTION_STARTED_CANCELLED = 3;
    TOKEN_TRANSACTION_SIGNED_CANCELLED = 4;

    TOKEN_TRANSACTION_UNKNOWN = 10;
}

message SpentTokenOutputMetadata {
    string output_id = 1;
    bytes revocation_secret = 2;
}

message TokenTransactionConfirmationMetadata {
    repeated SpentTokenOutputMetadata spent_token_outputs_metadata = 1;
}

message TokenTransactionWithStatus {
    TokenTransaction token_transaction = 1;
    TokenTransactionStatus status = 2;
    TokenTransactionConfirmationMetadata confirmation_metadata = 3;
    bytes token_transaction_hash = 4 [(validate.rules).bytes.len = 32];
}

message SignatureWithIndex {
    // This is a Schnorr or ECDSA DER signature which can be between 64 and 73 bytes.
    bytes signature = 1 [(validate.rules).bytes.min_len = 64, (validate.rules).bytes.max_len = 73];
    // The index of the TTXO associated with this signature.
    uint32 input_index = 2;
}

message TokenTransactionSignatures {
      // Filled by signing the partial token transaction hash with the owner/issuer private key.
      // For mint transactions this will be one signature for the input token_public_key
      // For transfer transactions this will be one for each output for the output owner_public_key
      repeated SignatureWithIndex owner_signatures = 1;
}

message StartTokenTransactionRequest {
    bytes identity_public_key = 1 [(validate.rules).bytes.len = 33];
    TokenTransaction partial_token_transaction = 2;
    // List of ecdsa signatures authorizing movement of tokens from the token input.
    TokenTransactionSignatures token_transaction_signatures = 3;
    string spark_payment_intent = 4;
}

message StartTokenTransactionResponse {
    // This is the same token transaction sent by the wallet with output revocation public keys
    // filled. This is the final transaction that is published and gossiped among LRC20 nodes.
    TokenTransaction final_token_transaction = 1;
    // Information for fetching and resolving the revocation keyshare on a transfer operation.
    // Contains the threshold of keyshares needed and the SO owners of those keyshares.
    SigningKeyshare keyshare_info = 2;
}

message OperatorSpecificTokenTransactionSignablePayload {
    bytes final_token_transaction_hash = 1 [(validate.rules).bytes.len = 32];
    bytes operator_identity_public_key = 2 [(validate.rules).bytes.len = 33];
}

// This message allows the sender of a output being spent to provide final evidence
// that it owns a output to an SO when requesting signing and release of the  revocation keyshare.
message OperatorSpecificOwnerSignature {
    SignatureWithIndex owner_signature = 1;
    OperatorSpecificTokenTransactionSignablePayload payload = 2;
}

message SignTokenTransactionRequest {
    TokenTransaction final_token_transaction = 1;
    repeated OperatorSpecificOwnerSignature operator_specific_signatures = 2;
    bytes identity_public_key = 3 [(validate.rules).bytes.len = 33];
}

message KeyshareWithIndex {
    // The index of the input TTXO associated with this keyshare.
    uint32 input_index = 1;
    bytes keyshare = 2 [(validate.rules).bytes.len = 32];
}

message SignTokenTransactionResponse {
    bytes spark_operator_signature = 1 [(validate.rules).bytes.min_len = 64, (validate.rules).bytes.max_len = 73];
    repeated KeyshareWithIndex revocation_keyshares = 2;
}

message RevocationSecretWithIndex {
    // The index of the input TTXO associated with this secret.
    uint32 input_index = 1;
    bytes revocation_secret = 2 [(validate.rules).bytes.len = 32];
}

message FinalizeTokenTransactionRequest {
    TokenTransaction final_token_transaction = 1;
    // List of ordered revocation secrets that map 1:1 with leaves being spent in the
    // token transaction.
    repeated RevocationSecretWithIndex revocation_secrets = 2;
    bytes identity_public_key = 3 [(validate.rules).bytes.len = 33];
    string spark_payment_intent = 4;
}

message FreezeTokensPayload {
    bytes owner_public_key = 1 [(validate.rules).bytes.len = 33];
    bytes token_public_key = 2 [(validate.rules).bytes.len = 33];
    uint64 issuer_provided_timestamp = 3;
    bytes operator_identity_public_key = 4 [(validate.rules).bytes.len = 33];
    // Set to false when requesting a freeze.
    bool should_unfreeze = 5;
    optional bytes token_identifier = 6 [(validate.rules).bytes.len = 32];
}

message FreezeTokensRequest {
    FreezeTokensPayload freeze_tokens_payload = 1;
    // This is a Schnorr or ECDSA DER signature which can be between 64 and 73 bytes.
    bytes issuer_signature = 2 [(validate.rules).bytes.min_len = 64, (validate.rules).bytes.max_len = 73];
}

message FreezeTokensResponse {
    repeated string impacted_output_ids = 1 [(validate.rules).repeated.items.string.uuid = true];
    bytes impacted_token_amount = 2;  // Decoded uint128
}

message QueryTokenOutputsRequest {
    repeated bytes owner_public_keys = 1 [(validate.rules).repeated.items.bytes.len = 33];
    // Optionally provide token public keys. If not set return leaves for all tokens.
    repeated bytes token_public_keys = 2 [(validate.rules).repeated.items.bytes.len = 33];
    repeated bytes token_identifiers = 4 [(validate.rules).repeated.items.bytes.len = 32];
    Network network = 3; // defaults to mainnet when no network is provided.
}

// Request constraints are combined using an AND relation.
message QueryTokenTransactionsRequest {
    // Returns transactions that have one of these output ids in the input or output.
    repeated string output_ids = 1 [(validate.rules).repeated.items.string.uuid = true];
    // Returns transactions that have this owner public key as the sender or receiver in one or more of the input/output leaves.
    repeated bytes owner_public_keys = 2 [(validate.rules).repeated.items.bytes.len = 33];
    // Returns transactions that related to this token public key.
    repeated bytes token_public_keys = 3 [(validate.rules).repeated.items.bytes.len = 33];
    // Returns transactions that related to this token identifier.
    repeated bytes token_identifiers = 7 [(validate.rules).repeated.items.bytes.len = 32];
    // Returns transactions that match the provided transaction hashes.
    repeated bytes token_transaction_hashes = 4 [(validate.rules).repeated.items.bytes.len = 32];
    int64 limit = 5;
    int64 offset = 6;
}

message QueryTokenTransactionsResponse {
    repeated TokenTransactionWithStatus token_transactions_with_status = 1;
    int64 offset = 2;
}

message OutputWithPreviousTransactionData {
    TokenOutput output = 1;
	bytes previous_transaction_hash = 2 [(validate.rules).bytes.len = 32];
	uint32 previous_transaction_vout = 3;
}

message QueryTokenOutputsResponse {
    repeated OutputWithPreviousTransactionData outputs_with_previous_transaction_data = 1;
}

/**
 * TreeNode represents a node on the tree.
 */
message TreeNode {
    // The id of the node.
    string id = 1;
    // The id of the tree for this node .
    string tree_id = 2;
    // The value that this node holds.
    uint64 value = 3;
    // The id of the parent node.
    optional string parent_node_id = 4;
    // The cpfp transaction of the node, this transaction is to pay to the same address as the node.
    bytes node_tx = 5;
    // The refund transaction of the node, this transaction is to pay to the user.
    bytes refund_tx = 6;
    // This vout is the vout to spend the previous transaction, which is in the parent node.
    uint32 vout = 7;
    // The verifying public key of the node.
    bytes verifying_public_key = 8;
    // The identity public key of the owner of the node.
    bytes owner_identity_public_key = 9;
    // The signing keyshare information of the node on the SE side.
    SigningKeyshare signing_keyshare = 10;
    // The status of the node.
    string status = 11;
    // The network of the node.
    Network network = 12;
    // The creation time of the node.
    google.protobuf.Timestamp created_time = 13;
    // The latest update time of the node.
    google.protobuf.Timestamp updated_time = 14;
    // The signing public key of the owner of the node.
    bytes owner_signing_public_key = 15;
    // The direct transaction of the node, this transaction is for the watchtower to broadcast.
    bytes direct_tx = 16;
    // The refund transaction of the node, this transaction is to pay to the user.
    bytes direct_refund_tx = 17;
    // The refund transaction of the node, this transaction is to pay to the user.
    bytes direct_from_cpfp_refund_tx = 18;
}

/**
 * FinalizeNodeSignaturesRequest is the request to finalize the signatures for a node.
 */
message FinalizeNodeSignaturesRequest {
    // The intent of the signature.
    common.SignatureIntent intent = 1;
    // The signatures for the node.
    repeated NodeSignatures node_signatures = 2;
}

/**
 * FinalizeNodeSignaturesResponse is the response to the request to finalize the signatures for a node.
 */
message FinalizeNodeSignaturesResponse {
    // The nodes that are finalized.
    repeated TreeNode nodes = 1;
}

/**
 * SecretShare is a secret share of a secret, using Feldman VSS.
 * The secret share is in the field of secp256k1 scalar field.
 */
message SecretShare {
    // The secret share.
    bytes secret_share = 1;
    // The proofs for the secret share. They are the compressed public keys in secp256k1 curve.
    // proofs[0] is the public key of the secret, while proofs[1..n] are the public key of the polynomial.
    repeated bytes proofs = 2;
}

/**
 * SecretProof is the proof for a secret share using Feldman VSS.
 * The proof is the compressed public keys in secp256k1 curve.
 */
message SecretProof {
    // The proofs for the secret share.
    // proofs[0] is the public key of the secret, while proofs[1..n] are the public key of the polynomial.
    repeated bytes proofs = 1;
}

message LeafRefundTxSigningJob {
    string leaf_id = 1;
    SigningJob refund_tx_signing_job = 2;
    SigningJob direct_refund_tx_signing_job = 3;
    SigningJob direct_from_cpfp_refund_tx_signing_job = 4;
}

message UserSignedTxSigningJob {
    string leaf_id = 1;
    bytes signing_public_key = 2;
    bytes raw_tx = 3;
    common.SigningCommitment signing_nonce_commitment = 4;
    bytes user_signature = 5;
    SigningCommitments signing_commitments = 6;
}

message LeafRefundTxSigningResult {
    string leaf_id = 1;
    SigningResult refund_tx_signing_result = 2;
    bytes verifying_key = 3;
    SigningResult direct_refund_tx_signing_result = 4;
    SigningResult direct_from_cpfp_refund_tx_signing_result = 5;
}

message StartUserSignedTransferRequest {
    string transfer_id = 1;
    bytes owner_identity_public_key = 2;
    repeated UserSignedTxSigningJob leaves_to_send = 3;
    bytes receiver_identity_public_key = 4;
    google.protobuf.Timestamp expiry_time = 5;
    repeated UserSignedTxSigningJob direct_leaves_to_send = 6;
    repeated UserSignedTxSigningJob direct_from_cpfp_leaves_to_send = 7;
}


message StartTransferRequest {
    reserved 6;
    reserved 9;

    string transfer_id = 1;
    bytes owner_identity_public_key = 2;
    repeated LeafRefundTxSigningJob leaves_to_send = 3 [deprecated = true];
    bytes receiver_identity_public_key = 4;
    google.protobuf.Timestamp expiry_time = 5;
    // If this field is set, the leaves_to_send and key_tweak_proofs will be ignored.
    TransferPackage transfer_package = 7;
    // The invoice this transfer pays.
    string spark_invoice = 10;
}

message StartTransferResponse {
    Transfer transfer = 1;
    repeated LeafRefundTxSigningResult signing_results = 2;
}

/**
 * TransferPackage is a package of leaves to send and key tweaks to send.
 * This is in the improved send transfer flow where the sender can send the transfer in one call to
 * the coordinator SO.
 */
message TransferPackage {
    // The leaves to send, with user signed cpfp refunds and signing package.
    repeated UserSignedTxSigningJob leaves_to_send = 1;
    // The map of SO identifier to ciphertext of SendLeafTweaks.
    map<string, bytes> key_tweak_package = 2;
    // The signature of user to prove that the key_tweak_package is not tampered.
    bytes user_signature = 3;
    // The leaves to send, with user signed direct refunds and signing package.
    repeated UserSignedTxSigningJob direct_leaves_to_send = 4;
    // The leaves to send, with user signed direct from cpfp refunds and signing package.
    repeated UserSignedTxSigningJob direct_from_cpfp_leaves_to_send = 5;
}

message SendLeafKeyTweaks {
    repeated SendLeafKeyTweak leaves_to_send = 1;
}

message SendLeafKeyTweak {
    string leaf_id = 1;
    SecretShare secret_share_tweak = 2;
    map<string, bytes> pubkey_shares_tweak = 3;
    bytes secret_cipher = 4;
    // Signature over Sha256(leaf_id||transfer_id||secret_cipher)
    bytes signature = 5;
    bytes refund_signature = 6;
    bytes direct_refund_signature = 7;
    bytes direct_from_cpfp_refund_signature = 8;
}

message FinalizeTransferRequest {
    string transfer_id = 1;
    bytes owner_identity_public_key = 2;
    repeated SendLeafKeyTweak leaves_to_send = 3;
    string spark_payment_intent = 4;
}

message FinalizeTransferWithTransferPackageRequest {
    string transfer_id = 1;
    bytes owner_identity_public_key = 2;
    TransferPackage transfer_package = 3;
}

message FinalizeTransferResponse {
    Transfer transfer = 1;
}

enum TransferStatus {
    TRANSFER_STATUS_SENDER_INITIATED = 0;
    TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING = 1;
    TRANSFER_STATUS_SENDER_KEY_TWEAKED = 2;
    TRANSFER_STATUS_RECEIVER_KEY_TWEAKED = 3;
    TRANSFER_STATUS_RECEIVER_REFUND_SIGNED = 4;
    TRANSFER_STATUS_COMPLETED = 5;
    TRANSFER_STATUS_EXPIRED = 6;
    TRANSFER_STATUS_RETURNED = 7;
    TRANSFER_STATUS_SENDER_INITIATED_COORDINATOR = 8;
    TRANSFER_STATUS_RECEIVER_KEY_TWEAK_LOCKED = 9;
    TRANSFER_STATUS_RECEIVER_KEY_TWEAK_APPLIED = 10;
}

enum TransferType {
    PREIMAGE_SWAP = 0;
    COOPERATIVE_EXIT = 1;
    TRANSFER = 2;
    UTXO_SWAP = 3;
    SWAP = 30;
    COUNTER_SWAP = 40;
}

enum Order {
    DESCENDING = 0;
    ASCENDING = 1;
}

message Transfer {
    string id = 1;
    bytes sender_identity_public_key = 2;
    bytes receiver_identity_public_key = 3;
    TransferStatus status = 4;
    uint64 total_value = 5;
    google.protobuf.Timestamp expiry_time = 6;
    repeated TransferLeaf leaves = 7;
    google.protobuf.Timestamp created_time = 8;
    google.protobuf.Timestamp updated_time = 9;
    TransferType type = 10;
    string spark_invoice = 11;
}

message TransferLeaf {
    TreeNode leaf = 1;
    bytes secret_cipher = 2;
    bytes signature = 3;
    bytes intermediate_refund_tx = 4;
    bytes intermediate_direct_refund_tx = 5;
    bytes intermediate_direct_from_cpfp_refund_tx = 6;
    bytes pending_key_tweak_public_key = 7;
}


message TransferFilter {
    oneof participant {
        bytes receiver_identity_public_key = 1;
        bytes sender_identity_public_key = 2;
        // This will include transfers where this public key is the sender or receiver.
        bytes sender_or_receiver_identity_public_key = 60;
    }
    repeated string transfer_ids = 3;
    int64 limit = 40;
    int64 offset = 50;
    repeated TransferType types = 70;
    Network network = 4; // defaults to mainnet when no network is provided.
    repeated TransferStatus statuses = 80;
    Order order = 5;
}

message QueryTransfersResponse {
    repeated Transfer transfers = 1;
    int64 offset = 2;
}

message ClaimLeafKeyTweak {
    string leaf_id = 1;
    SecretShare secret_share_tweak = 2;
    map<string, bytes> pubkey_shares_tweak = 3;
}

message ClaimTransferTweakKeysRequest {
    string transfer_id = 1;
    bytes owner_identity_public_key = 2;
    repeated ClaimLeafKeyTweak leaves_to_receive = 3;
}

message ClaimTransferSignRefundsRequest {
    string transfer_id = 1;
    bytes owner_identity_public_key = 2;
    repeated LeafRefundTxSigningJob signing_jobs = 3;
    reserved 4;
}

message ClaimTransferSignRefundsResponse {
    repeated LeafRefundTxSigningResult signing_results = 1;
}

message StorePreimageShareRequest {
    bytes payment_hash = 1;
    SecretShare preimage_share = 2;
    uint32 threshold = 3;
    string invoice_string = 4;
    bytes user_identity_public_key = 5;
}

message RequestedSigningCommitments {
    map<string, common.SigningCommitment> signing_nonce_commitments = 1;
}

message GetSigningCommitmentsRequest {
    repeated string node_ids = 1;
    uint32 count = 2;
}

message GetSigningCommitmentsResponse {
    repeated RequestedSigningCommitments signing_commitments = 1;
}

message SigningCommitments {
    map<string, common.SigningCommitment> signing_commitments = 1;
}

message UserSignedRefund {
    string node_id = 1;
    bytes refund_tx = 2;
    bytes user_signature = 3;
    SigningCommitments signing_commitments = 4;
    common.SigningCommitment user_signature_commitment = 5;
    Network network = 6 [(validate.rules).enum = {not_in: [0]}];
}

message InvoiceAmountProof {
    string bolt11_invoice = 1;
}

message InvoiceAmount {
    uint64 value_sats = 1;
    InvoiceAmountProof invoice_amount_proof = 2;
}

message InitiatePreimageSwapRequest {
    bytes payment_hash = 1;
    InvoiceAmount invoice_amount = 2;
    enum Reason {
        // The associated lightning service is sending the payment.
        REASON_SEND = 0;
        // The associated lightning service is receiving the payment.
        REASON_RECEIVE = 1;
    }
    Reason reason = 3;
    StartUserSignedTransferRequest transfer = 4;
    bytes receiver_identity_public_key = 5;
    uint64 fee_sats = 6;
}

message InitiatePreimageSwapResponse {
    bytes preimage = 1;
    Transfer transfer = 2;
}

message OutPoint {
    bytes txid = 1;
    uint32 vout = 2;
}

message CooperativeExitRequest {
    StartTransferRequest transfer = 1;
    string exit_id = 2;
    bytes exit_txid = 3;
}

message CooperativeExitResponse {
    Transfer transfer = 1;
    repeated LeafRefundTxSigningResult signing_results = 2;
}

message CounterLeafSwapRequest {
    StartTransferRequest transfer = 1;
    string swap_id = 2;
    bytes adaptor_public_key = 3;
    bytes direct_adaptor_public_key = 4;
    bytes direct_from_cpfp_adaptor_public_key = 5;
}

message CounterLeafSwapResponse {
    Transfer transfer = 1;
    repeated LeafRefundTxSigningResult signing_results = 2;
}

message RefreshTimelockRequest {
    string leaf_id = 1;
    bytes owner_identity_public_key = 2;
    repeated SigningJob signing_jobs = 3;
}

message RefreshTimelockSigningResult {
    SigningResult signing_result = 1;
    bytes verifying_key = 2; // Should maybe just be a part of SigningResult?
}

message RefreshTimelockResponse {
    repeated RefreshTimelockSigningResult signing_results = 1;
}

message ExtendLeafRequest {
    string leaf_id = 1;
    bytes owner_identity_public_key = 2;
    SigningJob node_tx_signing_job = 3;
    SigningJob refund_tx_signing_job = 4;
    SigningJob direct_node_tx_signing_job = 5;
    SigningJob direct_refund_tx_signing_job = 6;
    SigningJob direct_from_cpfp_refund_tx_signing_job = 7;
}

message ExtendLeafSigningResult {
    SigningResult signing_result = 1;
    bytes verifying_key = 2;
}

message ExtendLeafResponse {
    string leaf_id = 1;
    ExtendLeafSigningResult node_tx_signing_result = 2;
    ExtendLeafSigningResult refund_tx_signing_result = 3;
    ExtendLeafSigningResult direct_node_tx_signing_result = 4;
    ExtendLeafSigningResult direct_refund_tx_signing_result = 5;
    ExtendLeafSigningResult direct_from_cpfp_refund_tx_signing_result = 6;
}

message AddressRequestNode {
    bytes user_public_key = 1;
    repeated AddressRequestNode children = 2;
}

message PrepareTreeAddressRequest {
    oneof source {
        NodeOutput parent_node_output = 1;
        UTXO on_chain_utxo = 2;
    }
    // The tx on this node is to spend the source's utxo.
    // The user's public key should already be registered with the SE for the root node.
    AddressRequestNode node = 3;
    bytes user_identity_public_key = 4;
}

message AddressNode {
    Address address = 1;
    repeated AddressNode children = 2;
}

message PrepareTreeAddressResponse {
    AddressNode node = 1;
}

message CreationNode {
    // This is the cpfp tx that spends the parent node's output.
    SigningJob node_tx_signing_job = 1;
    // The refund tx can only exist if there's no children.
    SigningJob refund_tx_signing_job = 2;

    // The children will spend the output of the node's tx. Vout is the index of the child.
    repeated CreationNode children = 3;
    // This is the direct tx that spends the parent node's output.
    SigningJob direct_node_tx_signing_job = 4;
    // The direct refund tx can only exist if there's no children.
    SigningJob direct_refund_tx_signing_job = 5;
    // The direct from cpfp refund tx can only exist if there's no children.
    SigningJob direct_from_cpfp_refund_tx_signing_job = 6;
}

message CreateTreeRequest {
    oneof source {
        NodeOutput parent_node_output = 1;
        UTXO on_chain_utxo = 2;
    }
    // The node should contain the tx that spends the source's utxo.
    CreationNode node = 3;

    // The owner of the tree.
    bytes user_identity_public_key = 4;
}

message CreationResponseNode {
    string node_id = 1;
    SigningResult node_tx_signing_result = 2;
    SigningResult refund_tx_signing_result = 3;
    repeated CreationResponseNode children = 4;
    SigningResult direct_node_tx_signing_result = 5;
    SigningResult direct_refund_tx_signing_result = 6;
    SigningResult direct_from_cpfp_refund_tx_signing_result = 7;
}

message CreateTreeResponse {
    CreationResponseNode node = 1;
}

message SigningOperatorInfo {
    uint64 index = 1;
    string identifier = 2;
    bytes public_key = 3;
    string address = 4;
}

message GetSigningOperatorListResponse {
    map<string, SigningOperatorInfo> signing_operators = 1;
}

message QueryUserSignedRefundsRequest {
    bytes payment_hash = 1;
    bytes identity_public_key = 2;
}

message QueryUserSignedRefundsResponse {
    repeated UserSignedRefund user_signed_refunds = 1;
    reserved 2;
    Transfer transfer = 3;
}

message ProvidePreimageRequest {
    bytes payment_hash = 1;
    bytes preimage = 2;
    bytes identity_public_key = 3;
}

message ProvidePreimageResponse {
    Transfer transfer = 1;
}

message ReturnLightningPaymentRequest {
    bytes payment_hash = 1;
    bytes user_identity_public_key = 2;
}


message TreeNodeIds {
    repeated string node_ids = 1;
}

message QueryNodesRequest {
    oneof source {
        bytes owner_identity_pubkey = 1;
        TreeNodeIds node_ids = 2;
    }
    bool include_parents = 3;
    int64 limit = 4;
    int64 offset = 5;
    Network network = 6; // defaults to mainnet when no network is provided. Does not check network when querying by node_ids
}

message QueryNodesResponse {
    map<string, TreeNode> nodes = 1;
    int64 offset = 2;
}

message CancelTransferRequest {
    string transfer_id = 1;
    bytes sender_identity_public_key = 2;
}

message CancelTransferResponse {
    Transfer transfer = 1;
}

/**
 * Returns a list of addresses that can be used in express deposit flow.
 * Excludes static deposit addresses.
**/
message QueryUnusedDepositAddressesRequest {
    bytes identity_public_key = 1;
    Network network = 2; // defaults to mainnet when no network is provided.
    int64 limit = 3; // defaults to 100 if not set.
    int64 offset = 4; // defaults to 0 if not set.
}

message QueryStaticDepositAddressesRequest {
    bytes identity_public_key = 1;
    Network network = 2; // defaults to mainnet when no network is provided.
    int64 limit = 4;
    int64 offset = 5;
    // Optional filter. When specified, only the DepositAddress with this address is returned.
    optional string deposit_address = 6;
}

message DepositAddressQueryResult {
    string deposit_address = 1;
    bytes user_signing_public_key = 2;
    bytes verifying_public_key = 3;
    optional string leaf_id = 4 [(validate.rules).string.uuid = true];
    optional DepositAddressProof proof_of_possession = 5;
}

message QueryUnusedDepositAddressesResponse {
    repeated DepositAddressQueryResult deposit_addresses = 1;
    int64 offset = 2; // defaults to -1 if there are no more results
}

message QueryStaticDepositAddressesResponse {
    repeated DepositAddressQueryResult deposit_addresses = 1;
}

message QueryBalanceRequest {
    bytes identity_public_key = 1;
    Network network = 2; // defaults to mainnet when no network is provided.
}

message QueryBalanceResponse {
    uint64 balance = 1;
    map<string, uint64> node_balances = 2;
}

message SparkAddress {
    bytes identity_public_key = 1;
    SparkInvoiceFields spark_invoice_fields = 2;
    optional bytes signature = 3 [(validate.rules).bytes.len = 64];
}

message SparkInvoiceFields {
    uint32 version = 1;
    bytes id = 2 [(validate.rules).bytes.len = 16]; 
    oneof payment_type {
        TokensPayment tokens_payment = 3;
        SatsPayment sats_payment = 4;
    }
    optional string memo = 5 [(validate.rules).string.max_bytes = 120];
    optional bytes sender_public_key = 6 [(validate.rules).bytes.len = 33];  
    optional google.protobuf.Timestamp expiry_time = 7;
}

message SatsPayment {
    optional uint64 amount = 1;
}

message TokensPayment {
    optional bytes token_identifier = 1 [(validate.rules).bytes.len = 32];
    optional bytes amount = 2 [(validate.rules).bytes.max_len = 16]; // variable length uint128
}

/**
 * Static deposit address flow messages
 *
**/
enum UtxoSwapRequestType {
  Fixed = 0;
  MaxFee = 1;
  Refund = 2;
}

message InitiateStaticDepositUtxoRefundRequest {
    UTXO on_chain_utxo = 1;
    // A package that is used for signing L1 Bitcoin transactions using FROST.
    // SE consumes it to return SigningResult structure, that is used by the user to
    // construct the final signature for the refund Bitcoin transaction.
    SigningJob refund_tx_signing_job = 3;
    // Signature of a user statement that authorises the SE to initiate a static
    // deposit utxo refund to the user.
    //
    // The user statement is constructed by concatenating the following fields in order:
    // 1. Action name: "claim_static_deposit" (UTF-8 string)
    // 2. Network: lowercase network name (e.g., "bitcoin", "testnet") (UTF-8 string)
    // 3. Transaction ID: hex-encoded UTXO transaction ID (UTF-8 string)
    // 4. Output index: UTXO output index (vout) as 4-byte unsigned integer (little-endian)
    // 5. Request type: 2 for refund (1-byte unsigned integer, little-endian)
    // 6. Credit amount: amount of satoshis to credit as 8-byte unsigned integer (little-endian)
    // 7. Signing payload: sighash of spend transaction (UTF-8 string)
    //
    // The concatenated payload is then hashed with SHA-256, and the resulting hash
    // is signed using ECDSA with the user's identity private key to produce this signature.
    bytes user_signature = 4;
}

message InitiateStaticDepositUtxoRefundResponse {
    // The FROST signing results which must be aggregated by the user to complete signing
    SigningResult refund_tx_signing_result = 1;
    DepositAddressQueryResult deposit_address = 2;
}


message InitiateUtxoSwapRequest {
    UTXO on_chain_utxo = 1;
    UtxoSwapRequestType request_type = 2;
    oneof amount {
        uint64 credit_amount_sats = 3;
        uint64 max_fee_sats = 4;
    }
    bytes ssp_signature = 5;
    bytes user_signature = 6;
    StartTransferRequest transfer = 7;
    SigningJob spend_tx_signing_job = 8;
}

message InitiateUtxoSwapResponse {
    SigningResult spend_tx_signing_result = 1;
    Transfer transfer = 2;
    DepositAddressQueryResult deposit_address = 3;
}

message ExitingTree {
    string tree_id = 1;
    common.SigningCommitment user_signing_commitment = 2;
    uint32 vin = 3;
}

message ExitSingleNodeTreeSigningResult {
    string tree_id = 1;
    SigningResult signing_result = 2;
    bytes verifying_key = 3;
}

message BitcoinTransactionOutput {
    int64 value = 1;
    bytes pk_script = 2;
}

message ExitSingleNodeTreesRequest {
    bytes owner_identity_public_key = 1;
    repeated ExitingTree exiting_trees = 2;
    bytes raw_tx = 3;
    repeated BitcoinTransactionOutput previous_outputs = 4;
}

message ExitSingleNodeTreesResponse {
    repeated ExitSingleNodeTreeSigningResult signing_results = 1;
}

message InvestigateLeavesRequest {
    repeated string leaf_ids = 1;
    bytes owner_identity_public_key = 2;
    string transfer_id = 3;
}

message QueryNodesDistributionRequest {
    bytes owner_identity_public_key = 1;
}

message QueryNodesDistributionResponse {
    map<uint64, uint64> node_distribution = 1;
}

message QueryNodesByValueRequest {
    bytes owner_identity_public_key = 1;
    int64 value = 2;
    int64 offset = 3;
    int64 limit = 4;
}

message QueryNodesByValueResponse {
    map<string, TreeNode> nodes = 1;
    int64 offset = 2;
}

message GetUtxosForAddressRequest {
    string address = 1;
    uint64 offset = 2;
    uint64 limit = 3;
    Network network = 4;
    bool exclude_claimed = 5;
}

message GetUtxosForAddressResponse {
    repeated UTXO utxos = 1;
    uint64 offset = 2;
}

message QuerySparkInvoicesRequest {
    int64 limit = 1;
    int64 offset = 2;
    // returns the status for the provided list of spark invoices.
    repeated string invoice = 3;
}

message QuerySparkInvoicesResponse {
    int64 offset = 1;
    repeated InvoiceResponse invoice_statuses = 2;
}

message InvoiceResponse {
    string invoice = 1;
    InvoiceStatus status = 2;
}

enum InvoiceStatus {
    NOT_FOUND = 0;
    PENDING = 1;
    FINALIZED = 2;
    EXPIRED = 3;
}
