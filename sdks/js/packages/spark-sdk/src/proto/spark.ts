// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v5.29.3
// source: spark.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";
import { SignatureIntent, signatureIntentFromJSON, signatureIntentToJSON, SigningCommitment } from "./common.js";
import { Empty } from "./google/protobuf/empty.js";
import { Timestamp } from "./google/protobuf/timestamp.js";

export const protobufPackage = "spark";

/** Network is the network type of the bitcoin network. */
export enum Network {
  UNSPECIFIED = 0,
  MAINNET = 1,
  REGTEST = 2,
  TESTNET = 3,
  SIGNET = 4,
  UNRECOGNIZED = -1,
}

export function networkFromJSON(object: any): Network {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return Network.UNSPECIFIED;
    case 1:
    case "MAINNET":
      return Network.MAINNET;
    case 2:
    case "REGTEST":
      return Network.REGTEST;
    case 3:
    case "TESTNET":
      return Network.TESTNET;
    case 4:
    case "SIGNET":
      return Network.SIGNET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Network.UNRECOGNIZED;
  }
}

export function networkToJSON(object: Network): string {
  switch (object) {
    case Network.UNSPECIFIED:
      return "UNSPECIFIED";
    case Network.MAINNET:
      return "MAINNET";
    case Network.REGTEST:
      return "REGTEST";
    case Network.TESTNET:
      return "TESTNET";
    case Network.SIGNET:
      return "SIGNET";
    case Network.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Direction {
  NEXT = 0,
  PREVIOUS = 1,
  UNRECOGNIZED = -1,
}

export function directionFromJSON(object: any): Direction {
  switch (object) {
    case 0:
    case "NEXT":
      return Direction.NEXT;
    case 1:
    case "PREVIOUS":
      return Direction.PREVIOUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Direction.UNRECOGNIZED;
  }
}

export function directionToJSON(object: Direction): string {
  switch (object) {
    case Direction.NEXT:
      return "NEXT";
    case Direction.PREVIOUS:
      return "PREVIOUS";
    case Direction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TokenTransactionStatus {
  TOKEN_TRANSACTION_STARTED = 0,
  TOKEN_TRANSACTION_SIGNED = 1,
  TOKEN_TRANSACTION_REVEALED = 5,
  TOKEN_TRANSACTION_FINALIZED = 2,
  TOKEN_TRANSACTION_STARTED_CANCELLED = 3,
  TOKEN_TRANSACTION_SIGNED_CANCELLED = 4,
  TOKEN_TRANSACTION_UNKNOWN = 10,
  UNRECOGNIZED = -1,
}

export function tokenTransactionStatusFromJSON(object: any): TokenTransactionStatus {
  switch (object) {
    case 0:
    case "TOKEN_TRANSACTION_STARTED":
      return TokenTransactionStatus.TOKEN_TRANSACTION_STARTED;
    case 1:
    case "TOKEN_TRANSACTION_SIGNED":
      return TokenTransactionStatus.TOKEN_TRANSACTION_SIGNED;
    case 5:
    case "TOKEN_TRANSACTION_REVEALED":
      return TokenTransactionStatus.TOKEN_TRANSACTION_REVEALED;
    case 2:
    case "TOKEN_TRANSACTION_FINALIZED":
      return TokenTransactionStatus.TOKEN_TRANSACTION_FINALIZED;
    case 3:
    case "TOKEN_TRANSACTION_STARTED_CANCELLED":
      return TokenTransactionStatus.TOKEN_TRANSACTION_STARTED_CANCELLED;
    case 4:
    case "TOKEN_TRANSACTION_SIGNED_CANCELLED":
      return TokenTransactionStatus.TOKEN_TRANSACTION_SIGNED_CANCELLED;
    case 10:
    case "TOKEN_TRANSACTION_UNKNOWN":
      return TokenTransactionStatus.TOKEN_TRANSACTION_UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TokenTransactionStatus.UNRECOGNIZED;
  }
}

export function tokenTransactionStatusToJSON(object: TokenTransactionStatus): string {
  switch (object) {
    case TokenTransactionStatus.TOKEN_TRANSACTION_STARTED:
      return "TOKEN_TRANSACTION_STARTED";
    case TokenTransactionStatus.TOKEN_TRANSACTION_SIGNED:
      return "TOKEN_TRANSACTION_SIGNED";
    case TokenTransactionStatus.TOKEN_TRANSACTION_REVEALED:
      return "TOKEN_TRANSACTION_REVEALED";
    case TokenTransactionStatus.TOKEN_TRANSACTION_FINALIZED:
      return "TOKEN_TRANSACTION_FINALIZED";
    case TokenTransactionStatus.TOKEN_TRANSACTION_STARTED_CANCELLED:
      return "TOKEN_TRANSACTION_STARTED_CANCELLED";
    case TokenTransactionStatus.TOKEN_TRANSACTION_SIGNED_CANCELLED:
      return "TOKEN_TRANSACTION_SIGNED_CANCELLED";
    case TokenTransactionStatus.TOKEN_TRANSACTION_UNKNOWN:
      return "TOKEN_TRANSACTION_UNKNOWN";
    case TokenTransactionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TransferStatus {
  TRANSFER_STATUS_SENDER_INITIATED = 0,
  TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING = 1,
  TRANSFER_STATUS_SENDER_KEY_TWEAKED = 2,
  TRANSFER_STATUS_RECEIVER_KEY_TWEAKED = 3,
  TRANSFER_STATUS_RECEIVER_REFUND_SIGNED = 4,
  TRANSFER_STATUS_COMPLETED = 5,
  TRANSFER_STATUS_EXPIRED = 6,
  TRANSFER_STATUS_RETURNED = 7,
  TRANSFER_STATUS_SENDER_INITIATED_COORDINATOR = 8,
  TRANSFER_STATUS_RECEIVER_KEY_TWEAK_LOCKED = 9,
  TRANSFER_STATUS_RECEIVER_KEY_TWEAK_APPLIED = 10,
  UNRECOGNIZED = -1,
}

export function transferStatusFromJSON(object: any): TransferStatus {
  switch (object) {
    case 0:
    case "TRANSFER_STATUS_SENDER_INITIATED":
      return TransferStatus.TRANSFER_STATUS_SENDER_INITIATED;
    case 1:
    case "TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING":
      return TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING;
    case 2:
    case "TRANSFER_STATUS_SENDER_KEY_TWEAKED":
      return TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAKED;
    case 3:
    case "TRANSFER_STATUS_RECEIVER_KEY_TWEAKED":
      return TransferStatus.TRANSFER_STATUS_RECEIVER_KEY_TWEAKED;
    case 4:
    case "TRANSFER_STATUS_RECEIVER_REFUND_SIGNED":
      return TransferStatus.TRANSFER_STATUS_RECEIVER_REFUND_SIGNED;
    case 5:
    case "TRANSFER_STATUS_COMPLETED":
      return TransferStatus.TRANSFER_STATUS_COMPLETED;
    case 6:
    case "TRANSFER_STATUS_EXPIRED":
      return TransferStatus.TRANSFER_STATUS_EXPIRED;
    case 7:
    case "TRANSFER_STATUS_RETURNED":
      return TransferStatus.TRANSFER_STATUS_RETURNED;
    case 8:
    case "TRANSFER_STATUS_SENDER_INITIATED_COORDINATOR":
      return TransferStatus.TRANSFER_STATUS_SENDER_INITIATED_COORDINATOR;
    case 9:
    case "TRANSFER_STATUS_RECEIVER_KEY_TWEAK_LOCKED":
      return TransferStatus.TRANSFER_STATUS_RECEIVER_KEY_TWEAK_LOCKED;
    case 10:
    case "TRANSFER_STATUS_RECEIVER_KEY_TWEAK_APPLIED":
      return TransferStatus.TRANSFER_STATUS_RECEIVER_KEY_TWEAK_APPLIED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransferStatus.UNRECOGNIZED;
  }
}

export function transferStatusToJSON(object: TransferStatus): string {
  switch (object) {
    case TransferStatus.TRANSFER_STATUS_SENDER_INITIATED:
      return "TRANSFER_STATUS_SENDER_INITIATED";
    case TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING:
      return "TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING";
    case TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAKED:
      return "TRANSFER_STATUS_SENDER_KEY_TWEAKED";
    case TransferStatus.TRANSFER_STATUS_RECEIVER_KEY_TWEAKED:
      return "TRANSFER_STATUS_RECEIVER_KEY_TWEAKED";
    case TransferStatus.TRANSFER_STATUS_RECEIVER_REFUND_SIGNED:
      return "TRANSFER_STATUS_RECEIVER_REFUND_SIGNED";
    case TransferStatus.TRANSFER_STATUS_COMPLETED:
      return "TRANSFER_STATUS_COMPLETED";
    case TransferStatus.TRANSFER_STATUS_EXPIRED:
      return "TRANSFER_STATUS_EXPIRED";
    case TransferStatus.TRANSFER_STATUS_RETURNED:
      return "TRANSFER_STATUS_RETURNED";
    case TransferStatus.TRANSFER_STATUS_SENDER_INITIATED_COORDINATOR:
      return "TRANSFER_STATUS_SENDER_INITIATED_COORDINATOR";
    case TransferStatus.TRANSFER_STATUS_RECEIVER_KEY_TWEAK_LOCKED:
      return "TRANSFER_STATUS_RECEIVER_KEY_TWEAK_LOCKED";
    case TransferStatus.TRANSFER_STATUS_RECEIVER_KEY_TWEAK_APPLIED:
      return "TRANSFER_STATUS_RECEIVER_KEY_TWEAK_APPLIED";
    case TransferStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TransferType {
  PREIMAGE_SWAP = 0,
  COOPERATIVE_EXIT = 1,
  TRANSFER = 2,
  UTXO_SWAP = 3,
  SWAP = 30,
  COUNTER_SWAP = 40,
  UNRECOGNIZED = -1,
}

export function transferTypeFromJSON(object: any): TransferType {
  switch (object) {
    case 0:
    case "PREIMAGE_SWAP":
      return TransferType.PREIMAGE_SWAP;
    case 1:
    case "COOPERATIVE_EXIT":
      return TransferType.COOPERATIVE_EXIT;
    case 2:
    case "TRANSFER":
      return TransferType.TRANSFER;
    case 3:
    case "UTXO_SWAP":
      return TransferType.UTXO_SWAP;
    case 30:
    case "SWAP":
      return TransferType.SWAP;
    case 40:
    case "COUNTER_SWAP":
      return TransferType.COUNTER_SWAP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransferType.UNRECOGNIZED;
  }
}

export function transferTypeToJSON(object: TransferType): string {
  switch (object) {
    case TransferType.PREIMAGE_SWAP:
      return "PREIMAGE_SWAP";
    case TransferType.COOPERATIVE_EXIT:
      return "COOPERATIVE_EXIT";
    case TransferType.TRANSFER:
      return "TRANSFER";
    case TransferType.UTXO_SWAP:
      return "UTXO_SWAP";
    case TransferType.SWAP:
      return "SWAP";
    case TransferType.COUNTER_SWAP:
      return "COUNTER_SWAP";
    case TransferType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Order {
  DESCENDING = 0,
  ASCENDING = 1,
  UNRECOGNIZED = -1,
}

export function orderFromJSON(object: any): Order {
  switch (object) {
    case 0:
    case "DESCENDING":
      return Order.DESCENDING;
    case 1:
    case "ASCENDING":
      return Order.ASCENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Order.UNRECOGNIZED;
  }
}

export function orderToJSON(object: Order): string {
  switch (object) {
    case Order.DESCENDING:
      return "DESCENDING";
    case Order.ASCENDING:
      return "ASCENDING";
    case Order.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Static deposit address flow messages */
export enum UtxoSwapRequestType {
  Fixed = 0,
  MaxFee = 1,
  Refund = 2,
  UNRECOGNIZED = -1,
}

export function utxoSwapRequestTypeFromJSON(object: any): UtxoSwapRequestType {
  switch (object) {
    case 0:
    case "Fixed":
      return UtxoSwapRequestType.Fixed;
    case 1:
    case "MaxFee":
      return UtxoSwapRequestType.MaxFee;
    case 2:
    case "Refund":
      return UtxoSwapRequestType.Refund;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UtxoSwapRequestType.UNRECOGNIZED;
  }
}

export function utxoSwapRequestTypeToJSON(object: UtxoSwapRequestType): string {
  switch (object) {
    case UtxoSwapRequestType.Fixed:
      return "Fixed";
    case UtxoSwapRequestType.MaxFee:
      return "MaxFee";
    case UtxoSwapRequestType.Refund:
      return "Refund";
    case UtxoSwapRequestType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum InvoiceStatus {
  NOT_FOUND = 0,
  PENDING = 1,
  FINALIZED = 2,
  RETURNED = 4,
  UNRECOGNIZED = -1,
}

export function invoiceStatusFromJSON(object: any): InvoiceStatus {
  switch (object) {
    case 0:
    case "NOT_FOUND":
      return InvoiceStatus.NOT_FOUND;
    case 1:
    case "PENDING":
      return InvoiceStatus.PENDING;
    case 2:
    case "FINALIZED":
      return InvoiceStatus.FINALIZED;
    case 4:
    case "RETURNED":
      return InvoiceStatus.RETURNED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InvoiceStatus.UNRECOGNIZED;
  }
}

export function invoiceStatusToJSON(object: InvoiceStatus): string {
  switch (object) {
    case InvoiceStatus.NOT_FOUND:
      return "NOT_FOUND";
    case InvoiceStatus.PENDING:
      return "PENDING";
    case InvoiceStatus.FINALIZED:
      return "FINALIZED";
    case InvoiceStatus.RETURNED:
      return "RETURNED";
    case InvoiceStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SubscribeToEventsRequest {
  identityPublicKey: Uint8Array;
}

export interface SubscribeToEventsResponse {
  event?: { $case: "transfer"; transfer: TransferEvent } | { $case: "deposit"; deposit: DepositEvent } | {
    $case: "connected";
    connected: ConnectedEvent;
  } | undefined;
}

export interface ConnectedEvent {
}

export interface TransferEvent {
  transfer: Transfer | undefined;
}

export interface DepositEvent {
  deposit: TreeNode | undefined;
}

export interface PageRequest {
  pageSize: number;
  cursor: string;
  direction: Direction;
}

export interface PageResponse {
  hasNextPage: boolean;
  hasPreviousPage: boolean;
  nextCursor: string;
  previousCursor: string;
}

/**
 * DepositAddressProof is the proof of possession of the deposit address.
 * When a user wants to generate a deposit address, they are sending their public key to the SE,
 * and the SE will respond with an address of user's public key + SE's public key.
 *
 * In the trusty deposit flow, user will need to know that this address is valid, and no single SE
 * can generate this address.
 *
 * The SE will need to sign the address with their identity keys, and have a proof of possession of
 * the signing key piece that the SE holds.
 */
export interface DepositAddressProof {
  /** The signatures of the address by the SE's identity keys. */
  addressSignatures: { [key: string]: Uint8Array };
  /** The proof of possession of the signing key piece by the SE. */
  proofOfPossessionSignature: Uint8Array;
}

export interface DepositAddressProof_AddressSignaturesEntry {
  key: string;
  value: Uint8Array;
}

/**
 * GenerateDepositAddressRequest is the request to generate a deposit address.
 * The user will send their public key to the SE, and the SE will respond with an address of user's
 * public key + SE's public key.
 */
export interface GenerateDepositAddressRequest {
  /** The signing public key of the user. */
  signingPublicKey: Uint8Array;
  /** The identity public key of the user. */
  identityPublicKey: Uint8Array;
  /** The network of the bitcoin network. */
  network: Network;
  /** The UUID to use for the created TreeNode */
  leafId?:
    | string
    | undefined;
  /** Generate static deposit address */
  isStatic?: boolean | undefined;
}

/** Address is the address of the user's public key + SE's public key. */
export interface Address {
  /** The p2tr address of the user's public key + SE's public key. */
  address: string;
  /** The verifying key of the address, which is user's public key + SE's public key. */
  verifyingKey: Uint8Array;
  /** The proof of possession of the address by the SE. */
  depositAddressProof:
    | DepositAddressProof
    | undefined;
  /** Is it a static deposit address */
  isStatic: boolean;
}

/** GenerateDepositAddressResponse is the response to the request to generate a deposit address. */
export interface GenerateDepositAddressResponse {
  depositAddress: Address | undefined;
}

/** GenerateStaticDepositAddressRequest is the request to generate a static deposit address. */
export interface GenerateStaticDepositAddressRequest {
  /** The signing public key of the user. */
  signingPublicKey: Uint8Array;
  /** The identity public key of the user. */
  identityPublicKey: Uint8Array;
  /** The network of the bitcoin network. */
  network: Network;
}

/** GenerateStaticDepositAddressResponse is the response to the request to generate a static deposit address. */
export interface GenerateStaticDepositAddressResponse {
  depositAddress: Address | undefined;
}

/**
 * UTXO represents a utxo on the bitcoin network.
 * The UTXO is used to create a tree on Spark, it can also be an off-chain utxo so that the user
 * can create the tree first and the broadcast the transaction.
 */
export interface UTXO {
  /** The raw transaction of the utxo (optional). */
  rawTx: Uint8Array;
  /** The vout of the raw transaction for the utxo, which will be used to create the tree. Required. */
  vout: number;
  /** The network of the bitcoin network. Required. */
  network: Network;
  /** Transaction ID. Required, but older code may not provide it. */
  txid: Uint8Array;
}

/**
 * NodeOutput represents a node on the tree.
 * This is similar to a UTXO, which is used to create a subtree on Spark. But instead of using
 * a utxo, a existing node on the tree is used as the utxo.
 */
export interface NodeOutput {
  /** The id of the node. */
  nodeId: string;
  /** The vout of the raw transaction for the node, which will be used to create the tree. */
  vout: number;
}

/**
 * SigningJob is the job for signing a transaction.
 * The signing job is used to sign a bitcoin transaction using Spark FROST.
 */
export interface SigningJob {
  /** The signing public key of the user. */
  signingPublicKey: Uint8Array;
  /** The unsigned raw transaction to be signed. */
  rawTx: Uint8Array;
  /** The signing nonce commitment of the user. */
  signingNonceCommitment: SigningCommitment | undefined;
}

/** SigningKeyshare is the keyshare information of the SE keyshare group. */
export interface SigningKeyshare {
  /** The identifiers of the owners of the keyshare. */
  ownerIdentifiers: string[];
  /** The threshold of the keyshare. */
  threshold: number;
  /** The public key of the keyshare. */
  publicKey: Uint8Array;
  /** The public shares of the keyshare. */
  publicShares: { [key: string]: Uint8Array };
  /** The latest update time of the keyshare. */
  updatedTime: Date | undefined;
}

export interface SigningKeyshare_PublicSharesEntry {
  key: string;
  value: Uint8Array;
}

/**
 * SigningResult is the result of the signing job from the SE keyshare group.
 * It contains all the information for user to sign their part. After user signs, the signature
 * can be aggregated to form the final signature.
 */
export interface SigningResult {
  /** The public keys of the SE keyshare group. */
  publicKeys: { [key: string]: Uint8Array };
  /** The signing nonce commitments of the SE keyshare group. */
  signingNonceCommitments: { [key: string]: SigningCommitment };
  /** The signature shares of the SE keyshare group. */
  signatureShares: { [key: string]: Uint8Array };
  /** The keyshare information of the SE keyshare group. */
  signingKeyshare: SigningKeyshare | undefined;
}

export interface SigningResult_PublicKeysEntry {
  key: string;
  value: Uint8Array;
}

export interface SigningResult_SigningNonceCommitmentsEntry {
  key: string;
  value: SigningCommitment | undefined;
}

export interface SigningResult_SignatureSharesEntry {
  key: string;
  value: Uint8Array;
}

export interface RenewLeafRequest {
  leafId: string;
  ownerIdentityPublicKey: Uint8Array;
  signingJobs?:
    | //
    /**
     * Resets the node transaction timelock and refund transaction timelock
     * for a leaf to 2000. The old node transaction is invalidated by
     * introducing a "split node" with zero timelock that spends to a new
     * node transaction. Takes in the signing jobs for the updated
     * node, refund, and split node transactions with the new timelocks.
     * Requires that the existing node transaction timelock is <= 300
     * at the time this function is called. Returns an error if these
     * conditions are not met.
     */
    { $case: "renewNodeTimelockSigningJob"; renewNodeTimelockSigningJob: RenewNodeTimelockSigningJob }
    | //
    /**
     * Resets the refund transaction timelock for a leaf to 2000. Takes in
     * the signing jobs for the updated transactions with the new timelocks.
     * Requires that the existing refund transaction timelock is <= 300 and
     * the node transaction timelock > 300 at the time this function is
     * called. Returns an error if these conditions are not met.
     */
    { $case: "renewRefundTimelockSigningJob"; renewRefundTimelockSigningJob: RenewRefundTimelockSigningJob }
    | undefined;
}

export interface RenewNodeTimelockSigningJob {
  /**
   * Signing job with the new "split node" transaction. This spends the
   * inputs of the old node transaction and its outputs are spent by the new
   * node transaction. Timelock of split node transaction must be 0.
   */
  splitNodeTxSigningJob: UserSignedTxSigningJob | undefined;
  splitNodeDirectTxSigningJob:
    | UserSignedTxSigningJob
    | undefined;
  /**
   * Signing job with the updated node transaction. The updated transaction is
   * expected to have a timelock of 2000.
   */
  nodeTxSigningJob: UserSignedTxSigningJob | undefined;
  refundTxSigningJob: UserSignedTxSigningJob | undefined;
  directNodeTxSigningJob: UserSignedTxSigningJob | undefined;
  directRefundTxSigningJob: UserSignedTxSigningJob | undefined;
  directFromCpfpRefundTxSigningJob: UserSignedTxSigningJob | undefined;
}

export interface RenewRefundTimelockSigningJob {
  /**
   * Signing job with the updated node transaction. The updated transaction is
   * expected to have a timelock of 100 less than the existing node transaction.
   */
  nodeTxSigningJob:
    | UserSignedTxSigningJob
    | undefined;
  /**
   * Signing job with the updated refund transaction. This updated transaction
   * must have a timelock of 2000.
   */
  refundTxSigningJob: UserSignedTxSigningJob | undefined;
  directNodeTxSigningJob: UserSignedTxSigningJob | undefined;
  directRefundTxSigningJob: UserSignedTxSigningJob | undefined;
  directFromCpfpRefundTxSigningJob: UserSignedTxSigningJob | undefined;
}

export interface RenewLeafResponse {
  renewResult?: { $case: "extendResult"; extendResult: RenewNodeTimelockResult } | {
    $case: "refreshResult";
    refreshResult: RenewRefundTimelockResult;
  } | undefined;
}

export interface RenewNodeTimelockResult {
  splitNode: TreeNode | undefined;
  node: TreeNode | undefined;
}

export interface RenewRefundTimelockResult {
  node: TreeNode | undefined;
}

/**
 * NodeSignatureShares is the signature shares for a node on the tree.
 * For each tree node, the verifying key stays the same for both transactions.
 */
export interface NodeSignatureShares {
  /** The id of the node. */
  nodeId: string;
  /** The signing result of the node's transaction. This transaction is to pay to self. */
  nodeTxSigningResult:
    | SigningResult
    | undefined;
  /** The signing result of the node's refund transaction. This transaction is to pay to the user. */
  refundTxSigningResult:
    | SigningResult
    | undefined;
  /** The verifying key of the node. */
  verifyingKey: Uint8Array;
  /** The signing result of the node's transaction. This transaction is to pay to self. */
  directNodeTxSigningResult:
    | SigningResult
    | undefined;
  /** The signing result of the node's direct refund transaction. This transaction is to broadcast for the SO. */
  directRefundTxSigningResult:
    | SigningResult
    | undefined;
  /** The signing result of the node's direct from cpfp refund transaction. This transaction is to broadcast for the SO. */
  directFromCpfpRefundTxSigningResult: SigningResult | undefined;
}

/**
 * NodeSignatures is the final signatures for a node on the tree.
 * It contains the signature for the node's transaction and refund transaction.
 */
export interface NodeSignatures {
  /** The id of the node. */
  nodeId: string;
  /** The final signature of the node's cpfp transaction. This transaction is to pay to self. */
  nodeTxSignature: Uint8Array;
  /** The final signature of the node's cpfp refund transaction. This transaction is to pay to the user. */
  refundTxSignature: Uint8Array;
  /** The final signature of the node's direct transaction. This transaction is to pay for the watchtower. */
  directNodeTxSignature: Uint8Array;
  /** The final signature of the node's direct refund transaction. This transaction is to pay for the watchtower. */
  directRefundTxSignature: Uint8Array;
  /** The final signature of the node's direct from cpfp refund transaction. This transaction is to pay for the watchtower. */
  directFromCpfpRefundTxSignature: Uint8Array;
}

/** StartTreeCreationRequest is the request to start the tree creation for a tree root node. */
export interface StartTreeCreationRequest {
  /** The identity public key of the user. */
  identityPublicKey: Uint8Array;
  /** The on-chain utxo to be used to be spent by the root node. */
  onChainUtxo:
    | UTXO
    | undefined;
  /** The signing job for the root node's cpfp transaction. */
  rootTxSigningJob:
    | SigningJob
    | undefined;
  /** The signing job for the root node's cpfp refund transaction. */
  refundTxSigningJob:
    | SigningJob
    | undefined;
  /** The signing job for the root node's direct transaction. */
  directRootTxSigningJob:
    | SigningJob
    | undefined;
  /** The signing job for the root node's direct refund transaction */
  directRefundTxSigningJob:
    | SigningJob
    | undefined;
  /** The signing job for the root node's direct refund transaction */
  directFromCpfpRefundTxSigningJob: SigningJob | undefined;
}

/** StartTreeCreationResponse is the response to the request to start the tree creation for a tree root node. */
export interface StartTreeCreationResponse {
  /** The id of the tree. */
  treeId: string;
  /** The signature shares for the root node. */
  rootNodeSignatureShares: NodeSignatureShares | undefined;
}

/** StartDepositTreeCreationRequest is the request to start the tree creation for a tree root node. */
export interface StartDepositTreeCreationRequest {
  /** The identity public key of the user. */
  identityPublicKey: Uint8Array;
  /** The on-chain utxo to be used to be spent by the root node. */
  onChainUtxo:
    | UTXO
    | undefined;
  /** The signing job for the root node's transaction. */
  rootTxSigningJob:
    | SigningJob
    | undefined;
  /** The signing job for the root node's refund transaction. */
  refundTxSigningJob:
    | SigningJob
    | undefined;
  /** The direct signing job for the root node's transaction. */
  directRootTxSigningJob:
    | SigningJob
    | undefined;
  /** The signing job for the root node's direct refund transaction. */
  directRefundTxSigningJob:
    | SigningJob
    | undefined;
  /** The signing job for the root node's direct from cpfp refund transaction. */
  directFromCpfpRefundTxSigningJob: SigningJob | undefined;
}

/** StartDepositTreeCreationResponse is the response to the request to start the tree creation for a tree root node. */
export interface StartDepositTreeCreationResponse {
  /** The id of the tree. */
  treeId: string;
  /** The signature shares for the root node. */
  rootNodeSignatureShares: NodeSignatureShares | undefined;
}

/**
 * This proto is constructed by the wallet to specify leaves it wants to spend as
 * part of the token transaction.
 */
export interface TokenOutputToSpend {
  prevTokenTransactionHash: Uint8Array;
  prevTokenTransactionVout: number;
}

export interface TokenTransferInput {
  outputsToSpend: TokenOutputToSpend[];
}

export interface TokenMintInput {
  issuerPublicKey: Uint8Array;
  /**
   * Issuer provided timestamp of when the transaction was signed/constructed.
   * Helps provide idempotency and ensures that each mint input signature is unique
   * as long as multiple mint signatures are not happening at the same time. Also gives a
   * potentially useful data point for when the issuer authorized from their
   * perspective.  Note that we have no way of proving this is accurate.
   * TODO: Consider whether implementing generic idempotency controls and/or a
   * random nonce would be favorable to populating this field.
   */
  issuerProvidedTimestamp: number;
  tokenIdentifier?: Uint8Array | undefined;
}

export interface TokenCreateInput {
  issuerPublicKey: Uint8Array;
  /** No minimum length because a single utf-8 character can be 3 bytes. */
  tokenName: string;
  /** No minimum length because a single utf-8 character can be 3 bytes. */
  tokenTicker: string;
  decimals: number;
  /** Decoded uint128 */
  maxSupply: Uint8Array;
  isFreezable: boolean;
  creationEntityPublicKey?: Uint8Array | undefined;
}

/**
 * This proto is constructed by the wallet to specify outputs it wants to create
 * as part of a token transaction. Output id and revocation public key should remain unfilled
 * so that the SE can fill them as part of the StartTokenTransaction() call.
 */
export interface TokenOutput {
  id?: string | undefined;
  ownerPublicKey: Uint8Array;
  revocationCommitment?: Uint8Array | undefined;
  withdrawBondSats?: number | undefined;
  withdrawRelativeBlockLocktime?: number | undefined;
  tokenPublicKey?: Uint8Array | undefined;
  tokenIdentifier?:
    | Uint8Array
    | undefined;
  /** Decoded uint128 */
  tokenAmount: Uint8Array;
}

/**
 * This proto is constructed by the wallet and is the core transaction data structure.
 * This proto is deterministically hashed to generate the token_transaction_hash that
 * is cooperatively signed by the SO group to confirm a token transaction.
 */
export interface TokenTransaction {
  tokenInputs?:
    | { $case: "mintInput"; mintInput: TokenMintInput }
    | { $case: "transferInput"; transferInput: TokenTransferInput }
    | { $case: "createInput"; createInput: TokenCreateInput }
    | undefined;
  tokenOutputs: TokenOutput[];
  sparkOperatorIdentityPublicKeys: Uint8Array[];
  network: Network;
}

export interface SpentTokenOutputMetadata {
  outputId: string;
  revocationSecret: Uint8Array;
}

export interface TokenTransactionConfirmationMetadata {
  spentTokenOutputsMetadata: SpentTokenOutputMetadata[];
}

export interface TokenTransactionWithStatus {
  tokenTransaction: TokenTransaction | undefined;
  status: TokenTransactionStatus;
  confirmationMetadata: TokenTransactionConfirmationMetadata | undefined;
  tokenTransactionHash: Uint8Array;
}

export interface SignatureWithIndex {
  /** This is a Schnorr or ECDSA DER signature which can be between 64 and 73 bytes. */
  signature: Uint8Array;
  /** The index of the TTXO associated with this signature. */
  inputIndex: number;
}

export interface TokenTransactionSignatures {
  /**
   * Filled by signing the partial token transaction hash with the owner/issuer private key.
   * For mint transactions this will be one signature for the input token_public_key
   * For transfer transactions this will be one for each output for the output owner_public_key
   */
  ownerSignatures: SignatureWithIndex[];
}

export interface StartTokenTransactionRequest {
  identityPublicKey: Uint8Array;
  partialTokenTransaction:
    | TokenTransaction
    | undefined;
  /** List of ecdsa signatures authorizing movement of tokens from the token input. */
  tokenTransactionSignatures: TokenTransactionSignatures | undefined;
  sparkPaymentIntent: string;
}

export interface StartTokenTransactionResponse {
  /**
   * This is the same token transaction sent by the wallet with output revocation public keys
   * filled. This is the final transaction that is published and gossiped among LRC20 nodes.
   */
  finalTokenTransaction:
    | TokenTransaction
    | undefined;
  /**
   * Information for fetching and resolving the revocation keyshare on a transfer operation.
   * Contains the threshold of keyshares needed and the SO owners of those keyshares.
   */
  keyshareInfo: SigningKeyshare | undefined;
}

export interface OperatorSpecificTokenTransactionSignablePayload {
  finalTokenTransactionHash: Uint8Array;
  operatorIdentityPublicKey: Uint8Array;
}

/**
 * This message allows the sender of a output being spent to provide final evidence
 * that it owns a output to an SO when requesting signing and release of the  revocation keyshare.
 */
export interface OperatorSpecificOwnerSignature {
  ownerSignature: SignatureWithIndex | undefined;
  payload: OperatorSpecificTokenTransactionSignablePayload | undefined;
}

export interface SignTokenTransactionRequest {
  finalTokenTransaction: TokenTransaction | undefined;
  operatorSpecificSignatures: OperatorSpecificOwnerSignature[];
  identityPublicKey: Uint8Array;
}

export interface KeyshareWithIndex {
  /** The index of the input TTXO associated with this keyshare. */
  inputIndex: number;
  keyshare: Uint8Array;
}

export interface SignTokenTransactionResponse {
  sparkOperatorSignature: Uint8Array;
  revocationKeyshares: KeyshareWithIndex[];
}

export interface RevocationSecretWithIndex {
  /** The index of the input TTXO associated with this secret. */
  inputIndex: number;
  revocationSecret: Uint8Array;
}

export interface FinalizeTokenTransactionRequest {
  finalTokenTransaction:
    | TokenTransaction
    | undefined;
  /**
   * List of ordered revocation secrets that map 1:1 with leaves being spent in the
   * token transaction.
   */
  revocationSecrets: RevocationSecretWithIndex[];
  identityPublicKey: Uint8Array;
  sparkPaymentIntent: string;
}

export interface FreezeTokensPayload {
  ownerPublicKey: Uint8Array;
  tokenPublicKey: Uint8Array;
  issuerProvidedTimestamp: number;
  operatorIdentityPublicKey: Uint8Array;
  /** Set to false when requesting a freeze. */
  shouldUnfreeze: boolean;
  tokenIdentifier?: Uint8Array | undefined;
}

export interface FreezeTokensRequest {
  freezeTokensPayload:
    | FreezeTokensPayload
    | undefined;
  /** This is a Schnorr or ECDSA DER signature which can be between 64 and 73 bytes. */
  issuerSignature: Uint8Array;
}

export interface FreezeTokensResponse {
  impactedOutputIds: string[];
  /** Decoded uint128 */
  impactedTokenAmount: Uint8Array;
}

export interface QueryTokenOutputsRequest {
  ownerPublicKeys: Uint8Array[];
  /** Optionally provide token public keys. If not set return leaves for all tokens. */
  tokenPublicKeys: Uint8Array[];
  tokenIdentifiers: Uint8Array[];
  /** defaults to mainnet when no network is provided. */
  network: Network;
}

/** Request constraints are combined using an AND relation. */
export interface QueryTokenTransactionsRequest {
  /** Returns transactions that have one of these output ids in the input or output. */
  outputIds: string[];
  /** Returns transactions that have this owner public key as the sender or receiver in one or more of the input/output leaves. */
  ownerPublicKeys: Uint8Array[];
  /** Returns transactions that related to this token public key. */
  tokenPublicKeys: Uint8Array[];
  /** Returns transactions that related to this token identifier. */
  tokenIdentifiers: Uint8Array[];
  /** Returns transactions that match the provided transaction hashes. */
  tokenTransactionHashes: Uint8Array[];
  limit: number;
  offset: number;
}

export interface QueryTokenTransactionsResponse {
  tokenTransactionsWithStatus: TokenTransactionWithStatus[];
  offset: number;
}

export interface OutputWithPreviousTransactionData {
  output: TokenOutput | undefined;
  previousTransactionHash: Uint8Array;
  previousTransactionVout: number;
}

export interface QueryTokenOutputsResponse {
  outputsWithPreviousTransactionData: OutputWithPreviousTransactionData[];
}

/** TreeNode represents a node on the tree. */
export interface TreeNode {
  /** The id of the node. */
  id: string;
  /** The id of the tree for this node . */
  treeId: string;
  /** The value that this node holds. */
  value: number;
  /** The id of the parent node. */
  parentNodeId?:
    | string
    | undefined;
  /** The cpfp transaction of the node, this transaction is to pay to the same address as the node. */
  nodeTx: Uint8Array;
  /** The refund transaction of the node, this transaction is to pay to the user. */
  refundTx: Uint8Array;
  /** This vout is the vout to spend the previous transaction, which is in the parent node. */
  vout: number;
  /** The verifying public key of the node. */
  verifyingPublicKey: Uint8Array;
  /** The identity public key of the owner of the node. */
  ownerIdentityPublicKey: Uint8Array;
  /** The signing keyshare information of the node on the SE side. */
  signingKeyshare:
    | SigningKeyshare
    | undefined;
  /** The status of the node. */
  status: string;
  /** The network of the node. */
  network: Network;
  /** The creation time of the node. */
  createdTime:
    | Date
    | undefined;
  /** The latest update time of the node. */
  updatedTime:
    | Date
    | undefined;
  /** The signing public key of the owner of the node. */
  ownerSigningPublicKey: Uint8Array;
  /** The direct transaction of the node, this transaction is for the watchtower to broadcast. */
  directTx: Uint8Array;
  /** The refund transaction of the node, this transaction is to pay to the user. */
  directRefundTx: Uint8Array;
  /** The refund transaction of the node, this transaction is to pay to the user. */
  directFromCpfpRefundTx: Uint8Array;
}

/** FinalizeNodeSignaturesRequest is the request to finalize the signatures for a node. */
export interface FinalizeNodeSignaturesRequest {
  /** The intent of the signature. */
  intent: SignatureIntent;
  /** The signatures for the node. */
  nodeSignatures: NodeSignatures[];
}

/** FinalizeNodeSignaturesResponse is the response to the request to finalize the signatures for a node. */
export interface FinalizeNodeSignaturesResponse {
  /** The nodes that are finalized. */
  nodes: TreeNode[];
}

/**
 * SecretShare is a secret share of a secret, using Feldman VSS.
 * The secret share is in the field of secp256k1 scalar field.
 */
export interface SecretShare {
  /** The secret share. */
  secretShare: Uint8Array;
  /**
   * The proofs for the secret share. They are the compressed public keys in secp256k1 curve.
   * proofs[0] is the public key of the secret, while proofs[1..n] are the public key of the polynomial.
   */
  proofs: Uint8Array[];
}

/**
 * SecretProof is the proof for a secret share using Feldman VSS.
 * The proof is the compressed public keys in secp256k1 curve.
 */
export interface SecretProof {
  /**
   * The proofs for the secret share.
   * proofs[0] is the public key of the secret, while proofs[1..n] are the public key of the polynomial.
   */
  proofs: Uint8Array[];
}

export interface LeafRefundTxSigningJob {
  leafId: string;
  refundTxSigningJob: SigningJob | undefined;
  directRefundTxSigningJob: SigningJob | undefined;
  directFromCpfpRefundTxSigningJob: SigningJob | undefined;
}

export interface UserSignedTxSigningJob {
  leafId: string;
  signingPublicKey: Uint8Array;
  rawTx: Uint8Array;
  signingNonceCommitment: SigningCommitment | undefined;
  userSignature: Uint8Array;
  signingCommitments: SigningCommitments | undefined;
}

export interface LeafRefundTxSigningResult {
  leafId: string;
  refundTxSigningResult: SigningResult | undefined;
  verifyingKey: Uint8Array;
  directRefundTxSigningResult: SigningResult | undefined;
  directFromCpfpRefundTxSigningResult: SigningResult | undefined;
}

export interface StartUserSignedTransferRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  leavesToSend: UserSignedTxSigningJob[];
  receiverIdentityPublicKey: Uint8Array;
  expiryTime: Date | undefined;
  directLeavesToSend: UserSignedTxSigningJob[];
  directFromCpfpLeavesToSend: UserSignedTxSigningJob[];
}

export interface StartTransferRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  /**
   * This field is used for swap and coop exits. Regular transfers must use
   * the transfer_package field.
   */
  leavesToSend: LeafRefundTxSigningJob[];
  receiverIdentityPublicKey: Uint8Array;
  expiryTime:
    | Date
    | undefined;
  /**
   * This field is required for transfers of type "transfer". If this field
   * is set, the leaves_to_send and key_tweak_proofs will be ignored.
   */
  transferPackage:
    | TransferPackage
    | undefined;
  /** The invoice this transfer pays. */
  sparkInvoice: string;
}

export interface StartTransferResponse {
  transfer: Transfer | undefined;
  signingResults: LeafRefundTxSigningResult[];
}

/**
 * TransferPackage is a package of leaves to send and key tweaks to send.
 * This is in the improved send transfer flow where the sender can send the transfer in one call to
 * the coordinator SO.
 */
export interface TransferPackage {
  /** The leaves to send, with user signed cpfp refunds and signing package. */
  leavesToSend: UserSignedTxSigningJob[];
  /** The map of SO identifier to ciphertext of SendLeafTweaks. */
  keyTweakPackage: { [key: string]: Uint8Array };
  /** The signature of user to prove that the key_tweak_package is not tampered. */
  userSignature: Uint8Array;
  /** The leaves to send, with user signed direct refunds and signing package. */
  directLeavesToSend: UserSignedTxSigningJob[];
  /** The leaves to send, with user signed direct from cpfp refunds and signing package. */
  directFromCpfpLeavesToSend: UserSignedTxSigningJob[];
}

export interface TransferPackage_KeyTweakPackageEntry {
  key: string;
  value: Uint8Array;
}

export interface SendLeafKeyTweaks {
  leavesToSend: SendLeafKeyTweak[];
}

export interface SendLeafKeyTweak {
  leafId: string;
  secretShareTweak: SecretShare | undefined;
  pubkeySharesTweak: { [key: string]: Uint8Array };
  secretCipher: Uint8Array;
  /** Signature over Sha256(leaf_id||transfer_id||secret_cipher) */
  signature: Uint8Array;
  refundSignature: Uint8Array;
  directRefundSignature: Uint8Array;
  directFromCpfpRefundSignature: Uint8Array;
}

export interface SendLeafKeyTweak_PubkeySharesTweakEntry {
  key: string;
  value: Uint8Array;
}

export interface FinalizeTransferRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  leavesToSend: SendLeafKeyTweak[];
  sparkPaymentIntent: string;
}

export interface FinalizeTransferWithTransferPackageRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  transferPackage: TransferPackage | undefined;
}

export interface FinalizeTransferResponse {
  transfer: Transfer | undefined;
}

export interface Transfer {
  id: string;
  senderIdentityPublicKey: Uint8Array;
  receiverIdentityPublicKey: Uint8Array;
  status: TransferStatus;
  totalValue: number;
  expiryTime: Date | undefined;
  leaves: TransferLeaf[];
  createdTime: Date | undefined;
  updatedTime: Date | undefined;
  type: TransferType;
  sparkInvoice: string;
}

export interface TransferLeaf {
  leaf: TreeNode | undefined;
  secretCipher: Uint8Array;
  signature: Uint8Array;
  intermediateRefundTx: Uint8Array;
  intermediateDirectRefundTx: Uint8Array;
  intermediateDirectFromCpfpRefundTx: Uint8Array;
  pendingKeyTweakPublicKey: Uint8Array;
}

export interface TransferFilter {
  participant?: { $case: "receiverIdentityPublicKey"; receiverIdentityPublicKey: Uint8Array } | {
    $case: "senderIdentityPublicKey";
    senderIdentityPublicKey: Uint8Array;
  } | //
  /** This will include transfers where this public key is the sender or receiver. */
  { $case: "senderOrReceiverIdentityPublicKey"; senderOrReceiverIdentityPublicKey: Uint8Array } | undefined;
  transferIds: string[];
  limit: number;
  offset: number;
  types: TransferType[];
  /** defaults to mainnet when no network is provided. */
  network: Network;
  statuses: TransferStatus[];
  order: Order;
}

export interface QueryTransfersResponse {
  transfers: Transfer[];
  offset: number;
}

export interface ClaimLeafKeyTweak {
  leafId: string;
  secretShareTweak: SecretShare | undefined;
  pubkeySharesTweak: { [key: string]: Uint8Array };
}

export interface ClaimLeafKeyTweak_PubkeySharesTweakEntry {
  key: string;
  value: Uint8Array;
}

export interface ClaimTransferTweakKeysRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  leavesToReceive: ClaimLeafKeyTweak[];
}

export interface ClaimTransferSignRefundsRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  signingJobs: LeafRefundTxSigningJob[];
}

export interface ClaimTransferSignRefundsResponse {
  signingResults: LeafRefundTxSigningResult[];
}

export interface StorePreimageShareRequest {
  paymentHash: Uint8Array;
  preimageShare: SecretShare | undefined;
  threshold: number;
  invoiceString: string;
  userIdentityPublicKey: Uint8Array;
}

export interface RequestedSigningCommitments {
  signingNonceCommitments: { [key: string]: SigningCommitment };
}

export interface RequestedSigningCommitments_SigningNonceCommitmentsEntry {
  key: string;
  value: SigningCommitment | undefined;
}

export interface GetSigningCommitmentsRequest {
  nodeIds: string[];
  count: number;
}

export interface GetSigningCommitmentsResponse {
  signingCommitments: RequestedSigningCommitments[];
}

export interface SigningCommitments {
  signingCommitments: { [key: string]: SigningCommitment };
}

export interface SigningCommitments_SigningCommitmentsEntry {
  key: string;
  value: SigningCommitment | undefined;
}

export interface UserSignedRefund {
  nodeId: string;
  refundTx: Uint8Array;
  userSignature: Uint8Array;
  signingCommitments: SigningCommitments | undefined;
  userSignatureCommitment: SigningCommitment | undefined;
  network: Network;
}

export interface InvoiceAmountProof {
  bolt11Invoice: string;
}

export interface InvoiceAmount {
  valueSats: number;
  invoiceAmountProof: InvoiceAmountProof | undefined;
}

export interface InitiatePreimageSwapRequest {
  paymentHash: Uint8Array;
  invoiceAmount: InvoiceAmount | undefined;
  reason: InitiatePreimageSwapRequest_Reason;
  transfer: StartUserSignedTransferRequest | undefined;
  receiverIdentityPublicKey: Uint8Array;
  feeSats: number;
}

export enum InitiatePreimageSwapRequest_Reason {
  /** REASON_SEND - The associated lightning service is sending the payment. */
  REASON_SEND = 0,
  /** REASON_RECEIVE - The associated lightning service is receiving the payment. */
  REASON_RECEIVE = 1,
  UNRECOGNIZED = -1,
}

export function initiatePreimageSwapRequest_ReasonFromJSON(object: any): InitiatePreimageSwapRequest_Reason {
  switch (object) {
    case 0:
    case "REASON_SEND":
      return InitiatePreimageSwapRequest_Reason.REASON_SEND;
    case 1:
    case "REASON_RECEIVE":
      return InitiatePreimageSwapRequest_Reason.REASON_RECEIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InitiatePreimageSwapRequest_Reason.UNRECOGNIZED;
  }
}

export function initiatePreimageSwapRequest_ReasonToJSON(object: InitiatePreimageSwapRequest_Reason): string {
  switch (object) {
    case InitiatePreimageSwapRequest_Reason.REASON_SEND:
      return "REASON_SEND";
    case InitiatePreimageSwapRequest_Reason.REASON_RECEIVE:
      return "REASON_RECEIVE";
    case InitiatePreimageSwapRequest_Reason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface InitiatePreimageSwapResponse {
  preimage: Uint8Array;
  transfer: Transfer | undefined;
}

export interface OutPoint {
  txid: Uint8Array;
  vout: number;
}

export interface CooperativeExitRequest {
  transfer: StartTransferRequest | undefined;
  exitId: string;
  exitTxid: Uint8Array;
}

export interface CooperativeExitResponse {
  transfer: Transfer | undefined;
  signingResults: LeafRefundTxSigningResult[];
}

export interface CounterLeafSwapRequest {
  transfer: StartTransferRequest | undefined;
  swapId: string;
  adaptorPublicKey: Uint8Array;
  directAdaptorPublicKey: Uint8Array;
  directFromCpfpAdaptorPublicKey: Uint8Array;
}

export interface CounterLeafSwapResponse {
  transfer: Transfer | undefined;
  signingResults: LeafRefundTxSigningResult[];
}

export interface RefreshTimelockRequest {
  leafId: string;
  ownerIdentityPublicKey: Uint8Array;
  signingJobs: SigningJob[];
}

export interface RefreshTimelockSigningResult {
  signingResult:
    | SigningResult
    | undefined;
  /** Should maybe just be a part of SigningResult? */
  verifyingKey: Uint8Array;
}

export interface RefreshTimelockResponse {
  signingResults: RefreshTimelockSigningResult[];
}

export interface ExtendLeafRequest {
  leafId: string;
  ownerIdentityPublicKey: Uint8Array;
  nodeTxSigningJob: SigningJob | undefined;
  refundTxSigningJob: SigningJob | undefined;
  directNodeTxSigningJob: SigningJob | undefined;
  directRefundTxSigningJob: SigningJob | undefined;
  directFromCpfpRefundTxSigningJob: SigningJob | undefined;
}

export interface ExtendLeafSigningResult {
  signingResult: SigningResult | undefined;
  verifyingKey: Uint8Array;
}

export interface ExtendLeafResponse {
  leafId: string;
  nodeTxSigningResult: ExtendLeafSigningResult | undefined;
  refundTxSigningResult: ExtendLeafSigningResult | undefined;
  directNodeTxSigningResult: ExtendLeafSigningResult | undefined;
  directRefundTxSigningResult: ExtendLeafSigningResult | undefined;
  directFromCpfpRefundTxSigningResult: ExtendLeafSigningResult | undefined;
}

export interface AddressRequestNode {
  userPublicKey: Uint8Array;
  children: AddressRequestNode[];
}

export interface PrepareTreeAddressRequest {
  source?:
    | { $case: "parentNodeOutput"; parentNodeOutput: NodeOutput }
    | { $case: "onChainUtxo"; onChainUtxo: UTXO }
    | undefined;
  /**
   * The tx on this node is to spend the source's utxo.
   * The user's public key should already be registered with the SE for the root node.
   */
  node: AddressRequestNode | undefined;
  userIdentityPublicKey: Uint8Array;
}

export interface AddressNode {
  address: Address | undefined;
  children: AddressNode[];
}

export interface PrepareTreeAddressResponse {
  node: AddressNode | undefined;
}

export interface CreationNode {
  /** This is the cpfp tx that spends the parent node's output. */
  nodeTxSigningJob:
    | SigningJob
    | undefined;
  /** The refund tx can only exist if there's no children. */
  refundTxSigningJob:
    | SigningJob
    | undefined;
  /** The children will spend the output of the node's tx. Vout is the index of the child. */
  children: CreationNode[];
  /** This is the direct tx that spends the parent node's output. */
  directNodeTxSigningJob:
    | SigningJob
    | undefined;
  /** The direct refund tx can only exist if there's no children. */
  directRefundTxSigningJob:
    | SigningJob
    | undefined;
  /** The direct from cpfp refund tx can only exist if there's no children. */
  directFromCpfpRefundTxSigningJob: SigningJob | undefined;
}

export interface CreateTreeRequest {
  source?:
    | { $case: "parentNodeOutput"; parentNodeOutput: NodeOutput }
    | { $case: "onChainUtxo"; onChainUtxo: UTXO }
    | undefined;
  /** The node should contain the tx that spends the source's utxo. */
  node:
    | CreationNode
    | undefined;
  /** The owner of the tree. */
  userIdentityPublicKey: Uint8Array;
}

export interface CreationResponseNode {
  nodeId: string;
  nodeTxSigningResult: SigningResult | undefined;
  refundTxSigningResult: SigningResult | undefined;
  children: CreationResponseNode[];
  directNodeTxSigningResult: SigningResult | undefined;
  directRefundTxSigningResult: SigningResult | undefined;
  directFromCpfpRefundTxSigningResult: SigningResult | undefined;
}

export interface CreateTreeResponse {
  node: CreationResponseNode | undefined;
}

export interface SigningOperatorInfo {
  index: number;
  identifier: string;
  publicKey: Uint8Array;
  address: string;
}

export interface GetSigningOperatorListResponse {
  signingOperators: { [key: string]: SigningOperatorInfo };
}

export interface GetSigningOperatorListResponse_SigningOperatorsEntry {
  key: string;
  value: SigningOperatorInfo | undefined;
}

export interface QueryUserSignedRefundsRequest {
  paymentHash: Uint8Array;
  identityPublicKey: Uint8Array;
}

export interface QueryUserSignedRefundsResponse {
  userSignedRefunds: UserSignedRefund[];
  transfer: Transfer | undefined;
}

export interface ProvidePreimageRequest {
  paymentHash: Uint8Array;
  preimage: Uint8Array;
  identityPublicKey: Uint8Array;
}

export interface ProvidePreimageResponse {
  transfer: Transfer | undefined;
}

export interface ReturnLightningPaymentRequest {
  paymentHash: Uint8Array;
  userIdentityPublicKey: Uint8Array;
}

export interface TreeNodeIds {
  nodeIds: string[];
}

export interface QueryNodesRequest {
  source?: { $case: "ownerIdentityPubkey"; ownerIdentityPubkey: Uint8Array } | {
    $case: "nodeIds";
    nodeIds: TreeNodeIds;
  } | undefined;
  includeParents: boolean;
  limit: number;
  offset: number;
  /** defaults to mainnet when no network is provided. Does not check network when querying by node_ids */
  network: Network;
}

export interface QueryNodesResponse {
  nodes: { [key: string]: TreeNode };
  offset: number;
}

export interface QueryNodesResponse_NodesEntry {
  key: string;
  value: TreeNode | undefined;
}

export interface CancelTransferRequest {
  transferId: string;
  senderIdentityPublicKey: Uint8Array;
}

export interface CancelTransferResponse {
  transfer: Transfer | undefined;
}

/**
 * Returns a list of addresses that can be used in express deposit flow.
 * Excludes static deposit addresses.
 */
export interface QueryUnusedDepositAddressesRequest {
  identityPublicKey: Uint8Array;
  /** defaults to mainnet when no network is provided. */
  network: Network;
  /** defaults to 100 if not set. */
  limit: number;
  /** defaults to 0 if not set. */
  offset: number;
}

export interface QueryStaticDepositAddressesRequest {
  identityPublicKey: Uint8Array;
  /** defaults to mainnet when no network is provided. */
  network: Network;
  limit: number;
  offset: number;
  /** Optional filter. When specified, only the DepositAddress with this address is returned. */
  depositAddress?: string | undefined;
}

export interface DepositAddressQueryResult {
  depositAddress: string;
  userSigningPublicKey: Uint8Array;
  verifyingPublicKey: Uint8Array;
  leafId?: string | undefined;
  proofOfPossession?: DepositAddressProof | undefined;
}

export interface QueryUnusedDepositAddressesResponse {
  depositAddresses: DepositAddressQueryResult[];
  /** defaults to -1 if there are no more results */
  offset: number;
}

export interface QueryStaticDepositAddressesResponse {
  depositAddresses: DepositAddressQueryResult[];
}

export interface QueryBalanceRequest {
  identityPublicKey: Uint8Array;
  /** defaults to mainnet when no network is provided. */
  network: Network;
}

export interface QueryBalanceResponse {
  balance: number;
  nodeBalances: { [key: string]: number };
}

export interface QueryBalanceResponse_NodeBalancesEntry {
  key: string;
  value: number;
}

export interface SparkAddress {
  identityPublicKey: Uint8Array;
  sparkInvoiceFields: SparkInvoiceFields | undefined;
  signature?: Uint8Array | undefined;
}

export interface SparkInvoiceFields {
  version: number;
  id: Uint8Array;
  paymentType?: { $case: "tokensPayment"; tokensPayment: TokensPayment } | {
    $case: "satsPayment";
    satsPayment: SatsPayment;
  } | undefined;
  memo?: string | undefined;
  senderPublicKey?: Uint8Array | undefined;
  expiryTime?: Date | undefined;
}

export interface SatsPayment {
  amount?: number | undefined;
}

export interface TokensPayment {
  tokenIdentifier?:
    | Uint8Array
    | undefined;
  /** variable length uint128 */
  amount?: Uint8Array | undefined;
}

export interface InitiateStaticDepositUtxoRefundRequest {
  onChainUtxo:
    | UTXO
    | undefined;
  /**
   * A package that is used for signing L1 Bitcoin transactions using FROST.
   * SE consumes it to return SigningResult structure, that is used by the user to
   * construct the final signature for the refund Bitcoin transaction.
   */
  refundTxSigningJob:
    | SigningJob
    | undefined;
  /**
   * Signature of a user statement that authorises the SE to initiate a static
   * deposit utxo refund to the user.
   *
   * The user statement is constructed by concatenating the following fields in order:
   * 1. Action name: "claim_static_deposit" (UTF-8 string)
   * 2. Network: lowercase network name (e.g., "bitcoin", "testnet") (UTF-8 string)
   * 3. Transaction ID: hex-encoded UTXO transaction ID (UTF-8 string)
   * 4. Output index: UTXO output index (vout) as 4-byte unsigned integer (little-endian)
   * 5. Request type: 2 for refund (1-byte unsigned integer, little-endian)
   * 6. Credit amount: amount of satoshis to credit as 8-byte unsigned integer (little-endian)
   * 7. Signing payload: sighash of spend transaction (UTF-8 string)
   *
   * The concatenated payload is then hashed with SHA-256, and the resulting hash
   * is signed using ECDSA with the user's identity private key to produce this signature.
   */
  userSignature: Uint8Array;
}

export interface InitiateStaticDepositUtxoRefundResponse {
  /** The FROST signing results which must be aggregated by the user to complete signing */
  refundTxSigningResult: SigningResult | undefined;
  depositAddress: DepositAddressQueryResult | undefined;
}

export interface InitiateUtxoSwapRequest {
  onChainUtxo: UTXO | undefined;
  requestType: UtxoSwapRequestType;
  amount?:
    | { $case: "creditAmountSats"; creditAmountSats: number }
    | { $case: "maxFeeSats"; maxFeeSats: number }
    | undefined;
  sspSignature: Uint8Array;
  userSignature: Uint8Array;
  transfer: StartTransferRequest | undefined;
  spendTxSigningJob: SigningJob | undefined;
}

export interface InitiateUtxoSwapResponse {
  spendTxSigningResult: SigningResult | undefined;
  transfer: Transfer | undefined;
  depositAddress: DepositAddressQueryResult | undefined;
}

export interface ExitingTree {
  treeId: string;
  userSigningCommitment: SigningCommitment | undefined;
  vin: number;
}

export interface ExitSingleNodeTreeSigningResult {
  treeId: string;
  signingResult: SigningResult | undefined;
  verifyingKey: Uint8Array;
}

export interface BitcoinTransactionOutput {
  value: number;
  pkScript: Uint8Array;
}

export interface ExitSingleNodeTreesRequest {
  ownerIdentityPublicKey: Uint8Array;
  exitingTrees: ExitingTree[];
  rawTx: Uint8Array;
  previousOutputs: BitcoinTransactionOutput[];
}

export interface ExitSingleNodeTreesResponse {
  signingResults: ExitSingleNodeTreeSigningResult[];
}

export interface InvestigateLeavesRequest {
  leafIds: string[];
  ownerIdentityPublicKey: Uint8Array;
  transferId: string;
}

export interface QueryNodesDistributionRequest {
  ownerIdentityPublicKey: Uint8Array;
}

export interface QueryNodesDistributionResponse {
  nodeDistribution: { [key: number]: number };
}

export interface QueryNodesDistributionResponse_NodeDistributionEntry {
  key: number;
  value: number;
}

export interface QueryNodesByValueRequest {
  ownerIdentityPublicKey: Uint8Array;
  value: number;
  offset: number;
  limit: number;
}

export interface QueryNodesByValueResponse {
  nodes: { [key: string]: TreeNode };
  offset: number;
}

export interface QueryNodesByValueResponse_NodesEntry {
  key: string;
  value: TreeNode | undefined;
}

export interface GetUtxosForAddressRequest {
  address: string;
  offset: number;
  limit: number;
  network: Network;
  excludeClaimed: boolean;
}

export interface GetUtxosForAddressResponse {
  utxos: UTXO[];
  offset: number;
}

export interface QuerySparkInvoicesRequest {
  limit: number;
  offset: number;
  /** returns the status for the provided list of spark invoices. */
  invoice: string[];
}

export interface QuerySparkInvoicesResponse {
  offset: number;
  invoiceStatuses: InvoiceResponse[];
}

export interface InvoiceResponse {
  invoice: string;
  status: InvoiceStatus;
  transferType?: { $case: "satsTransfer"; satsTransfer: SatsTransfer } | {
    $case: "tokenTransfer";
    tokenTransfer: TokenTransfer;
  } | undefined;
}

export interface SatsTransfer {
  transferId: Uint8Array;
}

export interface TokenTransfer {
  finalTokenTransactionHash: Uint8Array;
}

function createBaseSubscribeToEventsRequest(): SubscribeToEventsRequest {
  return { identityPublicKey: new Uint8Array(0) };
}

export const SubscribeToEventsRequest: MessageFns<SubscribeToEventsRequest> = {
  encode(message: SubscribeToEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(82).bytes(message.identityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeToEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeToEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeToEventsRequest {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SubscribeToEventsRequest): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribeToEventsRequest>): SubscribeToEventsRequest {
    return SubscribeToEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeToEventsRequest>): SubscribeToEventsRequest {
    const message = createBaseSubscribeToEventsRequest();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubscribeToEventsResponse(): SubscribeToEventsResponse {
  return { event: undefined };
}

export const SubscribeToEventsResponse: MessageFns<SubscribeToEventsResponse> = {
  encode(message: SubscribeToEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.event?.$case) {
      case "transfer":
        TransferEvent.encode(message.event.transfer, writer.uint32(10).fork()).join();
        break;
      case "deposit":
        DepositEvent.encode(message.event.deposit, writer.uint32(18).fork()).join();
        break;
      case "connected":
        ConnectedEvent.encode(message.event.connected, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeToEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeToEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = { $case: "transfer", transfer: TransferEvent.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.event = { $case: "deposit", deposit: DepositEvent.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.event = { $case: "connected", connected: ConnectedEvent.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeToEventsResponse {
    return {
      event: isSet(object.transfer)
        ? { $case: "transfer", transfer: TransferEvent.fromJSON(object.transfer) }
        : isSet(object.deposit)
        ? { $case: "deposit", deposit: DepositEvent.fromJSON(object.deposit) }
        : isSet(object.connected)
        ? { $case: "connected", connected: ConnectedEvent.fromJSON(object.connected) }
        : undefined,
    };
  },

  toJSON(message: SubscribeToEventsResponse): unknown {
    const obj: any = {};
    if (message.event?.$case === "transfer") {
      obj.transfer = TransferEvent.toJSON(message.event.transfer);
    } else if (message.event?.$case === "deposit") {
      obj.deposit = DepositEvent.toJSON(message.event.deposit);
    } else if (message.event?.$case === "connected") {
      obj.connected = ConnectedEvent.toJSON(message.event.connected);
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribeToEventsResponse>): SubscribeToEventsResponse {
    return SubscribeToEventsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeToEventsResponse>): SubscribeToEventsResponse {
    const message = createBaseSubscribeToEventsResponse();
    switch (object.event?.$case) {
      case "transfer": {
        if (object.event?.transfer !== undefined && object.event?.transfer !== null) {
          message.event = { $case: "transfer", transfer: TransferEvent.fromPartial(object.event.transfer) };
        }
        break;
      }
      case "deposit": {
        if (object.event?.deposit !== undefined && object.event?.deposit !== null) {
          message.event = { $case: "deposit", deposit: DepositEvent.fromPartial(object.event.deposit) };
        }
        break;
      }
      case "connected": {
        if (object.event?.connected !== undefined && object.event?.connected !== null) {
          message.event = { $case: "connected", connected: ConnectedEvent.fromPartial(object.event.connected) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseConnectedEvent(): ConnectedEvent {
  return {};
}

export const ConnectedEvent: MessageFns<ConnectedEvent> = {
  encode(_: ConnectedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ConnectedEvent {
    return {};
  },

  toJSON(_: ConnectedEvent): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ConnectedEvent>): ConnectedEvent {
    return ConnectedEvent.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ConnectedEvent>): ConnectedEvent {
    const message = createBaseConnectedEvent();
    return message;
  },
};

function createBaseTransferEvent(): TransferEvent {
  return { transfer: undefined };
}

export const TransferEvent: MessageFns<TransferEvent> = {
  encode(message: TransferEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferEvent {
    return { transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined };
  },

  toJSON(message: TransferEvent): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferEvent>): TransferEvent {
    return TransferEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferEvent>): TransferEvent {
    const message = createBaseTransferEvent();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    return message;
  },
};

function createBaseDepositEvent(): DepositEvent {
  return { deposit: undefined };
}

export const DepositEvent: MessageFns<DepositEvent> = {
  encode(message: DepositEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deposit !== undefined) {
      TreeNode.encode(message.deposit, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.deposit = TreeNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositEvent {
    return { deposit: isSet(object.deposit) ? TreeNode.fromJSON(object.deposit) : undefined };
  },

  toJSON(message: DepositEvent): unknown {
    const obj: any = {};
    if (message.deposit !== undefined) {
      obj.deposit = TreeNode.toJSON(message.deposit);
    }
    return obj;
  },

  create(base?: DeepPartial<DepositEvent>): DepositEvent {
    return DepositEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DepositEvent>): DepositEvent {
    const message = createBaseDepositEvent();
    message.deposit = (object.deposit !== undefined && object.deposit !== null)
      ? TreeNode.fromPartial(object.deposit)
      : undefined;
    return message;
  },
};

function createBasePageRequest(): PageRequest {
  return { pageSize: 0, cursor: "", direction: 0 };
}

export const PageRequest: MessageFns<PageRequest> = {
  encode(message: PageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.cursor !== "") {
      writer.uint32(18).string(message.cursor);
    }
    if (message.direction !== 0) {
      writer.uint32(24).int32(message.direction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PageRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
      direction: isSet(object.direction) ? directionFromJSON(object.direction) : 0,
    };
  },

  toJSON(message: PageRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    if (message.direction !== 0) {
      obj.direction = directionToJSON(message.direction);
    }
    return obj;
  },

  create(base?: DeepPartial<PageRequest>): PageRequest {
    return PageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PageRequest>): PageRequest {
    const message = createBasePageRequest();
    message.pageSize = object.pageSize ?? 0;
    message.cursor = object.cursor ?? "";
    message.direction = object.direction ?? 0;
    return message;
  },
};

function createBasePageResponse(): PageResponse {
  return { hasNextPage: false, hasPreviousPage: false, nextCursor: "", previousCursor: "" };
}

export const PageResponse: MessageFns<PageResponse> = {
  encode(message: PageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasNextPage !== false) {
      writer.uint32(8).bool(message.hasNextPage);
    }
    if (message.hasPreviousPage !== false) {
      writer.uint32(16).bool(message.hasPreviousPage);
    }
    if (message.nextCursor !== "") {
      writer.uint32(26).string(message.nextCursor);
    }
    if (message.previousCursor !== "") {
      writer.uint32(34).string(message.previousCursor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasNextPage = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hasPreviousPage = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nextCursor = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.previousCursor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PageResponse {
    return {
      hasNextPage: isSet(object.hasNextPage) ? globalThis.Boolean(object.hasNextPage) : false,
      hasPreviousPage: isSet(object.hasPreviousPage) ? globalThis.Boolean(object.hasPreviousPage) : false,
      nextCursor: isSet(object.nextCursor) ? globalThis.String(object.nextCursor) : "",
      previousCursor: isSet(object.previousCursor) ? globalThis.String(object.previousCursor) : "",
    };
  },

  toJSON(message: PageResponse): unknown {
    const obj: any = {};
    if (message.hasNextPage !== false) {
      obj.hasNextPage = message.hasNextPage;
    }
    if (message.hasPreviousPage !== false) {
      obj.hasPreviousPage = message.hasPreviousPage;
    }
    if (message.nextCursor !== "") {
      obj.nextCursor = message.nextCursor;
    }
    if (message.previousCursor !== "") {
      obj.previousCursor = message.previousCursor;
    }
    return obj;
  },

  create(base?: DeepPartial<PageResponse>): PageResponse {
    return PageResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PageResponse>): PageResponse {
    const message = createBasePageResponse();
    message.hasNextPage = object.hasNextPage ?? false;
    message.hasPreviousPage = object.hasPreviousPage ?? false;
    message.nextCursor = object.nextCursor ?? "";
    message.previousCursor = object.previousCursor ?? "";
    return message;
  },
};

function createBaseDepositAddressProof(): DepositAddressProof {
  return { addressSignatures: {}, proofOfPossessionSignature: new Uint8Array(0) };
}

export const DepositAddressProof: MessageFns<DepositAddressProof> = {
  encode(message: DepositAddressProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.addressSignatures).forEach(([key, value]) => {
      DepositAddressProof_AddressSignaturesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.proofOfPossessionSignature.length !== 0) {
      writer.uint32(18).bytes(message.proofOfPossessionSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositAddressProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositAddressProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = DepositAddressProof_AddressSignaturesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.addressSignatures[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proofOfPossessionSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositAddressProof {
    return {
      addressSignatures: isObject(object.addressSignatures)
        ? Object.entries(object.addressSignatures).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      proofOfPossessionSignature: isSet(object.proofOfPossessionSignature)
        ? bytesFromBase64(object.proofOfPossessionSignature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: DepositAddressProof): unknown {
    const obj: any = {};
    if (message.addressSignatures) {
      const entries = Object.entries(message.addressSignatures);
      if (entries.length > 0) {
        obj.addressSignatures = {};
        entries.forEach(([k, v]) => {
          obj.addressSignatures[k] = base64FromBytes(v);
        });
      }
    }
    if (message.proofOfPossessionSignature.length !== 0) {
      obj.proofOfPossessionSignature = base64FromBytes(message.proofOfPossessionSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<DepositAddressProof>): DepositAddressProof {
    return DepositAddressProof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DepositAddressProof>): DepositAddressProof {
    const message = createBaseDepositAddressProof();
    message.addressSignatures = Object.entries(object.addressSignatures ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.proofOfPossessionSignature = object.proofOfPossessionSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDepositAddressProof_AddressSignaturesEntry(): DepositAddressProof_AddressSignaturesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const DepositAddressProof_AddressSignaturesEntry: MessageFns<DepositAddressProof_AddressSignaturesEntry> = {
  encode(message: DepositAddressProof_AddressSignaturesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositAddressProof_AddressSignaturesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositAddressProof_AddressSignaturesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositAddressProof_AddressSignaturesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: DepositAddressProof_AddressSignaturesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<DepositAddressProof_AddressSignaturesEntry>): DepositAddressProof_AddressSignaturesEntry {
    return DepositAddressProof_AddressSignaturesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DepositAddressProof_AddressSignaturesEntry>,
  ): DepositAddressProof_AddressSignaturesEntry {
    const message = createBaseDepositAddressProof_AddressSignaturesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGenerateDepositAddressRequest(): GenerateDepositAddressRequest {
  return {
    signingPublicKey: new Uint8Array(0),
    identityPublicKey: new Uint8Array(0),
    network: 0,
    leafId: undefined,
    isStatic: undefined,
  };
}

export const GenerateDepositAddressRequest: MessageFns<GenerateDepositAddressRequest> = {
  encode(message: GenerateDepositAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signingPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.signingPublicKey);
    }
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.identityPublicKey);
    }
    if (message.network !== 0) {
      writer.uint32(24).int32(message.network);
    }
    if (message.leafId !== undefined) {
      writer.uint32(34).string(message.leafId);
    }
    if (message.isStatic !== undefined) {
      writer.uint32(40).bool(message.isStatic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateDepositAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateDepositAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isStatic = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateDepositAddressRequest {
    return {
      signingPublicKey: isSet(object.signingPublicKey) ? bytesFromBase64(object.signingPublicKey) : new Uint8Array(0),
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : undefined,
      isStatic: isSet(object.isStatic) ? globalThis.Boolean(object.isStatic) : undefined,
    };
  },

  toJSON(message: GenerateDepositAddressRequest): unknown {
    const obj: any = {};
    if (message.signingPublicKey.length !== 0) {
      obj.signingPublicKey = base64FromBytes(message.signingPublicKey);
    }
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    if (message.leafId !== undefined) {
      obj.leafId = message.leafId;
    }
    if (message.isStatic !== undefined) {
      obj.isStatic = message.isStatic;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateDepositAddressRequest>): GenerateDepositAddressRequest {
    return GenerateDepositAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateDepositAddressRequest>): GenerateDepositAddressRequest {
    const message = createBaseGenerateDepositAddressRequest();
    message.signingPublicKey = object.signingPublicKey ?? new Uint8Array(0);
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.network = object.network ?? 0;
    message.leafId = object.leafId ?? undefined;
    message.isStatic = object.isStatic ?? undefined;
    return message;
  },
};

function createBaseAddress(): Address {
  return { address: "", verifyingKey: new Uint8Array(0), depositAddressProof: undefined, isStatic: false };
}

export const Address: MessageFns<Address> = {
  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(18).bytes(message.verifyingKey);
    }
    if (message.depositAddressProof !== undefined) {
      DepositAddressProof.encode(message.depositAddressProof, writer.uint32(26).fork()).join();
    }
    if (message.isStatic !== false) {
      writer.uint32(40).bool(message.isStatic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.depositAddressProof = DepositAddressProof.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isStatic = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
      depositAddressProof: isSet(object.depositAddressProof)
        ? DepositAddressProof.fromJSON(object.depositAddressProof)
        : undefined,
      isStatic: isSet(object.isStatic) ? globalThis.Boolean(object.isStatic) : false,
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    if (message.depositAddressProof !== undefined) {
      obj.depositAddressProof = DepositAddressProof.toJSON(message.depositAddressProof);
    }
    if (message.isStatic !== false) {
      obj.isStatic = message.isStatic;
    }
    return obj;
  },

  create(base?: DeepPartial<Address>): Address {
    return Address.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Address>): Address {
    const message = createBaseAddress();
    message.address = object.address ?? "";
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    message.depositAddressProof = (object.depositAddressProof !== undefined && object.depositAddressProof !== null)
      ? DepositAddressProof.fromPartial(object.depositAddressProof)
      : undefined;
    message.isStatic = object.isStatic ?? false;
    return message;
  },
};

function createBaseGenerateDepositAddressResponse(): GenerateDepositAddressResponse {
  return { depositAddress: undefined };
}

export const GenerateDepositAddressResponse: MessageFns<GenerateDepositAddressResponse> = {
  encode(message: GenerateDepositAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.depositAddress !== undefined) {
      Address.encode(message.depositAddress, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateDepositAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateDepositAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.depositAddress = Address.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateDepositAddressResponse {
    return { depositAddress: isSet(object.depositAddress) ? Address.fromJSON(object.depositAddress) : undefined };
  },

  toJSON(message: GenerateDepositAddressResponse): unknown {
    const obj: any = {};
    if (message.depositAddress !== undefined) {
      obj.depositAddress = Address.toJSON(message.depositAddress);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateDepositAddressResponse>): GenerateDepositAddressResponse {
    return GenerateDepositAddressResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateDepositAddressResponse>): GenerateDepositAddressResponse {
    const message = createBaseGenerateDepositAddressResponse();
    message.depositAddress = (object.depositAddress !== undefined && object.depositAddress !== null)
      ? Address.fromPartial(object.depositAddress)
      : undefined;
    return message;
  },
};

function createBaseGenerateStaticDepositAddressRequest(): GenerateStaticDepositAddressRequest {
  return { signingPublicKey: new Uint8Array(0), identityPublicKey: new Uint8Array(0), network: 0 };
}

export const GenerateStaticDepositAddressRequest: MessageFns<GenerateStaticDepositAddressRequest> = {
  encode(message: GenerateStaticDepositAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signingPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.signingPublicKey);
    }
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.identityPublicKey);
    }
    if (message.network !== 0) {
      writer.uint32(24).int32(message.network);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateStaticDepositAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateStaticDepositAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateStaticDepositAddressRequest {
    return {
      signingPublicKey: isSet(object.signingPublicKey) ? bytesFromBase64(object.signingPublicKey) : new Uint8Array(0),
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
    };
  },

  toJSON(message: GenerateStaticDepositAddressRequest): unknown {
    const obj: any = {};
    if (message.signingPublicKey.length !== 0) {
      obj.signingPublicKey = base64FromBytes(message.signingPublicKey);
    }
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateStaticDepositAddressRequest>): GenerateStaticDepositAddressRequest {
    return GenerateStaticDepositAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateStaticDepositAddressRequest>): GenerateStaticDepositAddressRequest {
    const message = createBaseGenerateStaticDepositAddressRequest();
    message.signingPublicKey = object.signingPublicKey ?? new Uint8Array(0);
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.network = object.network ?? 0;
    return message;
  },
};

function createBaseGenerateStaticDepositAddressResponse(): GenerateStaticDepositAddressResponse {
  return { depositAddress: undefined };
}

export const GenerateStaticDepositAddressResponse: MessageFns<GenerateStaticDepositAddressResponse> = {
  encode(message: GenerateStaticDepositAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.depositAddress !== undefined) {
      Address.encode(message.depositAddress, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateStaticDepositAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateStaticDepositAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.depositAddress = Address.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateStaticDepositAddressResponse {
    return { depositAddress: isSet(object.depositAddress) ? Address.fromJSON(object.depositAddress) : undefined };
  },

  toJSON(message: GenerateStaticDepositAddressResponse): unknown {
    const obj: any = {};
    if (message.depositAddress !== undefined) {
      obj.depositAddress = Address.toJSON(message.depositAddress);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateStaticDepositAddressResponse>): GenerateStaticDepositAddressResponse {
    return GenerateStaticDepositAddressResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateStaticDepositAddressResponse>): GenerateStaticDepositAddressResponse {
    const message = createBaseGenerateStaticDepositAddressResponse();
    message.depositAddress = (object.depositAddress !== undefined && object.depositAddress !== null)
      ? Address.fromPartial(object.depositAddress)
      : undefined;
    return message;
  },
};

function createBaseUTXO(): UTXO {
  return { rawTx: new Uint8Array(0), vout: 0, network: 0, txid: new Uint8Array(0) };
}

export const UTXO: MessageFns<UTXO> = {
  encode(message: UTXO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rawTx.length !== 0) {
      writer.uint32(10).bytes(message.rawTx);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    if (message.network !== 0) {
      writer.uint32(24).int32(message.network);
    }
    if (message.txid.length !== 0) {
      writer.uint32(34).bytes(message.txid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UTXO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUTXO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rawTx = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.txid = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UTXO {
    return {
      rawTx: isSet(object.rawTx) ? bytesFromBase64(object.rawTx) : new Uint8Array(0),
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
      txid: isSet(object.txid) ? bytesFromBase64(object.txid) : new Uint8Array(0),
    };
  },

  toJSON(message: UTXO): unknown {
    const obj: any = {};
    if (message.rawTx.length !== 0) {
      obj.rawTx = base64FromBytes(message.rawTx);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    if (message.txid.length !== 0) {
      obj.txid = base64FromBytes(message.txid);
    }
    return obj;
  },

  create(base?: DeepPartial<UTXO>): UTXO {
    return UTXO.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UTXO>): UTXO {
    const message = createBaseUTXO();
    message.rawTx = object.rawTx ?? new Uint8Array(0);
    message.vout = object.vout ?? 0;
    message.network = object.network ?? 0;
    message.txid = object.txid ?? new Uint8Array(0);
    return message;
  },
};

function createBaseNodeOutput(): NodeOutput {
  return { nodeId: "", vout: 0 };
}

export const NodeOutput: MessageFns<NodeOutput> = {
  encode(message: NodeOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeOutput {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
    };
  },

  toJSON(message: NodeOutput): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeOutput>): NodeOutput {
    return NodeOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeOutput>): NodeOutput {
    const message = createBaseNodeOutput();
    message.nodeId = object.nodeId ?? "";
    message.vout = object.vout ?? 0;
    return message;
  },
};

function createBaseSigningJob(): SigningJob {
  return { signingPublicKey: new Uint8Array(0), rawTx: new Uint8Array(0), signingNonceCommitment: undefined };
}

export const SigningJob: MessageFns<SigningJob> = {
  encode(message: SigningJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signingPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.signingPublicKey);
    }
    if (message.rawTx.length !== 0) {
      writer.uint32(18).bytes(message.rawTx);
    }
    if (message.signingNonceCommitment !== undefined) {
      SigningCommitment.encode(message.signingNonceCommitment, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rawTx = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signingNonceCommitment = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningJob {
    return {
      signingPublicKey: isSet(object.signingPublicKey) ? bytesFromBase64(object.signingPublicKey) : new Uint8Array(0),
      rawTx: isSet(object.rawTx) ? bytesFromBase64(object.rawTx) : new Uint8Array(0),
      signingNonceCommitment: isSet(object.signingNonceCommitment)
        ? SigningCommitment.fromJSON(object.signingNonceCommitment)
        : undefined,
    };
  },

  toJSON(message: SigningJob): unknown {
    const obj: any = {};
    if (message.signingPublicKey.length !== 0) {
      obj.signingPublicKey = base64FromBytes(message.signingPublicKey);
    }
    if (message.rawTx.length !== 0) {
      obj.rawTx = base64FromBytes(message.rawTx);
    }
    if (message.signingNonceCommitment !== undefined) {
      obj.signingNonceCommitment = SigningCommitment.toJSON(message.signingNonceCommitment);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningJob>): SigningJob {
    return SigningJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningJob>): SigningJob {
    const message = createBaseSigningJob();
    message.signingPublicKey = object.signingPublicKey ?? new Uint8Array(0);
    message.rawTx = object.rawTx ?? new Uint8Array(0);
    message.signingNonceCommitment =
      (object.signingNonceCommitment !== undefined && object.signingNonceCommitment !== null)
        ? SigningCommitment.fromPartial(object.signingNonceCommitment)
        : undefined;
    return message;
  },
};

function createBaseSigningKeyshare(): SigningKeyshare {
  return { ownerIdentifiers: [], threshold: 0, publicKey: new Uint8Array(0), publicShares: {}, updatedTime: undefined };
}

export const SigningKeyshare: MessageFns<SigningKeyshare> = {
  encode(message: SigningKeyshare, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ownerIdentifiers) {
      writer.uint32(10).string(v!);
    }
    if (message.threshold !== 0) {
      writer.uint32(16).uint32(message.threshold);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    Object.entries(message.publicShares).forEach(([key, value]) => {
      SigningKeyshare_PublicSharesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.updatedTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningKeyshare {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningKeyshare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerIdentifiers.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.threshold = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = SigningKeyshare_PublicSharesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.publicShares[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningKeyshare {
    return {
      ownerIdentifiers: globalThis.Array.isArray(object?.ownerIdentifiers)
        ? object.ownerIdentifiers.map((e: any) => globalThis.String(e))
        : [],
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      publicShares: isObject(object.publicShares)
        ? Object.entries(object.publicShares).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      updatedTime: isSet(object.updatedTime) ? fromJsonTimestamp(object.updatedTime) : undefined,
    };
  },

  toJSON(message: SigningKeyshare): unknown {
    const obj: any = {};
    if (message.ownerIdentifiers?.length) {
      obj.ownerIdentifiers = message.ownerIdentifiers;
    }
    if (message.threshold !== 0) {
      obj.threshold = Math.round(message.threshold);
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.publicShares) {
      const entries = Object.entries(message.publicShares);
      if (entries.length > 0) {
        obj.publicShares = {};
        entries.forEach(([k, v]) => {
          obj.publicShares[k] = base64FromBytes(v);
        });
      }
    }
    if (message.updatedTime !== undefined) {
      obj.updatedTime = message.updatedTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<SigningKeyshare>): SigningKeyshare {
    return SigningKeyshare.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningKeyshare>): SigningKeyshare {
    const message = createBaseSigningKeyshare();
    message.ownerIdentifiers = object.ownerIdentifiers?.map((e) => e) || [];
    message.threshold = object.threshold ?? 0;
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.publicShares = Object.entries(object.publicShares ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.updatedTime = object.updatedTime ?? undefined;
    return message;
  },
};

function createBaseSigningKeyshare_PublicSharesEntry(): SigningKeyshare_PublicSharesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const SigningKeyshare_PublicSharesEntry: MessageFns<SigningKeyshare_PublicSharesEntry> = {
  encode(message: SigningKeyshare_PublicSharesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningKeyshare_PublicSharesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningKeyshare_PublicSharesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningKeyshare_PublicSharesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: SigningKeyshare_PublicSharesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningKeyshare_PublicSharesEntry>): SigningKeyshare_PublicSharesEntry {
    return SigningKeyshare_PublicSharesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningKeyshare_PublicSharesEntry>): SigningKeyshare_PublicSharesEntry {
    const message = createBaseSigningKeyshare_PublicSharesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSigningResult(): SigningResult {
  return { publicKeys: {}, signingNonceCommitments: {}, signatureShares: {}, signingKeyshare: undefined };
}

export const SigningResult: MessageFns<SigningResult> = {
  encode(message: SigningResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.publicKeys).forEach(([key, value]) => {
      SigningResult_PublicKeysEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.signingNonceCommitments).forEach(([key, value]) => {
      SigningResult_SigningNonceCommitmentsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    Object.entries(message.signatureShares).forEach(([key, value]) => {
      SigningResult_SignatureSharesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.signingKeyshare !== undefined) {
      SigningKeyshare.encode(message.signingKeyshare, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = SigningResult_PublicKeysEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.publicKeys[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = SigningResult_SigningNonceCommitmentsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.signingNonceCommitments[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SigningResult_SignatureSharesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.signatureShares[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signingKeyshare = SigningKeyshare.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningResult {
    return {
      publicKeys: isObject(object.publicKeys)
        ? Object.entries(object.publicKeys).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      signingNonceCommitments: isObject(object.signingNonceCommitments)
        ? Object.entries(object.signingNonceCommitments).reduce<{ [key: string]: SigningCommitment }>(
          (acc, [key, value]) => {
            acc[key] = SigningCommitment.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      signatureShares: isObject(object.signatureShares)
        ? Object.entries(object.signatureShares).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      signingKeyshare: isSet(object.signingKeyshare) ? SigningKeyshare.fromJSON(object.signingKeyshare) : undefined,
    };
  },

  toJSON(message: SigningResult): unknown {
    const obj: any = {};
    if (message.publicKeys) {
      const entries = Object.entries(message.publicKeys);
      if (entries.length > 0) {
        obj.publicKeys = {};
        entries.forEach(([k, v]) => {
          obj.publicKeys[k] = base64FromBytes(v);
        });
      }
    }
    if (message.signingNonceCommitments) {
      const entries = Object.entries(message.signingNonceCommitments);
      if (entries.length > 0) {
        obj.signingNonceCommitments = {};
        entries.forEach(([k, v]) => {
          obj.signingNonceCommitments[k] = SigningCommitment.toJSON(v);
        });
      }
    }
    if (message.signatureShares) {
      const entries = Object.entries(message.signatureShares);
      if (entries.length > 0) {
        obj.signatureShares = {};
        entries.forEach(([k, v]) => {
          obj.signatureShares[k] = base64FromBytes(v);
        });
      }
    }
    if (message.signingKeyshare !== undefined) {
      obj.signingKeyshare = SigningKeyshare.toJSON(message.signingKeyshare);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningResult>): SigningResult {
    return SigningResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningResult>): SigningResult {
    const message = createBaseSigningResult();
    message.publicKeys = Object.entries(object.publicKeys ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.signingNonceCommitments = Object.entries(object.signingNonceCommitments ?? {}).reduce<
      { [key: string]: SigningCommitment }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SigningCommitment.fromPartial(value);
      }
      return acc;
    }, {});
    message.signatureShares = Object.entries(object.signatureShares ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.signingKeyshare = (object.signingKeyshare !== undefined && object.signingKeyshare !== null)
      ? SigningKeyshare.fromPartial(object.signingKeyshare)
      : undefined;
    return message;
  },
};

function createBaseSigningResult_PublicKeysEntry(): SigningResult_PublicKeysEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const SigningResult_PublicKeysEntry: MessageFns<SigningResult_PublicKeysEntry> = {
  encode(message: SigningResult_PublicKeysEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningResult_PublicKeysEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningResult_PublicKeysEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningResult_PublicKeysEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: SigningResult_PublicKeysEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningResult_PublicKeysEntry>): SigningResult_PublicKeysEntry {
    return SigningResult_PublicKeysEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningResult_PublicKeysEntry>): SigningResult_PublicKeysEntry {
    const message = createBaseSigningResult_PublicKeysEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSigningResult_SigningNonceCommitmentsEntry(): SigningResult_SigningNonceCommitmentsEntry {
  return { key: "", value: undefined };
}

export const SigningResult_SigningNonceCommitmentsEntry: MessageFns<SigningResult_SigningNonceCommitmentsEntry> = {
  encode(message: SigningResult_SigningNonceCommitmentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SigningCommitment.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningResult_SigningNonceCommitmentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningResult_SigningNonceCommitmentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningResult_SigningNonceCommitmentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SigningCommitment.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SigningResult_SigningNonceCommitmentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SigningCommitment.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningResult_SigningNonceCommitmentsEntry>): SigningResult_SigningNonceCommitmentsEntry {
    return SigningResult_SigningNonceCommitmentsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SigningResult_SigningNonceCommitmentsEntry>,
  ): SigningResult_SigningNonceCommitmentsEntry {
    const message = createBaseSigningResult_SigningNonceCommitmentsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SigningCommitment.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSigningResult_SignatureSharesEntry(): SigningResult_SignatureSharesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const SigningResult_SignatureSharesEntry: MessageFns<SigningResult_SignatureSharesEntry> = {
  encode(message: SigningResult_SignatureSharesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningResult_SignatureSharesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningResult_SignatureSharesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningResult_SignatureSharesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: SigningResult_SignatureSharesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningResult_SignatureSharesEntry>): SigningResult_SignatureSharesEntry {
    return SigningResult_SignatureSharesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningResult_SignatureSharesEntry>): SigningResult_SignatureSharesEntry {
    const message = createBaseSigningResult_SignatureSharesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRenewLeafRequest(): RenewLeafRequest {
  return { leafId: "", ownerIdentityPublicKey: new Uint8Array(0), signingJobs: undefined };
}

export const RenewLeafRequest: MessageFns<RenewLeafRequest> = {
  encode(message: RenewLeafRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    switch (message.signingJobs?.$case) {
      case "renewNodeTimelockSigningJob":
        RenewNodeTimelockSigningJob.encode(message.signingJobs.renewNodeTimelockSigningJob, writer.uint32(26).fork())
          .join();
        break;
      case "renewRefundTimelockSigningJob":
        RenewRefundTimelockSigningJob.encode(
          message.signingJobs.renewRefundTimelockSigningJob,
          writer.uint32(34).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenewLeafRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewLeafRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signingJobs = {
            $case: "renewNodeTimelockSigningJob",
            renewNodeTimelockSigningJob: RenewNodeTimelockSigningJob.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signingJobs = {
            $case: "renewRefundTimelockSigningJob",
            renewRefundTimelockSigningJob: RenewRefundTimelockSigningJob.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenewLeafRequest {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      signingJobs: isSet(object.renewNodeTimelockSigningJob)
        ? {
          $case: "renewNodeTimelockSigningJob",
          renewNodeTimelockSigningJob: RenewNodeTimelockSigningJob.fromJSON(object.renewNodeTimelockSigningJob),
        }
        : isSet(object.renewRefundTimelockSigningJob)
        ? {
          $case: "renewRefundTimelockSigningJob",
          renewRefundTimelockSigningJob: RenewRefundTimelockSigningJob.fromJSON(object.renewRefundTimelockSigningJob),
        }
        : undefined,
    };
  },

  toJSON(message: RenewLeafRequest): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.signingJobs?.$case === "renewNodeTimelockSigningJob") {
      obj.renewNodeTimelockSigningJob = RenewNodeTimelockSigningJob.toJSON(
        message.signingJobs.renewNodeTimelockSigningJob,
      );
    } else if (message.signingJobs?.$case === "renewRefundTimelockSigningJob") {
      obj.renewRefundTimelockSigningJob = RenewRefundTimelockSigningJob.toJSON(
        message.signingJobs.renewRefundTimelockSigningJob,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<RenewLeafRequest>): RenewLeafRequest {
    return RenewLeafRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenewLeafRequest>): RenewLeafRequest {
    const message = createBaseRenewLeafRequest();
    message.leafId = object.leafId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    switch (object.signingJobs?.$case) {
      case "renewNodeTimelockSigningJob": {
        if (
          object.signingJobs?.renewNodeTimelockSigningJob !== undefined &&
          object.signingJobs?.renewNodeTimelockSigningJob !== null
        ) {
          message.signingJobs = {
            $case: "renewNodeTimelockSigningJob",
            renewNodeTimelockSigningJob: RenewNodeTimelockSigningJob.fromPartial(
              object.signingJobs.renewNodeTimelockSigningJob,
            ),
          };
        }
        break;
      }
      case "renewRefundTimelockSigningJob": {
        if (
          object.signingJobs?.renewRefundTimelockSigningJob !== undefined &&
          object.signingJobs?.renewRefundTimelockSigningJob !== null
        ) {
          message.signingJobs = {
            $case: "renewRefundTimelockSigningJob",
            renewRefundTimelockSigningJob: RenewRefundTimelockSigningJob.fromPartial(
              object.signingJobs.renewRefundTimelockSigningJob,
            ),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseRenewNodeTimelockSigningJob(): RenewNodeTimelockSigningJob {
  return {
    splitNodeTxSigningJob: undefined,
    splitNodeDirectTxSigningJob: undefined,
    nodeTxSigningJob: undefined,
    refundTxSigningJob: undefined,
    directNodeTxSigningJob: undefined,
    directRefundTxSigningJob: undefined,
    directFromCpfpRefundTxSigningJob: undefined,
  };
}

export const RenewNodeTimelockSigningJob: MessageFns<RenewNodeTimelockSigningJob> = {
  encode(message: RenewNodeTimelockSigningJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.splitNodeTxSigningJob !== undefined) {
      UserSignedTxSigningJob.encode(message.splitNodeTxSigningJob, writer.uint32(10).fork()).join();
    }
    if (message.splitNodeDirectTxSigningJob !== undefined) {
      UserSignedTxSigningJob.encode(message.splitNodeDirectTxSigningJob, writer.uint32(18).fork()).join();
    }
    if (message.nodeTxSigningJob !== undefined) {
      UserSignedTxSigningJob.encode(message.nodeTxSigningJob, writer.uint32(26).fork()).join();
    }
    if (message.refundTxSigningJob !== undefined) {
      UserSignedTxSigningJob.encode(message.refundTxSigningJob, writer.uint32(34).fork()).join();
    }
    if (message.directNodeTxSigningJob !== undefined) {
      UserSignedTxSigningJob.encode(message.directNodeTxSigningJob, writer.uint32(42).fork()).join();
    }
    if (message.directRefundTxSigningJob !== undefined) {
      UserSignedTxSigningJob.encode(message.directRefundTxSigningJob, writer.uint32(50).fork()).join();
    }
    if (message.directFromCpfpRefundTxSigningJob !== undefined) {
      UserSignedTxSigningJob.encode(message.directFromCpfpRefundTxSigningJob, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenewNodeTimelockSigningJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewNodeTimelockSigningJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.splitNodeTxSigningJob = UserSignedTxSigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.splitNodeDirectTxSigningJob = UserSignedTxSigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodeTxSigningJob = UserSignedTxSigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refundTxSigningJob = UserSignedTxSigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.directNodeTxSigningJob = UserSignedTxSigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.directRefundTxSigningJob = UserSignedTxSigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.directFromCpfpRefundTxSigningJob = UserSignedTxSigningJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenewNodeTimelockSigningJob {
    return {
      splitNodeTxSigningJob: isSet(object.splitNodeTxSigningJob)
        ? UserSignedTxSigningJob.fromJSON(object.splitNodeTxSigningJob)
        : undefined,
      splitNodeDirectTxSigningJob: isSet(object.splitNodeDirectTxSigningJob)
        ? UserSignedTxSigningJob.fromJSON(object.splitNodeDirectTxSigningJob)
        : undefined,
      nodeTxSigningJob: isSet(object.nodeTxSigningJob)
        ? UserSignedTxSigningJob.fromJSON(object.nodeTxSigningJob)
        : undefined,
      refundTxSigningJob: isSet(object.refundTxSigningJob)
        ? UserSignedTxSigningJob.fromJSON(object.refundTxSigningJob)
        : undefined,
      directNodeTxSigningJob: isSet(object.directNodeTxSigningJob)
        ? UserSignedTxSigningJob.fromJSON(object.directNodeTxSigningJob)
        : undefined,
      directRefundTxSigningJob: isSet(object.directRefundTxSigningJob)
        ? UserSignedTxSigningJob.fromJSON(object.directRefundTxSigningJob)
        : undefined,
      directFromCpfpRefundTxSigningJob: isSet(object.directFromCpfpRefundTxSigningJob)
        ? UserSignedTxSigningJob.fromJSON(object.directFromCpfpRefundTxSigningJob)
        : undefined,
    };
  },

  toJSON(message: RenewNodeTimelockSigningJob): unknown {
    const obj: any = {};
    if (message.splitNodeTxSigningJob !== undefined) {
      obj.splitNodeTxSigningJob = UserSignedTxSigningJob.toJSON(message.splitNodeTxSigningJob);
    }
    if (message.splitNodeDirectTxSigningJob !== undefined) {
      obj.splitNodeDirectTxSigningJob = UserSignedTxSigningJob.toJSON(message.splitNodeDirectTxSigningJob);
    }
    if (message.nodeTxSigningJob !== undefined) {
      obj.nodeTxSigningJob = UserSignedTxSigningJob.toJSON(message.nodeTxSigningJob);
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = UserSignedTxSigningJob.toJSON(message.refundTxSigningJob);
    }
    if (message.directNodeTxSigningJob !== undefined) {
      obj.directNodeTxSigningJob = UserSignedTxSigningJob.toJSON(message.directNodeTxSigningJob);
    }
    if (message.directRefundTxSigningJob !== undefined) {
      obj.directRefundTxSigningJob = UserSignedTxSigningJob.toJSON(message.directRefundTxSigningJob);
    }
    if (message.directFromCpfpRefundTxSigningJob !== undefined) {
      obj.directFromCpfpRefundTxSigningJob = UserSignedTxSigningJob.toJSON(message.directFromCpfpRefundTxSigningJob);
    }
    return obj;
  },

  create(base?: DeepPartial<RenewNodeTimelockSigningJob>): RenewNodeTimelockSigningJob {
    return RenewNodeTimelockSigningJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenewNodeTimelockSigningJob>): RenewNodeTimelockSigningJob {
    const message = createBaseRenewNodeTimelockSigningJob();
    message.splitNodeTxSigningJob =
      (object.splitNodeTxSigningJob !== undefined && object.splitNodeTxSigningJob !== null)
        ? UserSignedTxSigningJob.fromPartial(object.splitNodeTxSigningJob)
        : undefined;
    message.splitNodeDirectTxSigningJob =
      (object.splitNodeDirectTxSigningJob !== undefined && object.splitNodeDirectTxSigningJob !== null)
        ? UserSignedTxSigningJob.fromPartial(object.splitNodeDirectTxSigningJob)
        : undefined;
    message.nodeTxSigningJob = (object.nodeTxSigningJob !== undefined && object.nodeTxSigningJob !== null)
      ? UserSignedTxSigningJob.fromPartial(object.nodeTxSigningJob)
      : undefined;
    message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
      ? UserSignedTxSigningJob.fromPartial(object.refundTxSigningJob)
      : undefined;
    message.directNodeTxSigningJob =
      (object.directNodeTxSigningJob !== undefined && object.directNodeTxSigningJob !== null)
        ? UserSignedTxSigningJob.fromPartial(object.directNodeTxSigningJob)
        : undefined;
    message.directRefundTxSigningJob =
      (object.directRefundTxSigningJob !== undefined && object.directRefundTxSigningJob !== null)
        ? UserSignedTxSigningJob.fromPartial(object.directRefundTxSigningJob)
        : undefined;
    message.directFromCpfpRefundTxSigningJob =
      (object.directFromCpfpRefundTxSigningJob !== undefined && object.directFromCpfpRefundTxSigningJob !== null)
        ? UserSignedTxSigningJob.fromPartial(object.directFromCpfpRefundTxSigningJob)
        : undefined;
    return message;
  },
};

function createBaseRenewRefundTimelockSigningJob(): RenewRefundTimelockSigningJob {
  return {
    nodeTxSigningJob: undefined,
    refundTxSigningJob: undefined,
    directNodeTxSigningJob: undefined,
    directRefundTxSigningJob: undefined,
    directFromCpfpRefundTxSigningJob: undefined,
  };
}

export const RenewRefundTimelockSigningJob: MessageFns<RenewRefundTimelockSigningJob> = {
  encode(message: RenewRefundTimelockSigningJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeTxSigningJob !== undefined) {
      UserSignedTxSigningJob.encode(message.nodeTxSigningJob, writer.uint32(10).fork()).join();
    }
    if (message.refundTxSigningJob !== undefined) {
      UserSignedTxSigningJob.encode(message.refundTxSigningJob, writer.uint32(18).fork()).join();
    }
    if (message.directNodeTxSigningJob !== undefined) {
      UserSignedTxSigningJob.encode(message.directNodeTxSigningJob, writer.uint32(26).fork()).join();
    }
    if (message.directRefundTxSigningJob !== undefined) {
      UserSignedTxSigningJob.encode(message.directRefundTxSigningJob, writer.uint32(34).fork()).join();
    }
    if (message.directFromCpfpRefundTxSigningJob !== undefined) {
      UserSignedTxSigningJob.encode(message.directFromCpfpRefundTxSigningJob, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenewRefundTimelockSigningJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewRefundTimelockSigningJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeTxSigningJob = UserSignedTxSigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundTxSigningJob = UserSignedTxSigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.directNodeTxSigningJob = UserSignedTxSigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.directRefundTxSigningJob = UserSignedTxSigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.directFromCpfpRefundTxSigningJob = UserSignedTxSigningJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenewRefundTimelockSigningJob {
    return {
      nodeTxSigningJob: isSet(object.nodeTxSigningJob)
        ? UserSignedTxSigningJob.fromJSON(object.nodeTxSigningJob)
        : undefined,
      refundTxSigningJob: isSet(object.refundTxSigningJob)
        ? UserSignedTxSigningJob.fromJSON(object.refundTxSigningJob)
        : undefined,
      directNodeTxSigningJob: isSet(object.directNodeTxSigningJob)
        ? UserSignedTxSigningJob.fromJSON(object.directNodeTxSigningJob)
        : undefined,
      directRefundTxSigningJob: isSet(object.directRefundTxSigningJob)
        ? UserSignedTxSigningJob.fromJSON(object.directRefundTxSigningJob)
        : undefined,
      directFromCpfpRefundTxSigningJob: isSet(object.directFromCpfpRefundTxSigningJob)
        ? UserSignedTxSigningJob.fromJSON(object.directFromCpfpRefundTxSigningJob)
        : undefined,
    };
  },

  toJSON(message: RenewRefundTimelockSigningJob): unknown {
    const obj: any = {};
    if (message.nodeTxSigningJob !== undefined) {
      obj.nodeTxSigningJob = UserSignedTxSigningJob.toJSON(message.nodeTxSigningJob);
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = UserSignedTxSigningJob.toJSON(message.refundTxSigningJob);
    }
    if (message.directNodeTxSigningJob !== undefined) {
      obj.directNodeTxSigningJob = UserSignedTxSigningJob.toJSON(message.directNodeTxSigningJob);
    }
    if (message.directRefundTxSigningJob !== undefined) {
      obj.directRefundTxSigningJob = UserSignedTxSigningJob.toJSON(message.directRefundTxSigningJob);
    }
    if (message.directFromCpfpRefundTxSigningJob !== undefined) {
      obj.directFromCpfpRefundTxSigningJob = UserSignedTxSigningJob.toJSON(message.directFromCpfpRefundTxSigningJob);
    }
    return obj;
  },

  create(base?: DeepPartial<RenewRefundTimelockSigningJob>): RenewRefundTimelockSigningJob {
    return RenewRefundTimelockSigningJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenewRefundTimelockSigningJob>): RenewRefundTimelockSigningJob {
    const message = createBaseRenewRefundTimelockSigningJob();
    message.nodeTxSigningJob = (object.nodeTxSigningJob !== undefined && object.nodeTxSigningJob !== null)
      ? UserSignedTxSigningJob.fromPartial(object.nodeTxSigningJob)
      : undefined;
    message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
      ? UserSignedTxSigningJob.fromPartial(object.refundTxSigningJob)
      : undefined;
    message.directNodeTxSigningJob =
      (object.directNodeTxSigningJob !== undefined && object.directNodeTxSigningJob !== null)
        ? UserSignedTxSigningJob.fromPartial(object.directNodeTxSigningJob)
        : undefined;
    message.directRefundTxSigningJob =
      (object.directRefundTxSigningJob !== undefined && object.directRefundTxSigningJob !== null)
        ? UserSignedTxSigningJob.fromPartial(object.directRefundTxSigningJob)
        : undefined;
    message.directFromCpfpRefundTxSigningJob =
      (object.directFromCpfpRefundTxSigningJob !== undefined && object.directFromCpfpRefundTxSigningJob !== null)
        ? UserSignedTxSigningJob.fromPartial(object.directFromCpfpRefundTxSigningJob)
        : undefined;
    return message;
  },
};

function createBaseRenewLeafResponse(): RenewLeafResponse {
  return { renewResult: undefined };
}

export const RenewLeafResponse: MessageFns<RenewLeafResponse> = {
  encode(message: RenewLeafResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.renewResult?.$case) {
      case "extendResult":
        RenewNodeTimelockResult.encode(message.renewResult.extendResult, writer.uint32(10).fork()).join();
        break;
      case "refreshResult":
        RenewRefundTimelockResult.encode(message.renewResult.refreshResult, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenewLeafResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewLeafResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.renewResult = {
            $case: "extendResult",
            extendResult: RenewNodeTimelockResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.renewResult = {
            $case: "refreshResult",
            refreshResult: RenewRefundTimelockResult.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenewLeafResponse {
    return {
      renewResult: isSet(object.extendResult)
        ? { $case: "extendResult", extendResult: RenewNodeTimelockResult.fromJSON(object.extendResult) }
        : isSet(object.refreshResult)
        ? { $case: "refreshResult", refreshResult: RenewRefundTimelockResult.fromJSON(object.refreshResult) }
        : undefined,
    };
  },

  toJSON(message: RenewLeafResponse): unknown {
    const obj: any = {};
    if (message.renewResult?.$case === "extendResult") {
      obj.extendResult = RenewNodeTimelockResult.toJSON(message.renewResult.extendResult);
    } else if (message.renewResult?.$case === "refreshResult") {
      obj.refreshResult = RenewRefundTimelockResult.toJSON(message.renewResult.refreshResult);
    }
    return obj;
  },

  create(base?: DeepPartial<RenewLeafResponse>): RenewLeafResponse {
    return RenewLeafResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenewLeafResponse>): RenewLeafResponse {
    const message = createBaseRenewLeafResponse();
    switch (object.renewResult?.$case) {
      case "extendResult": {
        if (object.renewResult?.extendResult !== undefined && object.renewResult?.extendResult !== null) {
          message.renewResult = {
            $case: "extendResult",
            extendResult: RenewNodeTimelockResult.fromPartial(object.renewResult.extendResult),
          };
        }
        break;
      }
      case "refreshResult": {
        if (object.renewResult?.refreshResult !== undefined && object.renewResult?.refreshResult !== null) {
          message.renewResult = {
            $case: "refreshResult",
            refreshResult: RenewRefundTimelockResult.fromPartial(object.renewResult.refreshResult),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseRenewNodeTimelockResult(): RenewNodeTimelockResult {
  return { splitNode: undefined, node: undefined };
}

export const RenewNodeTimelockResult: MessageFns<RenewNodeTimelockResult> = {
  encode(message: RenewNodeTimelockResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.splitNode !== undefined) {
      TreeNode.encode(message.splitNode, writer.uint32(10).fork()).join();
    }
    if (message.node !== undefined) {
      TreeNode.encode(message.node, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenewNodeTimelockResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewNodeTimelockResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.splitNode = TreeNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.node = TreeNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenewNodeTimelockResult {
    return {
      splitNode: isSet(object.splitNode) ? TreeNode.fromJSON(object.splitNode) : undefined,
      node: isSet(object.node) ? TreeNode.fromJSON(object.node) : undefined,
    };
  },

  toJSON(message: RenewNodeTimelockResult): unknown {
    const obj: any = {};
    if (message.splitNode !== undefined) {
      obj.splitNode = TreeNode.toJSON(message.splitNode);
    }
    if (message.node !== undefined) {
      obj.node = TreeNode.toJSON(message.node);
    }
    return obj;
  },

  create(base?: DeepPartial<RenewNodeTimelockResult>): RenewNodeTimelockResult {
    return RenewNodeTimelockResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenewNodeTimelockResult>): RenewNodeTimelockResult {
    const message = createBaseRenewNodeTimelockResult();
    message.splitNode = (object.splitNode !== undefined && object.splitNode !== null)
      ? TreeNode.fromPartial(object.splitNode)
      : undefined;
    message.node = (object.node !== undefined && object.node !== null) ? TreeNode.fromPartial(object.node) : undefined;
    return message;
  },
};

function createBaseRenewRefundTimelockResult(): RenewRefundTimelockResult {
  return { node: undefined };
}

export const RenewRefundTimelockResult: MessageFns<RenewRefundTimelockResult> = {
  encode(message: RenewRefundTimelockResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      TreeNode.encode(message.node, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenewRefundTimelockResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewRefundTimelockResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = TreeNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenewRefundTimelockResult {
    return { node: isSet(object.node) ? TreeNode.fromJSON(object.node) : undefined };
  },

  toJSON(message: RenewRefundTimelockResult): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = TreeNode.toJSON(message.node);
    }
    return obj;
  },

  create(base?: DeepPartial<RenewRefundTimelockResult>): RenewRefundTimelockResult {
    return RenewRefundTimelockResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenewRefundTimelockResult>): RenewRefundTimelockResult {
    const message = createBaseRenewRefundTimelockResult();
    message.node = (object.node !== undefined && object.node !== null) ? TreeNode.fromPartial(object.node) : undefined;
    return message;
  },
};

function createBaseNodeSignatureShares(): NodeSignatureShares {
  return {
    nodeId: "",
    nodeTxSigningResult: undefined,
    refundTxSigningResult: undefined,
    verifyingKey: new Uint8Array(0),
    directNodeTxSigningResult: undefined,
    directRefundTxSigningResult: undefined,
    directFromCpfpRefundTxSigningResult: undefined,
  };
}

export const NodeSignatureShares: MessageFns<NodeSignatureShares> = {
  encode(message: NodeSignatureShares, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.nodeTxSigningResult !== undefined) {
      SigningResult.encode(message.nodeTxSigningResult, writer.uint32(18).fork()).join();
    }
    if (message.refundTxSigningResult !== undefined) {
      SigningResult.encode(message.refundTxSigningResult, writer.uint32(26).fork()).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(34).bytes(message.verifyingKey);
    }
    if (message.directNodeTxSigningResult !== undefined) {
      SigningResult.encode(message.directNodeTxSigningResult, writer.uint32(42).fork()).join();
    }
    if (message.directRefundTxSigningResult !== undefined) {
      SigningResult.encode(message.directRefundTxSigningResult, writer.uint32(50).fork()).join();
    }
    if (message.directFromCpfpRefundTxSigningResult !== undefined) {
      SigningResult.encode(message.directFromCpfpRefundTxSigningResult, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeSignatureShares {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeSignatureShares();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.directNodeTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.directRefundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.directFromCpfpRefundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeSignatureShares {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      nodeTxSigningResult: isSet(object.nodeTxSigningResult)
        ? SigningResult.fromJSON(object.nodeTxSigningResult)
        : undefined,
      refundTxSigningResult: isSet(object.refundTxSigningResult)
        ? SigningResult.fromJSON(object.refundTxSigningResult)
        : undefined,
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
      directNodeTxSigningResult: isSet(object.directNodeTxSigningResult)
        ? SigningResult.fromJSON(object.directNodeTxSigningResult)
        : undefined,
      directRefundTxSigningResult: isSet(object.directRefundTxSigningResult)
        ? SigningResult.fromJSON(object.directRefundTxSigningResult)
        : undefined,
      directFromCpfpRefundTxSigningResult: isSet(object.directFromCpfpRefundTxSigningResult)
        ? SigningResult.fromJSON(object.directFromCpfpRefundTxSigningResult)
        : undefined,
    };
  },

  toJSON(message: NodeSignatureShares): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.nodeTxSigningResult !== undefined) {
      obj.nodeTxSigningResult = SigningResult.toJSON(message.nodeTxSigningResult);
    }
    if (message.refundTxSigningResult !== undefined) {
      obj.refundTxSigningResult = SigningResult.toJSON(message.refundTxSigningResult);
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    if (message.directNodeTxSigningResult !== undefined) {
      obj.directNodeTxSigningResult = SigningResult.toJSON(message.directNodeTxSigningResult);
    }
    if (message.directRefundTxSigningResult !== undefined) {
      obj.directRefundTxSigningResult = SigningResult.toJSON(message.directRefundTxSigningResult);
    }
    if (message.directFromCpfpRefundTxSigningResult !== undefined) {
      obj.directFromCpfpRefundTxSigningResult = SigningResult.toJSON(message.directFromCpfpRefundTxSigningResult);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeSignatureShares>): NodeSignatureShares {
    return NodeSignatureShares.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeSignatureShares>): NodeSignatureShares {
    const message = createBaseNodeSignatureShares();
    message.nodeId = object.nodeId ?? "";
    message.nodeTxSigningResult = (object.nodeTxSigningResult !== undefined && object.nodeTxSigningResult !== null)
      ? SigningResult.fromPartial(object.nodeTxSigningResult)
      : undefined;
    message.refundTxSigningResult =
      (object.refundTxSigningResult !== undefined && object.refundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.refundTxSigningResult)
        : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    message.directNodeTxSigningResult =
      (object.directNodeTxSigningResult !== undefined && object.directNodeTxSigningResult !== null)
        ? SigningResult.fromPartial(object.directNodeTxSigningResult)
        : undefined;
    message.directRefundTxSigningResult =
      (object.directRefundTxSigningResult !== undefined && object.directRefundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.directRefundTxSigningResult)
        : undefined;
    message.directFromCpfpRefundTxSigningResult =
      (object.directFromCpfpRefundTxSigningResult !== undefined && object.directFromCpfpRefundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.directFromCpfpRefundTxSigningResult)
        : undefined;
    return message;
  },
};

function createBaseNodeSignatures(): NodeSignatures {
  return {
    nodeId: "",
    nodeTxSignature: new Uint8Array(0),
    refundTxSignature: new Uint8Array(0),
    directNodeTxSignature: new Uint8Array(0),
    directRefundTxSignature: new Uint8Array(0),
    directFromCpfpRefundTxSignature: new Uint8Array(0),
  };
}

export const NodeSignatures: MessageFns<NodeSignatures> = {
  encode(message: NodeSignatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.nodeTxSignature.length !== 0) {
      writer.uint32(18).bytes(message.nodeTxSignature);
    }
    if (message.refundTxSignature.length !== 0) {
      writer.uint32(26).bytes(message.refundTxSignature);
    }
    if (message.directNodeTxSignature.length !== 0) {
      writer.uint32(34).bytes(message.directNodeTxSignature);
    }
    if (message.directRefundTxSignature.length !== 0) {
      writer.uint32(42).bytes(message.directRefundTxSignature);
    }
    if (message.directFromCpfpRefundTxSignature.length !== 0) {
      writer.uint32(50).bytes(message.directFromCpfpRefundTxSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeSignatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeSignatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeTxSignature = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundTxSignature = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.directNodeTxSignature = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.directRefundTxSignature = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.directFromCpfpRefundTxSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeSignatures {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      nodeTxSignature: isSet(object.nodeTxSignature) ? bytesFromBase64(object.nodeTxSignature) : new Uint8Array(0),
      refundTxSignature: isSet(object.refundTxSignature)
        ? bytesFromBase64(object.refundTxSignature)
        : new Uint8Array(0),
      directNodeTxSignature: isSet(object.directNodeTxSignature)
        ? bytesFromBase64(object.directNodeTxSignature)
        : new Uint8Array(0),
      directRefundTxSignature: isSet(object.directRefundTxSignature)
        ? bytesFromBase64(object.directRefundTxSignature)
        : new Uint8Array(0),
      directFromCpfpRefundTxSignature: isSet(object.directFromCpfpRefundTxSignature)
        ? bytesFromBase64(object.directFromCpfpRefundTxSignature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: NodeSignatures): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.nodeTxSignature.length !== 0) {
      obj.nodeTxSignature = base64FromBytes(message.nodeTxSignature);
    }
    if (message.refundTxSignature.length !== 0) {
      obj.refundTxSignature = base64FromBytes(message.refundTxSignature);
    }
    if (message.directNodeTxSignature.length !== 0) {
      obj.directNodeTxSignature = base64FromBytes(message.directNodeTxSignature);
    }
    if (message.directRefundTxSignature.length !== 0) {
      obj.directRefundTxSignature = base64FromBytes(message.directRefundTxSignature);
    }
    if (message.directFromCpfpRefundTxSignature.length !== 0) {
      obj.directFromCpfpRefundTxSignature = base64FromBytes(message.directFromCpfpRefundTxSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeSignatures>): NodeSignatures {
    return NodeSignatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeSignatures>): NodeSignatures {
    const message = createBaseNodeSignatures();
    message.nodeId = object.nodeId ?? "";
    message.nodeTxSignature = object.nodeTxSignature ?? new Uint8Array(0);
    message.refundTxSignature = object.refundTxSignature ?? new Uint8Array(0);
    message.directNodeTxSignature = object.directNodeTxSignature ?? new Uint8Array(0);
    message.directRefundTxSignature = object.directRefundTxSignature ?? new Uint8Array(0);
    message.directFromCpfpRefundTxSignature = object.directFromCpfpRefundTxSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseStartTreeCreationRequest(): StartTreeCreationRequest {
  return {
    identityPublicKey: new Uint8Array(0),
    onChainUtxo: undefined,
    rootTxSigningJob: undefined,
    refundTxSigningJob: undefined,
    directRootTxSigningJob: undefined,
    directRefundTxSigningJob: undefined,
    directFromCpfpRefundTxSigningJob: undefined,
  };
}

export const StartTreeCreationRequest: MessageFns<StartTreeCreationRequest> = {
  encode(message: StartTreeCreationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.identityPublicKey);
    }
    if (message.onChainUtxo !== undefined) {
      UTXO.encode(message.onChainUtxo, writer.uint32(18).fork()).join();
    }
    if (message.rootTxSigningJob !== undefined) {
      SigningJob.encode(message.rootTxSigningJob, writer.uint32(26).fork()).join();
    }
    if (message.refundTxSigningJob !== undefined) {
      SigningJob.encode(message.refundTxSigningJob, writer.uint32(34).fork()).join();
    }
    if (message.directRootTxSigningJob !== undefined) {
      SigningJob.encode(message.directRootTxSigningJob, writer.uint32(42).fork()).join();
    }
    if (message.directRefundTxSigningJob !== undefined) {
      SigningJob.encode(message.directRefundTxSigningJob, writer.uint32(50).fork()).join();
    }
    if (message.directFromCpfpRefundTxSigningJob !== undefined) {
      SigningJob.encode(message.directFromCpfpRefundTxSigningJob, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTreeCreationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTreeCreationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.onChainUtxo = UTXO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rootTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.directRootTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.directRefundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.directFromCpfpRefundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTreeCreationRequest {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      onChainUtxo: isSet(object.onChainUtxo) ? UTXO.fromJSON(object.onChainUtxo) : undefined,
      rootTxSigningJob: isSet(object.rootTxSigningJob) ? SigningJob.fromJSON(object.rootTxSigningJob) : undefined,
      refundTxSigningJob: isSet(object.refundTxSigningJob) ? SigningJob.fromJSON(object.refundTxSigningJob) : undefined,
      directRootTxSigningJob: isSet(object.directRootTxSigningJob)
        ? SigningJob.fromJSON(object.directRootTxSigningJob)
        : undefined,
      directRefundTxSigningJob: isSet(object.directRefundTxSigningJob)
        ? SigningJob.fromJSON(object.directRefundTxSigningJob)
        : undefined,
      directFromCpfpRefundTxSigningJob: isSet(object.directFromCpfpRefundTxSigningJob)
        ? SigningJob.fromJSON(object.directFromCpfpRefundTxSigningJob)
        : undefined,
    };
  },

  toJSON(message: StartTreeCreationRequest): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.onChainUtxo !== undefined) {
      obj.onChainUtxo = UTXO.toJSON(message.onChainUtxo);
    }
    if (message.rootTxSigningJob !== undefined) {
      obj.rootTxSigningJob = SigningJob.toJSON(message.rootTxSigningJob);
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
    }
    if (message.directRootTxSigningJob !== undefined) {
      obj.directRootTxSigningJob = SigningJob.toJSON(message.directRootTxSigningJob);
    }
    if (message.directRefundTxSigningJob !== undefined) {
      obj.directRefundTxSigningJob = SigningJob.toJSON(message.directRefundTxSigningJob);
    }
    if (message.directFromCpfpRefundTxSigningJob !== undefined) {
      obj.directFromCpfpRefundTxSigningJob = SigningJob.toJSON(message.directFromCpfpRefundTxSigningJob);
    }
    return obj;
  },

  create(base?: DeepPartial<StartTreeCreationRequest>): StartTreeCreationRequest {
    return StartTreeCreationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTreeCreationRequest>): StartTreeCreationRequest {
    const message = createBaseStartTreeCreationRequest();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.onChainUtxo = (object.onChainUtxo !== undefined && object.onChainUtxo !== null)
      ? UTXO.fromPartial(object.onChainUtxo)
      : undefined;
    message.rootTxSigningJob = (object.rootTxSigningJob !== undefined && object.rootTxSigningJob !== null)
      ? SigningJob.fromPartial(object.rootTxSigningJob)
      : undefined;
    message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
      ? SigningJob.fromPartial(object.refundTxSigningJob)
      : undefined;
    message.directRootTxSigningJob =
      (object.directRootTxSigningJob !== undefined && object.directRootTxSigningJob !== null)
        ? SigningJob.fromPartial(object.directRootTxSigningJob)
        : undefined;
    message.directRefundTxSigningJob =
      (object.directRefundTxSigningJob !== undefined && object.directRefundTxSigningJob !== null)
        ? SigningJob.fromPartial(object.directRefundTxSigningJob)
        : undefined;
    message.directFromCpfpRefundTxSigningJob =
      (object.directFromCpfpRefundTxSigningJob !== undefined && object.directFromCpfpRefundTxSigningJob !== null)
        ? SigningJob.fromPartial(object.directFromCpfpRefundTxSigningJob)
        : undefined;
    return message;
  },
};

function createBaseStartTreeCreationResponse(): StartTreeCreationResponse {
  return { treeId: "", rootNodeSignatureShares: undefined };
}

export const StartTreeCreationResponse: MessageFns<StartTreeCreationResponse> = {
  encode(message: StartTreeCreationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.treeId !== "") {
      writer.uint32(10).string(message.treeId);
    }
    if (message.rootNodeSignatureShares !== undefined) {
      NodeSignatureShares.encode(message.rootNodeSignatureShares, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTreeCreationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTreeCreationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.treeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rootNodeSignatureShares = NodeSignatureShares.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTreeCreationResponse {
    return {
      treeId: isSet(object.treeId) ? globalThis.String(object.treeId) : "",
      rootNodeSignatureShares: isSet(object.rootNodeSignatureShares)
        ? NodeSignatureShares.fromJSON(object.rootNodeSignatureShares)
        : undefined,
    };
  },

  toJSON(message: StartTreeCreationResponse): unknown {
    const obj: any = {};
    if (message.treeId !== "") {
      obj.treeId = message.treeId;
    }
    if (message.rootNodeSignatureShares !== undefined) {
      obj.rootNodeSignatureShares = NodeSignatureShares.toJSON(message.rootNodeSignatureShares);
    }
    return obj;
  },

  create(base?: DeepPartial<StartTreeCreationResponse>): StartTreeCreationResponse {
    return StartTreeCreationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTreeCreationResponse>): StartTreeCreationResponse {
    const message = createBaseStartTreeCreationResponse();
    message.treeId = object.treeId ?? "";
    message.rootNodeSignatureShares =
      (object.rootNodeSignatureShares !== undefined && object.rootNodeSignatureShares !== null)
        ? NodeSignatureShares.fromPartial(object.rootNodeSignatureShares)
        : undefined;
    return message;
  },
};

function createBaseStartDepositTreeCreationRequest(): StartDepositTreeCreationRequest {
  return {
    identityPublicKey: new Uint8Array(0),
    onChainUtxo: undefined,
    rootTxSigningJob: undefined,
    refundTxSigningJob: undefined,
    directRootTxSigningJob: undefined,
    directRefundTxSigningJob: undefined,
    directFromCpfpRefundTxSigningJob: undefined,
  };
}

export const StartDepositTreeCreationRequest: MessageFns<StartDepositTreeCreationRequest> = {
  encode(message: StartDepositTreeCreationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.identityPublicKey);
    }
    if (message.onChainUtxo !== undefined) {
      UTXO.encode(message.onChainUtxo, writer.uint32(18).fork()).join();
    }
    if (message.rootTxSigningJob !== undefined) {
      SigningJob.encode(message.rootTxSigningJob, writer.uint32(26).fork()).join();
    }
    if (message.refundTxSigningJob !== undefined) {
      SigningJob.encode(message.refundTxSigningJob, writer.uint32(34).fork()).join();
    }
    if (message.directRootTxSigningJob !== undefined) {
      SigningJob.encode(message.directRootTxSigningJob, writer.uint32(42).fork()).join();
    }
    if (message.directRefundTxSigningJob !== undefined) {
      SigningJob.encode(message.directRefundTxSigningJob, writer.uint32(50).fork()).join();
    }
    if (message.directFromCpfpRefundTxSigningJob !== undefined) {
      SigningJob.encode(message.directFromCpfpRefundTxSigningJob, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartDepositTreeCreationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartDepositTreeCreationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.onChainUtxo = UTXO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rootTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.directRootTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.directRefundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.directFromCpfpRefundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartDepositTreeCreationRequest {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      onChainUtxo: isSet(object.onChainUtxo) ? UTXO.fromJSON(object.onChainUtxo) : undefined,
      rootTxSigningJob: isSet(object.rootTxSigningJob) ? SigningJob.fromJSON(object.rootTxSigningJob) : undefined,
      refundTxSigningJob: isSet(object.refundTxSigningJob) ? SigningJob.fromJSON(object.refundTxSigningJob) : undefined,
      directRootTxSigningJob: isSet(object.directRootTxSigningJob)
        ? SigningJob.fromJSON(object.directRootTxSigningJob)
        : undefined,
      directRefundTxSigningJob: isSet(object.directRefundTxSigningJob)
        ? SigningJob.fromJSON(object.directRefundTxSigningJob)
        : undefined,
      directFromCpfpRefundTxSigningJob: isSet(object.directFromCpfpRefundTxSigningJob)
        ? SigningJob.fromJSON(object.directFromCpfpRefundTxSigningJob)
        : undefined,
    };
  },

  toJSON(message: StartDepositTreeCreationRequest): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.onChainUtxo !== undefined) {
      obj.onChainUtxo = UTXO.toJSON(message.onChainUtxo);
    }
    if (message.rootTxSigningJob !== undefined) {
      obj.rootTxSigningJob = SigningJob.toJSON(message.rootTxSigningJob);
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
    }
    if (message.directRootTxSigningJob !== undefined) {
      obj.directRootTxSigningJob = SigningJob.toJSON(message.directRootTxSigningJob);
    }
    if (message.directRefundTxSigningJob !== undefined) {
      obj.directRefundTxSigningJob = SigningJob.toJSON(message.directRefundTxSigningJob);
    }
    if (message.directFromCpfpRefundTxSigningJob !== undefined) {
      obj.directFromCpfpRefundTxSigningJob = SigningJob.toJSON(message.directFromCpfpRefundTxSigningJob);
    }
    return obj;
  },

  create(base?: DeepPartial<StartDepositTreeCreationRequest>): StartDepositTreeCreationRequest {
    return StartDepositTreeCreationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartDepositTreeCreationRequest>): StartDepositTreeCreationRequest {
    const message = createBaseStartDepositTreeCreationRequest();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.onChainUtxo = (object.onChainUtxo !== undefined && object.onChainUtxo !== null)
      ? UTXO.fromPartial(object.onChainUtxo)
      : undefined;
    message.rootTxSigningJob = (object.rootTxSigningJob !== undefined && object.rootTxSigningJob !== null)
      ? SigningJob.fromPartial(object.rootTxSigningJob)
      : undefined;
    message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
      ? SigningJob.fromPartial(object.refundTxSigningJob)
      : undefined;
    message.directRootTxSigningJob =
      (object.directRootTxSigningJob !== undefined && object.directRootTxSigningJob !== null)
        ? SigningJob.fromPartial(object.directRootTxSigningJob)
        : undefined;
    message.directRefundTxSigningJob =
      (object.directRefundTxSigningJob !== undefined && object.directRefundTxSigningJob !== null)
        ? SigningJob.fromPartial(object.directRefundTxSigningJob)
        : undefined;
    message.directFromCpfpRefundTxSigningJob =
      (object.directFromCpfpRefundTxSigningJob !== undefined && object.directFromCpfpRefundTxSigningJob !== null)
        ? SigningJob.fromPartial(object.directFromCpfpRefundTxSigningJob)
        : undefined;
    return message;
  },
};

function createBaseStartDepositTreeCreationResponse(): StartDepositTreeCreationResponse {
  return { treeId: "", rootNodeSignatureShares: undefined };
}

export const StartDepositTreeCreationResponse: MessageFns<StartDepositTreeCreationResponse> = {
  encode(message: StartDepositTreeCreationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.treeId !== "") {
      writer.uint32(10).string(message.treeId);
    }
    if (message.rootNodeSignatureShares !== undefined) {
      NodeSignatureShares.encode(message.rootNodeSignatureShares, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartDepositTreeCreationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartDepositTreeCreationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.treeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rootNodeSignatureShares = NodeSignatureShares.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartDepositTreeCreationResponse {
    return {
      treeId: isSet(object.treeId) ? globalThis.String(object.treeId) : "",
      rootNodeSignatureShares: isSet(object.rootNodeSignatureShares)
        ? NodeSignatureShares.fromJSON(object.rootNodeSignatureShares)
        : undefined,
    };
  },

  toJSON(message: StartDepositTreeCreationResponse): unknown {
    const obj: any = {};
    if (message.treeId !== "") {
      obj.treeId = message.treeId;
    }
    if (message.rootNodeSignatureShares !== undefined) {
      obj.rootNodeSignatureShares = NodeSignatureShares.toJSON(message.rootNodeSignatureShares);
    }
    return obj;
  },

  create(base?: DeepPartial<StartDepositTreeCreationResponse>): StartDepositTreeCreationResponse {
    return StartDepositTreeCreationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartDepositTreeCreationResponse>): StartDepositTreeCreationResponse {
    const message = createBaseStartDepositTreeCreationResponse();
    message.treeId = object.treeId ?? "";
    message.rootNodeSignatureShares =
      (object.rootNodeSignatureShares !== undefined && object.rootNodeSignatureShares !== null)
        ? NodeSignatureShares.fromPartial(object.rootNodeSignatureShares)
        : undefined;
    return message;
  },
};

function createBaseTokenOutputToSpend(): TokenOutputToSpend {
  return { prevTokenTransactionHash: new Uint8Array(0), prevTokenTransactionVout: 0 };
}

export const TokenOutputToSpend: MessageFns<TokenOutputToSpend> = {
  encode(message: TokenOutputToSpend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prevTokenTransactionHash.length !== 0) {
      writer.uint32(10).bytes(message.prevTokenTransactionHash);
    }
    if (message.prevTokenTransactionVout !== 0) {
      writer.uint32(16).uint32(message.prevTokenTransactionVout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenOutputToSpend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenOutputToSpend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prevTokenTransactionHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.prevTokenTransactionVout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenOutputToSpend {
    return {
      prevTokenTransactionHash: isSet(object.prevTokenTransactionHash)
        ? bytesFromBase64(object.prevTokenTransactionHash)
        : new Uint8Array(0),
      prevTokenTransactionVout: isSet(object.prevTokenTransactionVout)
        ? globalThis.Number(object.prevTokenTransactionVout)
        : 0,
    };
  },

  toJSON(message: TokenOutputToSpend): unknown {
    const obj: any = {};
    if (message.prevTokenTransactionHash.length !== 0) {
      obj.prevTokenTransactionHash = base64FromBytes(message.prevTokenTransactionHash);
    }
    if (message.prevTokenTransactionVout !== 0) {
      obj.prevTokenTransactionVout = Math.round(message.prevTokenTransactionVout);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenOutputToSpend>): TokenOutputToSpend {
    return TokenOutputToSpend.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenOutputToSpend>): TokenOutputToSpend {
    const message = createBaseTokenOutputToSpend();
    message.prevTokenTransactionHash = object.prevTokenTransactionHash ?? new Uint8Array(0);
    message.prevTokenTransactionVout = object.prevTokenTransactionVout ?? 0;
    return message;
  },
};

function createBaseTokenTransferInput(): TokenTransferInput {
  return { outputsToSpend: [] };
}

export const TokenTransferInput: MessageFns<TokenTransferInput> = {
  encode(message: TokenTransferInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.outputsToSpend) {
      TokenOutputToSpend.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenTransferInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenTransferInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputsToSpend.push(TokenOutputToSpend.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenTransferInput {
    return {
      outputsToSpend: globalThis.Array.isArray(object?.outputsToSpend)
        ? object.outputsToSpend.map((e: any) => TokenOutputToSpend.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TokenTransferInput): unknown {
    const obj: any = {};
    if (message.outputsToSpend?.length) {
      obj.outputsToSpend = message.outputsToSpend.map((e) => TokenOutputToSpend.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TokenTransferInput>): TokenTransferInput {
    return TokenTransferInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenTransferInput>): TokenTransferInput {
    const message = createBaseTokenTransferInput();
    message.outputsToSpend = object.outputsToSpend?.map((e) => TokenOutputToSpend.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTokenMintInput(): TokenMintInput {
  return { issuerPublicKey: new Uint8Array(0), issuerProvidedTimestamp: 0, tokenIdentifier: undefined };
}

export const TokenMintInput: MessageFns<TokenMintInput> = {
  encode(message: TokenMintInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issuerPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.issuerPublicKey);
    }
    if (message.issuerProvidedTimestamp !== 0) {
      writer.uint32(16).uint64(message.issuerProvidedTimestamp);
    }
    if (message.tokenIdentifier !== undefined) {
      writer.uint32(26).bytes(message.tokenIdentifier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenMintInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenMintInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.issuerPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.issuerProvidedTimestamp = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenIdentifier = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenMintInput {
    return {
      issuerPublicKey: isSet(object.issuerPublicKey) ? bytesFromBase64(object.issuerPublicKey) : new Uint8Array(0),
      issuerProvidedTimestamp: isSet(object.issuerProvidedTimestamp)
        ? globalThis.Number(object.issuerProvidedTimestamp)
        : 0,
      tokenIdentifier: isSet(object.tokenIdentifier) ? bytesFromBase64(object.tokenIdentifier) : undefined,
    };
  },

  toJSON(message: TokenMintInput): unknown {
    const obj: any = {};
    if (message.issuerPublicKey.length !== 0) {
      obj.issuerPublicKey = base64FromBytes(message.issuerPublicKey);
    }
    if (message.issuerProvidedTimestamp !== 0) {
      obj.issuerProvidedTimestamp = Math.round(message.issuerProvidedTimestamp);
    }
    if (message.tokenIdentifier !== undefined) {
      obj.tokenIdentifier = base64FromBytes(message.tokenIdentifier);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenMintInput>): TokenMintInput {
    return TokenMintInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenMintInput>): TokenMintInput {
    const message = createBaseTokenMintInput();
    message.issuerPublicKey = object.issuerPublicKey ?? new Uint8Array(0);
    message.issuerProvidedTimestamp = object.issuerProvidedTimestamp ?? 0;
    message.tokenIdentifier = object.tokenIdentifier ?? undefined;
    return message;
  },
};

function createBaseTokenCreateInput(): TokenCreateInput {
  return {
    issuerPublicKey: new Uint8Array(0),
    tokenName: "",
    tokenTicker: "",
    decimals: 0,
    maxSupply: new Uint8Array(0),
    isFreezable: false,
    creationEntityPublicKey: undefined,
  };
}

export const TokenCreateInput: MessageFns<TokenCreateInput> = {
  encode(message: TokenCreateInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issuerPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.issuerPublicKey);
    }
    if (message.tokenName !== "") {
      writer.uint32(18).string(message.tokenName);
    }
    if (message.tokenTicker !== "") {
      writer.uint32(26).string(message.tokenTicker);
    }
    if (message.decimals !== 0) {
      writer.uint32(32).uint32(message.decimals);
    }
    if (message.maxSupply.length !== 0) {
      writer.uint32(42).bytes(message.maxSupply);
    }
    if (message.isFreezable !== false) {
      writer.uint32(48).bool(message.isFreezable);
    }
    if (message.creationEntityPublicKey !== undefined) {
      writer.uint32(58).bytes(message.creationEntityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenCreateInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenCreateInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.issuerPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenTicker = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.decimals = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.maxSupply = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isFreezable = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.creationEntityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenCreateInput {
    return {
      issuerPublicKey: isSet(object.issuerPublicKey) ? bytesFromBase64(object.issuerPublicKey) : new Uint8Array(0),
      tokenName: isSet(object.tokenName) ? globalThis.String(object.tokenName) : "",
      tokenTicker: isSet(object.tokenTicker) ? globalThis.String(object.tokenTicker) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      maxSupply: isSet(object.maxSupply) ? bytesFromBase64(object.maxSupply) : new Uint8Array(0),
      isFreezable: isSet(object.isFreezable) ? globalThis.Boolean(object.isFreezable) : false,
      creationEntityPublicKey: isSet(object.creationEntityPublicKey)
        ? bytesFromBase64(object.creationEntityPublicKey)
        : undefined,
    };
  },

  toJSON(message: TokenCreateInput): unknown {
    const obj: any = {};
    if (message.issuerPublicKey.length !== 0) {
      obj.issuerPublicKey = base64FromBytes(message.issuerPublicKey);
    }
    if (message.tokenName !== "") {
      obj.tokenName = message.tokenName;
    }
    if (message.tokenTicker !== "") {
      obj.tokenTicker = message.tokenTicker;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.maxSupply.length !== 0) {
      obj.maxSupply = base64FromBytes(message.maxSupply);
    }
    if (message.isFreezable !== false) {
      obj.isFreezable = message.isFreezable;
    }
    if (message.creationEntityPublicKey !== undefined) {
      obj.creationEntityPublicKey = base64FromBytes(message.creationEntityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenCreateInput>): TokenCreateInput {
    return TokenCreateInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenCreateInput>): TokenCreateInput {
    const message = createBaseTokenCreateInput();
    message.issuerPublicKey = object.issuerPublicKey ?? new Uint8Array(0);
    message.tokenName = object.tokenName ?? "";
    message.tokenTicker = object.tokenTicker ?? "";
    message.decimals = object.decimals ?? 0;
    message.maxSupply = object.maxSupply ?? new Uint8Array(0);
    message.isFreezable = object.isFreezable ?? false;
    message.creationEntityPublicKey = object.creationEntityPublicKey ?? undefined;
    return message;
  },
};

function createBaseTokenOutput(): TokenOutput {
  return {
    id: undefined,
    ownerPublicKey: new Uint8Array(0),
    revocationCommitment: undefined,
    withdrawBondSats: undefined,
    withdrawRelativeBlockLocktime: undefined,
    tokenPublicKey: undefined,
    tokenIdentifier: undefined,
    tokenAmount: new Uint8Array(0),
  };
}

export const TokenOutput: MessageFns<TokenOutput> = {
  encode(message: TokenOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    if (message.ownerPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerPublicKey);
    }
    if (message.revocationCommitment !== undefined) {
      writer.uint32(26).bytes(message.revocationCommitment);
    }
    if (message.withdrawBondSats !== undefined) {
      writer.uint32(32).uint64(message.withdrawBondSats);
    }
    if (message.withdrawRelativeBlockLocktime !== undefined) {
      writer.uint32(40).uint64(message.withdrawRelativeBlockLocktime);
    }
    if (message.tokenPublicKey !== undefined) {
      writer.uint32(50).bytes(message.tokenPublicKey);
    }
    if (message.tokenIdentifier !== undefined) {
      writer.uint32(66).bytes(message.tokenIdentifier);
    }
    if (message.tokenAmount.length !== 0) {
      writer.uint32(58).bytes(message.tokenAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.revocationCommitment = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.withdrawBondSats = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.withdrawRelativeBlockLocktime = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tokenPublicKey = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tokenIdentifier = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tokenAmount = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenOutput {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      ownerPublicKey: isSet(object.ownerPublicKey) ? bytesFromBase64(object.ownerPublicKey) : new Uint8Array(0),
      revocationCommitment: isSet(object.revocationCommitment)
        ? bytesFromBase64(object.revocationCommitment)
        : undefined,
      withdrawBondSats: isSet(object.withdrawBondSats) ? globalThis.Number(object.withdrawBondSats) : undefined,
      withdrawRelativeBlockLocktime: isSet(object.withdrawRelativeBlockLocktime)
        ? globalThis.Number(object.withdrawRelativeBlockLocktime)
        : undefined,
      tokenPublicKey: isSet(object.tokenPublicKey) ? bytesFromBase64(object.tokenPublicKey) : undefined,
      tokenIdentifier: isSet(object.tokenIdentifier) ? bytesFromBase64(object.tokenIdentifier) : undefined,
      tokenAmount: isSet(object.tokenAmount) ? bytesFromBase64(object.tokenAmount) : new Uint8Array(0),
    };
  },

  toJSON(message: TokenOutput): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.ownerPublicKey.length !== 0) {
      obj.ownerPublicKey = base64FromBytes(message.ownerPublicKey);
    }
    if (message.revocationCommitment !== undefined) {
      obj.revocationCommitment = base64FromBytes(message.revocationCommitment);
    }
    if (message.withdrawBondSats !== undefined) {
      obj.withdrawBondSats = Math.round(message.withdrawBondSats);
    }
    if (message.withdrawRelativeBlockLocktime !== undefined) {
      obj.withdrawRelativeBlockLocktime = Math.round(message.withdrawRelativeBlockLocktime);
    }
    if (message.tokenPublicKey !== undefined) {
      obj.tokenPublicKey = base64FromBytes(message.tokenPublicKey);
    }
    if (message.tokenIdentifier !== undefined) {
      obj.tokenIdentifier = base64FromBytes(message.tokenIdentifier);
    }
    if (message.tokenAmount.length !== 0) {
      obj.tokenAmount = base64FromBytes(message.tokenAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenOutput>): TokenOutput {
    return TokenOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenOutput>): TokenOutput {
    const message = createBaseTokenOutput();
    message.id = object.id ?? undefined;
    message.ownerPublicKey = object.ownerPublicKey ?? new Uint8Array(0);
    message.revocationCommitment = object.revocationCommitment ?? undefined;
    message.withdrawBondSats = object.withdrawBondSats ?? undefined;
    message.withdrawRelativeBlockLocktime = object.withdrawRelativeBlockLocktime ?? undefined;
    message.tokenPublicKey = object.tokenPublicKey ?? undefined;
    message.tokenIdentifier = object.tokenIdentifier ?? undefined;
    message.tokenAmount = object.tokenAmount ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTokenTransaction(): TokenTransaction {
  return { tokenInputs: undefined, tokenOutputs: [], sparkOperatorIdentityPublicKeys: [], network: 0 };
}

export const TokenTransaction: MessageFns<TokenTransaction> = {
  encode(message: TokenTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.tokenInputs?.$case) {
      case "mintInput":
        TokenMintInput.encode(message.tokenInputs.mintInput, writer.uint32(10).fork()).join();
        break;
      case "transferInput":
        TokenTransferInput.encode(message.tokenInputs.transferInput, writer.uint32(18).fork()).join();
        break;
      case "createInput":
        TokenCreateInput.encode(message.tokenInputs.createInput, writer.uint32(42).fork()).join();
        break;
    }
    for (const v of message.tokenOutputs) {
      TokenOutput.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.sparkOperatorIdentityPublicKeys) {
      writer.uint32(34).bytes(v!);
    }
    if (message.network !== 0) {
      writer.uint32(80).int32(message.network);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenInputs = { $case: "mintInput", mintInput: TokenMintInput.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenInputs = {
            $case: "transferInput",
            transferInput: TokenTransferInput.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tokenInputs = { $case: "createInput", createInput: TokenCreateInput.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenOutputs.push(TokenOutput.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sparkOperatorIdentityPublicKeys.push(reader.bytes());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenTransaction {
    return {
      tokenInputs: isSet(object.mintInput)
        ? { $case: "mintInput", mintInput: TokenMintInput.fromJSON(object.mintInput) }
        : isSet(object.transferInput)
        ? { $case: "transferInput", transferInput: TokenTransferInput.fromJSON(object.transferInput) }
        : isSet(object.createInput)
        ? { $case: "createInput", createInput: TokenCreateInput.fromJSON(object.createInput) }
        : undefined,
      tokenOutputs: globalThis.Array.isArray(object?.tokenOutputs)
        ? object.tokenOutputs.map((e: any) => TokenOutput.fromJSON(e))
        : [],
      sparkOperatorIdentityPublicKeys: globalThis.Array.isArray(object?.sparkOperatorIdentityPublicKeys)
        ? object.sparkOperatorIdentityPublicKeys.map((e: any) => bytesFromBase64(e))
        : [],
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
    };
  },

  toJSON(message: TokenTransaction): unknown {
    const obj: any = {};
    if (message.tokenInputs?.$case === "mintInput") {
      obj.mintInput = TokenMintInput.toJSON(message.tokenInputs.mintInput);
    } else if (message.tokenInputs?.$case === "transferInput") {
      obj.transferInput = TokenTransferInput.toJSON(message.tokenInputs.transferInput);
    } else if (message.tokenInputs?.$case === "createInput") {
      obj.createInput = TokenCreateInput.toJSON(message.tokenInputs.createInput);
    }
    if (message.tokenOutputs?.length) {
      obj.tokenOutputs = message.tokenOutputs.map((e) => TokenOutput.toJSON(e));
    }
    if (message.sparkOperatorIdentityPublicKeys?.length) {
      obj.sparkOperatorIdentityPublicKeys = message.sparkOperatorIdentityPublicKeys.map((e) => base64FromBytes(e));
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenTransaction>): TokenTransaction {
    return TokenTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenTransaction>): TokenTransaction {
    const message = createBaseTokenTransaction();
    switch (object.tokenInputs?.$case) {
      case "mintInput": {
        if (object.tokenInputs?.mintInput !== undefined && object.tokenInputs?.mintInput !== null) {
          message.tokenInputs = {
            $case: "mintInput",
            mintInput: TokenMintInput.fromPartial(object.tokenInputs.mintInput),
          };
        }
        break;
      }
      case "transferInput": {
        if (object.tokenInputs?.transferInput !== undefined && object.tokenInputs?.transferInput !== null) {
          message.tokenInputs = {
            $case: "transferInput",
            transferInput: TokenTransferInput.fromPartial(object.tokenInputs.transferInput),
          };
        }
        break;
      }
      case "createInput": {
        if (object.tokenInputs?.createInput !== undefined && object.tokenInputs?.createInput !== null) {
          message.tokenInputs = {
            $case: "createInput",
            createInput: TokenCreateInput.fromPartial(object.tokenInputs.createInput),
          };
        }
        break;
      }
    }
    message.tokenOutputs = object.tokenOutputs?.map((e) => TokenOutput.fromPartial(e)) || [];
    message.sparkOperatorIdentityPublicKeys = object.sparkOperatorIdentityPublicKeys?.map((e) => e) || [];
    message.network = object.network ?? 0;
    return message;
  },
};

function createBaseSpentTokenOutputMetadata(): SpentTokenOutputMetadata {
  return { outputId: "", revocationSecret: new Uint8Array(0) };
}

export const SpentTokenOutputMetadata: MessageFns<SpentTokenOutputMetadata> = {
  encode(message: SpentTokenOutputMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputId !== "") {
      writer.uint32(10).string(message.outputId);
    }
    if (message.revocationSecret.length !== 0) {
      writer.uint32(18).bytes(message.revocationSecret);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpentTokenOutputMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpentTokenOutputMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.revocationSecret = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpentTokenOutputMetadata {
    return {
      outputId: isSet(object.outputId) ? globalThis.String(object.outputId) : "",
      revocationSecret: isSet(object.revocationSecret) ? bytesFromBase64(object.revocationSecret) : new Uint8Array(0),
    };
  },

  toJSON(message: SpentTokenOutputMetadata): unknown {
    const obj: any = {};
    if (message.outputId !== "") {
      obj.outputId = message.outputId;
    }
    if (message.revocationSecret.length !== 0) {
      obj.revocationSecret = base64FromBytes(message.revocationSecret);
    }
    return obj;
  },

  create(base?: DeepPartial<SpentTokenOutputMetadata>): SpentTokenOutputMetadata {
    return SpentTokenOutputMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpentTokenOutputMetadata>): SpentTokenOutputMetadata {
    const message = createBaseSpentTokenOutputMetadata();
    message.outputId = object.outputId ?? "";
    message.revocationSecret = object.revocationSecret ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTokenTransactionConfirmationMetadata(): TokenTransactionConfirmationMetadata {
  return { spentTokenOutputsMetadata: [] };
}

export const TokenTransactionConfirmationMetadata: MessageFns<TokenTransactionConfirmationMetadata> = {
  encode(message: TokenTransactionConfirmationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.spentTokenOutputsMetadata) {
      SpentTokenOutputMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenTransactionConfirmationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenTransactionConfirmationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.spentTokenOutputsMetadata.push(SpentTokenOutputMetadata.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenTransactionConfirmationMetadata {
    return {
      spentTokenOutputsMetadata: globalThis.Array.isArray(object?.spentTokenOutputsMetadata)
        ? object.spentTokenOutputsMetadata.map((e: any) => SpentTokenOutputMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TokenTransactionConfirmationMetadata): unknown {
    const obj: any = {};
    if (message.spentTokenOutputsMetadata?.length) {
      obj.spentTokenOutputsMetadata = message.spentTokenOutputsMetadata.map((e) => SpentTokenOutputMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TokenTransactionConfirmationMetadata>): TokenTransactionConfirmationMetadata {
    return TokenTransactionConfirmationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenTransactionConfirmationMetadata>): TokenTransactionConfirmationMetadata {
    const message = createBaseTokenTransactionConfirmationMetadata();
    message.spentTokenOutputsMetadata =
      object.spentTokenOutputsMetadata?.map((e) => SpentTokenOutputMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTokenTransactionWithStatus(): TokenTransactionWithStatus {
  return {
    tokenTransaction: undefined,
    status: 0,
    confirmationMetadata: undefined,
    tokenTransactionHash: new Uint8Array(0),
  };
}

export const TokenTransactionWithStatus: MessageFns<TokenTransactionWithStatus> = {
  encode(message: TokenTransactionWithStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenTransaction !== undefined) {
      TokenTransaction.encode(message.tokenTransaction, writer.uint32(10).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.confirmationMetadata !== undefined) {
      TokenTransactionConfirmationMetadata.encode(message.confirmationMetadata, writer.uint32(26).fork()).join();
    }
    if (message.tokenTransactionHash.length !== 0) {
      writer.uint32(34).bytes(message.tokenTransactionHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenTransactionWithStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenTransactionWithStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenTransaction = TokenTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.confirmationMetadata = TokenTransactionConfirmationMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tokenTransactionHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenTransactionWithStatus {
    return {
      tokenTransaction: isSet(object.tokenTransaction) ? TokenTransaction.fromJSON(object.tokenTransaction) : undefined,
      status: isSet(object.status) ? tokenTransactionStatusFromJSON(object.status) : 0,
      confirmationMetadata: isSet(object.confirmationMetadata)
        ? TokenTransactionConfirmationMetadata.fromJSON(object.confirmationMetadata)
        : undefined,
      tokenTransactionHash: isSet(object.tokenTransactionHash)
        ? bytesFromBase64(object.tokenTransactionHash)
        : new Uint8Array(0),
    };
  },

  toJSON(message: TokenTransactionWithStatus): unknown {
    const obj: any = {};
    if (message.tokenTransaction !== undefined) {
      obj.tokenTransaction = TokenTransaction.toJSON(message.tokenTransaction);
    }
    if (message.status !== 0) {
      obj.status = tokenTransactionStatusToJSON(message.status);
    }
    if (message.confirmationMetadata !== undefined) {
      obj.confirmationMetadata = TokenTransactionConfirmationMetadata.toJSON(message.confirmationMetadata);
    }
    if (message.tokenTransactionHash.length !== 0) {
      obj.tokenTransactionHash = base64FromBytes(message.tokenTransactionHash);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenTransactionWithStatus>): TokenTransactionWithStatus {
    return TokenTransactionWithStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenTransactionWithStatus>): TokenTransactionWithStatus {
    const message = createBaseTokenTransactionWithStatus();
    message.tokenTransaction = (object.tokenTransaction !== undefined && object.tokenTransaction !== null)
      ? TokenTransaction.fromPartial(object.tokenTransaction)
      : undefined;
    message.status = object.status ?? 0;
    message.confirmationMetadata = (object.confirmationMetadata !== undefined && object.confirmationMetadata !== null)
      ? TokenTransactionConfirmationMetadata.fromPartial(object.confirmationMetadata)
      : undefined;
    message.tokenTransactionHash = object.tokenTransactionHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSignatureWithIndex(): SignatureWithIndex {
  return { signature: new Uint8Array(0), inputIndex: 0 };
}

export const SignatureWithIndex: MessageFns<SignatureWithIndex> = {
  encode(message: SignatureWithIndex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    if (message.inputIndex !== 0) {
      writer.uint32(16).uint32(message.inputIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignatureWithIndex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignatureWithIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inputIndex = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignatureWithIndex {
    return {
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      inputIndex: isSet(object.inputIndex) ? globalThis.Number(object.inputIndex) : 0,
    };
  },

  toJSON(message: SignatureWithIndex): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.inputIndex !== 0) {
      obj.inputIndex = Math.round(message.inputIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<SignatureWithIndex>): SignatureWithIndex {
    return SignatureWithIndex.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignatureWithIndex>): SignatureWithIndex {
    const message = createBaseSignatureWithIndex();
    message.signature = object.signature ?? new Uint8Array(0);
    message.inputIndex = object.inputIndex ?? 0;
    return message;
  },
};

function createBaseTokenTransactionSignatures(): TokenTransactionSignatures {
  return { ownerSignatures: [] };
}

export const TokenTransactionSignatures: MessageFns<TokenTransactionSignatures> = {
  encode(message: TokenTransactionSignatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ownerSignatures) {
      SignatureWithIndex.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenTransactionSignatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenTransactionSignatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerSignatures.push(SignatureWithIndex.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenTransactionSignatures {
    return {
      ownerSignatures: globalThis.Array.isArray(object?.ownerSignatures)
        ? object.ownerSignatures.map((e: any) => SignatureWithIndex.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TokenTransactionSignatures): unknown {
    const obj: any = {};
    if (message.ownerSignatures?.length) {
      obj.ownerSignatures = message.ownerSignatures.map((e) => SignatureWithIndex.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TokenTransactionSignatures>): TokenTransactionSignatures {
    return TokenTransactionSignatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenTransactionSignatures>): TokenTransactionSignatures {
    const message = createBaseTokenTransactionSignatures();
    message.ownerSignatures = object.ownerSignatures?.map((e) => SignatureWithIndex.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStartTokenTransactionRequest(): StartTokenTransactionRequest {
  return {
    identityPublicKey: new Uint8Array(0),
    partialTokenTransaction: undefined,
    tokenTransactionSignatures: undefined,
    sparkPaymentIntent: "",
  };
}

export const StartTokenTransactionRequest: MessageFns<StartTokenTransactionRequest> = {
  encode(message: StartTokenTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.identityPublicKey);
    }
    if (message.partialTokenTransaction !== undefined) {
      TokenTransaction.encode(message.partialTokenTransaction, writer.uint32(18).fork()).join();
    }
    if (message.tokenTransactionSignatures !== undefined) {
      TokenTransactionSignatures.encode(message.tokenTransactionSignatures, writer.uint32(26).fork()).join();
    }
    if (message.sparkPaymentIntent !== "") {
      writer.uint32(34).string(message.sparkPaymentIntent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTokenTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTokenTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.partialTokenTransaction = TokenTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenTransactionSignatures = TokenTransactionSignatures.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sparkPaymentIntent = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTokenTransactionRequest {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      partialTokenTransaction: isSet(object.partialTokenTransaction)
        ? TokenTransaction.fromJSON(object.partialTokenTransaction)
        : undefined,
      tokenTransactionSignatures: isSet(object.tokenTransactionSignatures)
        ? TokenTransactionSignatures.fromJSON(object.tokenTransactionSignatures)
        : undefined,
      sparkPaymentIntent: isSet(object.sparkPaymentIntent) ? globalThis.String(object.sparkPaymentIntent) : "",
    };
  },

  toJSON(message: StartTokenTransactionRequest): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.partialTokenTransaction !== undefined) {
      obj.partialTokenTransaction = TokenTransaction.toJSON(message.partialTokenTransaction);
    }
    if (message.tokenTransactionSignatures !== undefined) {
      obj.tokenTransactionSignatures = TokenTransactionSignatures.toJSON(message.tokenTransactionSignatures);
    }
    if (message.sparkPaymentIntent !== "") {
      obj.sparkPaymentIntent = message.sparkPaymentIntent;
    }
    return obj;
  },

  create(base?: DeepPartial<StartTokenTransactionRequest>): StartTokenTransactionRequest {
    return StartTokenTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTokenTransactionRequest>): StartTokenTransactionRequest {
    const message = createBaseStartTokenTransactionRequest();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.partialTokenTransaction =
      (object.partialTokenTransaction !== undefined && object.partialTokenTransaction !== null)
        ? TokenTransaction.fromPartial(object.partialTokenTransaction)
        : undefined;
    message.tokenTransactionSignatures =
      (object.tokenTransactionSignatures !== undefined && object.tokenTransactionSignatures !== null)
        ? TokenTransactionSignatures.fromPartial(object.tokenTransactionSignatures)
        : undefined;
    message.sparkPaymentIntent = object.sparkPaymentIntent ?? "";
    return message;
  },
};

function createBaseStartTokenTransactionResponse(): StartTokenTransactionResponse {
  return { finalTokenTransaction: undefined, keyshareInfo: undefined };
}

export const StartTokenTransactionResponse: MessageFns<StartTokenTransactionResponse> = {
  encode(message: StartTokenTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.finalTokenTransaction !== undefined) {
      TokenTransaction.encode(message.finalTokenTransaction, writer.uint32(10).fork()).join();
    }
    if (message.keyshareInfo !== undefined) {
      SigningKeyshare.encode(message.keyshareInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTokenTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTokenTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.finalTokenTransaction = TokenTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyshareInfo = SigningKeyshare.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTokenTransactionResponse {
    return {
      finalTokenTransaction: isSet(object.finalTokenTransaction)
        ? TokenTransaction.fromJSON(object.finalTokenTransaction)
        : undefined,
      keyshareInfo: isSet(object.keyshareInfo) ? SigningKeyshare.fromJSON(object.keyshareInfo) : undefined,
    };
  },

  toJSON(message: StartTokenTransactionResponse): unknown {
    const obj: any = {};
    if (message.finalTokenTransaction !== undefined) {
      obj.finalTokenTransaction = TokenTransaction.toJSON(message.finalTokenTransaction);
    }
    if (message.keyshareInfo !== undefined) {
      obj.keyshareInfo = SigningKeyshare.toJSON(message.keyshareInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<StartTokenTransactionResponse>): StartTokenTransactionResponse {
    return StartTokenTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTokenTransactionResponse>): StartTokenTransactionResponse {
    const message = createBaseStartTokenTransactionResponse();
    message.finalTokenTransaction =
      (object.finalTokenTransaction !== undefined && object.finalTokenTransaction !== null)
        ? TokenTransaction.fromPartial(object.finalTokenTransaction)
        : undefined;
    message.keyshareInfo = (object.keyshareInfo !== undefined && object.keyshareInfo !== null)
      ? SigningKeyshare.fromPartial(object.keyshareInfo)
      : undefined;
    return message;
  },
};

function createBaseOperatorSpecificTokenTransactionSignablePayload(): OperatorSpecificTokenTransactionSignablePayload {
  return { finalTokenTransactionHash: new Uint8Array(0), operatorIdentityPublicKey: new Uint8Array(0) };
}

export const OperatorSpecificTokenTransactionSignablePayload: MessageFns<
  OperatorSpecificTokenTransactionSignablePayload
> = {
  encode(
    message: OperatorSpecificTokenTransactionSignablePayload,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.finalTokenTransactionHash.length !== 0) {
      writer.uint32(10).bytes(message.finalTokenTransactionHash);
    }
    if (message.operatorIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.operatorIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperatorSpecificTokenTransactionSignablePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperatorSpecificTokenTransactionSignablePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.finalTokenTransactionHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operatorIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperatorSpecificTokenTransactionSignablePayload {
    return {
      finalTokenTransactionHash: isSet(object.finalTokenTransactionHash)
        ? bytesFromBase64(object.finalTokenTransactionHash)
        : new Uint8Array(0),
      operatorIdentityPublicKey: isSet(object.operatorIdentityPublicKey)
        ? bytesFromBase64(object.operatorIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: OperatorSpecificTokenTransactionSignablePayload): unknown {
    const obj: any = {};
    if (message.finalTokenTransactionHash.length !== 0) {
      obj.finalTokenTransactionHash = base64FromBytes(message.finalTokenTransactionHash);
    }
    if (message.operatorIdentityPublicKey.length !== 0) {
      obj.operatorIdentityPublicKey = base64FromBytes(message.operatorIdentityPublicKey);
    }
    return obj;
  },

  create(
    base?: DeepPartial<OperatorSpecificTokenTransactionSignablePayload>,
  ): OperatorSpecificTokenTransactionSignablePayload {
    return OperatorSpecificTokenTransactionSignablePayload.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<OperatorSpecificTokenTransactionSignablePayload>,
  ): OperatorSpecificTokenTransactionSignablePayload {
    const message = createBaseOperatorSpecificTokenTransactionSignablePayload();
    message.finalTokenTransactionHash = object.finalTokenTransactionHash ?? new Uint8Array(0);
    message.operatorIdentityPublicKey = object.operatorIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseOperatorSpecificOwnerSignature(): OperatorSpecificOwnerSignature {
  return { ownerSignature: undefined, payload: undefined };
}

export const OperatorSpecificOwnerSignature: MessageFns<OperatorSpecificOwnerSignature> = {
  encode(message: OperatorSpecificOwnerSignature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerSignature !== undefined) {
      SignatureWithIndex.encode(message.ownerSignature, writer.uint32(10).fork()).join();
    }
    if (message.payload !== undefined) {
      OperatorSpecificTokenTransactionSignablePayload.encode(message.payload, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperatorSpecificOwnerSignature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperatorSpecificOwnerSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerSignature = SignatureWithIndex.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = OperatorSpecificTokenTransactionSignablePayload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperatorSpecificOwnerSignature {
    return {
      ownerSignature: isSet(object.ownerSignature) ? SignatureWithIndex.fromJSON(object.ownerSignature) : undefined,
      payload: isSet(object.payload)
        ? OperatorSpecificTokenTransactionSignablePayload.fromJSON(object.payload)
        : undefined,
    };
  },

  toJSON(message: OperatorSpecificOwnerSignature): unknown {
    const obj: any = {};
    if (message.ownerSignature !== undefined) {
      obj.ownerSignature = SignatureWithIndex.toJSON(message.ownerSignature);
    }
    if (message.payload !== undefined) {
      obj.payload = OperatorSpecificTokenTransactionSignablePayload.toJSON(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<OperatorSpecificOwnerSignature>): OperatorSpecificOwnerSignature {
    return OperatorSpecificOwnerSignature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperatorSpecificOwnerSignature>): OperatorSpecificOwnerSignature {
    const message = createBaseOperatorSpecificOwnerSignature();
    message.ownerSignature = (object.ownerSignature !== undefined && object.ownerSignature !== null)
      ? SignatureWithIndex.fromPartial(object.ownerSignature)
      : undefined;
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? OperatorSpecificTokenTransactionSignablePayload.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseSignTokenTransactionRequest(): SignTokenTransactionRequest {
  return { finalTokenTransaction: undefined, operatorSpecificSignatures: [], identityPublicKey: new Uint8Array(0) };
}

export const SignTokenTransactionRequest: MessageFns<SignTokenTransactionRequest> = {
  encode(message: SignTokenTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.finalTokenTransaction !== undefined) {
      TokenTransaction.encode(message.finalTokenTransaction, writer.uint32(10).fork()).join();
    }
    for (const v of message.operatorSpecificSignatures) {
      OperatorSpecificOwnerSignature.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.identityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignTokenTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignTokenTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.finalTokenTransaction = TokenTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operatorSpecificSignatures.push(OperatorSpecificOwnerSignature.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignTokenTransactionRequest {
    return {
      finalTokenTransaction: isSet(object.finalTokenTransaction)
        ? TokenTransaction.fromJSON(object.finalTokenTransaction)
        : undefined,
      operatorSpecificSignatures: globalThis.Array.isArray(object?.operatorSpecificSignatures)
        ? object.operatorSpecificSignatures.map((e: any) => OperatorSpecificOwnerSignature.fromJSON(e))
        : [],
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SignTokenTransactionRequest): unknown {
    const obj: any = {};
    if (message.finalTokenTransaction !== undefined) {
      obj.finalTokenTransaction = TokenTransaction.toJSON(message.finalTokenTransaction);
    }
    if (message.operatorSpecificSignatures?.length) {
      obj.operatorSpecificSignatures = message.operatorSpecificSignatures.map((e) =>
        OperatorSpecificOwnerSignature.toJSON(e)
      );
    }
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<SignTokenTransactionRequest>): SignTokenTransactionRequest {
    return SignTokenTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignTokenTransactionRequest>): SignTokenTransactionRequest {
    const message = createBaseSignTokenTransactionRequest();
    message.finalTokenTransaction =
      (object.finalTokenTransaction !== undefined && object.finalTokenTransaction !== null)
        ? TokenTransaction.fromPartial(object.finalTokenTransaction)
        : undefined;
    message.operatorSpecificSignatures =
      object.operatorSpecificSignatures?.map((e) => OperatorSpecificOwnerSignature.fromPartial(e)) || [];
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseKeyshareWithIndex(): KeyshareWithIndex {
  return { inputIndex: 0, keyshare: new Uint8Array(0) };
}

export const KeyshareWithIndex: MessageFns<KeyshareWithIndex> = {
  encode(message: KeyshareWithIndex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputIndex !== 0) {
      writer.uint32(8).uint32(message.inputIndex);
    }
    if (message.keyshare.length !== 0) {
      writer.uint32(18).bytes(message.keyshare);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyshareWithIndex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyshareWithIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.inputIndex = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyshare = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyshareWithIndex {
    return {
      inputIndex: isSet(object.inputIndex) ? globalThis.Number(object.inputIndex) : 0,
      keyshare: isSet(object.keyshare) ? bytesFromBase64(object.keyshare) : new Uint8Array(0),
    };
  },

  toJSON(message: KeyshareWithIndex): unknown {
    const obj: any = {};
    if (message.inputIndex !== 0) {
      obj.inputIndex = Math.round(message.inputIndex);
    }
    if (message.keyshare.length !== 0) {
      obj.keyshare = base64FromBytes(message.keyshare);
    }
    return obj;
  },

  create(base?: DeepPartial<KeyshareWithIndex>): KeyshareWithIndex {
    return KeyshareWithIndex.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyshareWithIndex>): KeyshareWithIndex {
    const message = createBaseKeyshareWithIndex();
    message.inputIndex = object.inputIndex ?? 0;
    message.keyshare = object.keyshare ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSignTokenTransactionResponse(): SignTokenTransactionResponse {
  return { sparkOperatorSignature: new Uint8Array(0), revocationKeyshares: [] };
}

export const SignTokenTransactionResponse: MessageFns<SignTokenTransactionResponse> = {
  encode(message: SignTokenTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sparkOperatorSignature.length !== 0) {
      writer.uint32(10).bytes(message.sparkOperatorSignature);
    }
    for (const v of message.revocationKeyshares) {
      KeyshareWithIndex.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignTokenTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignTokenTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sparkOperatorSignature = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.revocationKeyshares.push(KeyshareWithIndex.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignTokenTransactionResponse {
    return {
      sparkOperatorSignature: isSet(object.sparkOperatorSignature)
        ? bytesFromBase64(object.sparkOperatorSignature)
        : new Uint8Array(0),
      revocationKeyshares: globalThis.Array.isArray(object?.revocationKeyshares)
        ? object.revocationKeyshares.map((e: any) => KeyshareWithIndex.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SignTokenTransactionResponse): unknown {
    const obj: any = {};
    if (message.sparkOperatorSignature.length !== 0) {
      obj.sparkOperatorSignature = base64FromBytes(message.sparkOperatorSignature);
    }
    if (message.revocationKeyshares?.length) {
      obj.revocationKeyshares = message.revocationKeyshares.map((e) => KeyshareWithIndex.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SignTokenTransactionResponse>): SignTokenTransactionResponse {
    return SignTokenTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignTokenTransactionResponse>): SignTokenTransactionResponse {
    const message = createBaseSignTokenTransactionResponse();
    message.sparkOperatorSignature = object.sparkOperatorSignature ?? new Uint8Array(0);
    message.revocationKeyshares = object.revocationKeyshares?.map((e) => KeyshareWithIndex.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRevocationSecretWithIndex(): RevocationSecretWithIndex {
  return { inputIndex: 0, revocationSecret: new Uint8Array(0) };
}

export const RevocationSecretWithIndex: MessageFns<RevocationSecretWithIndex> = {
  encode(message: RevocationSecretWithIndex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputIndex !== 0) {
      writer.uint32(8).uint32(message.inputIndex);
    }
    if (message.revocationSecret.length !== 0) {
      writer.uint32(18).bytes(message.revocationSecret);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevocationSecretWithIndex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevocationSecretWithIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.inputIndex = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.revocationSecret = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevocationSecretWithIndex {
    return {
      inputIndex: isSet(object.inputIndex) ? globalThis.Number(object.inputIndex) : 0,
      revocationSecret: isSet(object.revocationSecret) ? bytesFromBase64(object.revocationSecret) : new Uint8Array(0),
    };
  },

  toJSON(message: RevocationSecretWithIndex): unknown {
    const obj: any = {};
    if (message.inputIndex !== 0) {
      obj.inputIndex = Math.round(message.inputIndex);
    }
    if (message.revocationSecret.length !== 0) {
      obj.revocationSecret = base64FromBytes(message.revocationSecret);
    }
    return obj;
  },

  create(base?: DeepPartial<RevocationSecretWithIndex>): RevocationSecretWithIndex {
    return RevocationSecretWithIndex.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RevocationSecretWithIndex>): RevocationSecretWithIndex {
    const message = createBaseRevocationSecretWithIndex();
    message.inputIndex = object.inputIndex ?? 0;
    message.revocationSecret = object.revocationSecret ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFinalizeTokenTransactionRequest(): FinalizeTokenTransactionRequest {
  return {
    finalTokenTransaction: undefined,
    revocationSecrets: [],
    identityPublicKey: new Uint8Array(0),
    sparkPaymentIntent: "",
  };
}

export const FinalizeTokenTransactionRequest: MessageFns<FinalizeTokenTransactionRequest> = {
  encode(message: FinalizeTokenTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.finalTokenTransaction !== undefined) {
      TokenTransaction.encode(message.finalTokenTransaction, writer.uint32(10).fork()).join();
    }
    for (const v of message.revocationSecrets) {
      RevocationSecretWithIndex.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.identityPublicKey);
    }
    if (message.sparkPaymentIntent !== "") {
      writer.uint32(34).string(message.sparkPaymentIntent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeTokenTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeTokenTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.finalTokenTransaction = TokenTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.revocationSecrets.push(RevocationSecretWithIndex.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sparkPaymentIntent = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeTokenTransactionRequest {
    return {
      finalTokenTransaction: isSet(object.finalTokenTransaction)
        ? TokenTransaction.fromJSON(object.finalTokenTransaction)
        : undefined,
      revocationSecrets: globalThis.Array.isArray(object?.revocationSecrets)
        ? object.revocationSecrets.map((e: any) => RevocationSecretWithIndex.fromJSON(e))
        : [],
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      sparkPaymentIntent: isSet(object.sparkPaymentIntent) ? globalThis.String(object.sparkPaymentIntent) : "",
    };
  },

  toJSON(message: FinalizeTokenTransactionRequest): unknown {
    const obj: any = {};
    if (message.finalTokenTransaction !== undefined) {
      obj.finalTokenTransaction = TokenTransaction.toJSON(message.finalTokenTransaction);
    }
    if (message.revocationSecrets?.length) {
      obj.revocationSecrets = message.revocationSecrets.map((e) => RevocationSecretWithIndex.toJSON(e));
    }
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.sparkPaymentIntent !== "") {
      obj.sparkPaymentIntent = message.sparkPaymentIntent;
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeTokenTransactionRequest>): FinalizeTokenTransactionRequest {
    return FinalizeTokenTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeTokenTransactionRequest>): FinalizeTokenTransactionRequest {
    const message = createBaseFinalizeTokenTransactionRequest();
    message.finalTokenTransaction =
      (object.finalTokenTransaction !== undefined && object.finalTokenTransaction !== null)
        ? TokenTransaction.fromPartial(object.finalTokenTransaction)
        : undefined;
    message.revocationSecrets = object.revocationSecrets?.map((e) => RevocationSecretWithIndex.fromPartial(e)) || [];
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.sparkPaymentIntent = object.sparkPaymentIntent ?? "";
    return message;
  },
};

function createBaseFreezeTokensPayload(): FreezeTokensPayload {
  return {
    ownerPublicKey: new Uint8Array(0),
    tokenPublicKey: new Uint8Array(0),
    issuerProvidedTimestamp: 0,
    operatorIdentityPublicKey: new Uint8Array(0),
    shouldUnfreeze: false,
    tokenIdentifier: undefined,
  };
}

export const FreezeTokensPayload: MessageFns<FreezeTokensPayload> = {
  encode(message: FreezeTokensPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.ownerPublicKey);
    }
    if (message.tokenPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.tokenPublicKey);
    }
    if (message.issuerProvidedTimestamp !== 0) {
      writer.uint32(24).uint64(message.issuerProvidedTimestamp);
    }
    if (message.operatorIdentityPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.operatorIdentityPublicKey);
    }
    if (message.shouldUnfreeze !== false) {
      writer.uint32(40).bool(message.shouldUnfreeze);
    }
    if (message.tokenIdentifier !== undefined) {
      writer.uint32(50).bytes(message.tokenIdentifier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FreezeTokensPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreezeTokensPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.issuerProvidedTimestamp = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.operatorIdentityPublicKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.shouldUnfreeze = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tokenIdentifier = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FreezeTokensPayload {
    return {
      ownerPublicKey: isSet(object.ownerPublicKey) ? bytesFromBase64(object.ownerPublicKey) : new Uint8Array(0),
      tokenPublicKey: isSet(object.tokenPublicKey) ? bytesFromBase64(object.tokenPublicKey) : new Uint8Array(0),
      issuerProvidedTimestamp: isSet(object.issuerProvidedTimestamp)
        ? globalThis.Number(object.issuerProvidedTimestamp)
        : 0,
      operatorIdentityPublicKey: isSet(object.operatorIdentityPublicKey)
        ? bytesFromBase64(object.operatorIdentityPublicKey)
        : new Uint8Array(0),
      shouldUnfreeze: isSet(object.shouldUnfreeze) ? globalThis.Boolean(object.shouldUnfreeze) : false,
      tokenIdentifier: isSet(object.tokenIdentifier) ? bytesFromBase64(object.tokenIdentifier) : undefined,
    };
  },

  toJSON(message: FreezeTokensPayload): unknown {
    const obj: any = {};
    if (message.ownerPublicKey.length !== 0) {
      obj.ownerPublicKey = base64FromBytes(message.ownerPublicKey);
    }
    if (message.tokenPublicKey.length !== 0) {
      obj.tokenPublicKey = base64FromBytes(message.tokenPublicKey);
    }
    if (message.issuerProvidedTimestamp !== 0) {
      obj.issuerProvidedTimestamp = Math.round(message.issuerProvidedTimestamp);
    }
    if (message.operatorIdentityPublicKey.length !== 0) {
      obj.operatorIdentityPublicKey = base64FromBytes(message.operatorIdentityPublicKey);
    }
    if (message.shouldUnfreeze !== false) {
      obj.shouldUnfreeze = message.shouldUnfreeze;
    }
    if (message.tokenIdentifier !== undefined) {
      obj.tokenIdentifier = base64FromBytes(message.tokenIdentifier);
    }
    return obj;
  },

  create(base?: DeepPartial<FreezeTokensPayload>): FreezeTokensPayload {
    return FreezeTokensPayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FreezeTokensPayload>): FreezeTokensPayload {
    const message = createBaseFreezeTokensPayload();
    message.ownerPublicKey = object.ownerPublicKey ?? new Uint8Array(0);
    message.tokenPublicKey = object.tokenPublicKey ?? new Uint8Array(0);
    message.issuerProvidedTimestamp = object.issuerProvidedTimestamp ?? 0;
    message.operatorIdentityPublicKey = object.operatorIdentityPublicKey ?? new Uint8Array(0);
    message.shouldUnfreeze = object.shouldUnfreeze ?? false;
    message.tokenIdentifier = object.tokenIdentifier ?? undefined;
    return message;
  },
};

function createBaseFreezeTokensRequest(): FreezeTokensRequest {
  return { freezeTokensPayload: undefined, issuerSignature: new Uint8Array(0) };
}

export const FreezeTokensRequest: MessageFns<FreezeTokensRequest> = {
  encode(message: FreezeTokensRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.freezeTokensPayload !== undefined) {
      FreezeTokensPayload.encode(message.freezeTokensPayload, writer.uint32(10).fork()).join();
    }
    if (message.issuerSignature.length !== 0) {
      writer.uint32(18).bytes(message.issuerSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FreezeTokensRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreezeTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.freezeTokensPayload = FreezeTokensPayload.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.issuerSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FreezeTokensRequest {
    return {
      freezeTokensPayload: isSet(object.freezeTokensPayload)
        ? FreezeTokensPayload.fromJSON(object.freezeTokensPayload)
        : undefined,
      issuerSignature: isSet(object.issuerSignature) ? bytesFromBase64(object.issuerSignature) : new Uint8Array(0),
    };
  },

  toJSON(message: FreezeTokensRequest): unknown {
    const obj: any = {};
    if (message.freezeTokensPayload !== undefined) {
      obj.freezeTokensPayload = FreezeTokensPayload.toJSON(message.freezeTokensPayload);
    }
    if (message.issuerSignature.length !== 0) {
      obj.issuerSignature = base64FromBytes(message.issuerSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<FreezeTokensRequest>): FreezeTokensRequest {
    return FreezeTokensRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FreezeTokensRequest>): FreezeTokensRequest {
    const message = createBaseFreezeTokensRequest();
    message.freezeTokensPayload = (object.freezeTokensPayload !== undefined && object.freezeTokensPayload !== null)
      ? FreezeTokensPayload.fromPartial(object.freezeTokensPayload)
      : undefined;
    message.issuerSignature = object.issuerSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFreezeTokensResponse(): FreezeTokensResponse {
  return { impactedOutputIds: [], impactedTokenAmount: new Uint8Array(0) };
}

export const FreezeTokensResponse: MessageFns<FreezeTokensResponse> = {
  encode(message: FreezeTokensResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.impactedOutputIds) {
      writer.uint32(10).string(v!);
    }
    if (message.impactedTokenAmount.length !== 0) {
      writer.uint32(18).bytes(message.impactedTokenAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FreezeTokensResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreezeTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.impactedOutputIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.impactedTokenAmount = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FreezeTokensResponse {
    return {
      impactedOutputIds: globalThis.Array.isArray(object?.impactedOutputIds)
        ? object.impactedOutputIds.map((e: any) => globalThis.String(e))
        : [],
      impactedTokenAmount: isSet(object.impactedTokenAmount)
        ? bytesFromBase64(object.impactedTokenAmount)
        : new Uint8Array(0),
    };
  },

  toJSON(message: FreezeTokensResponse): unknown {
    const obj: any = {};
    if (message.impactedOutputIds?.length) {
      obj.impactedOutputIds = message.impactedOutputIds;
    }
    if (message.impactedTokenAmount.length !== 0) {
      obj.impactedTokenAmount = base64FromBytes(message.impactedTokenAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<FreezeTokensResponse>): FreezeTokensResponse {
    return FreezeTokensResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FreezeTokensResponse>): FreezeTokensResponse {
    const message = createBaseFreezeTokensResponse();
    message.impactedOutputIds = object.impactedOutputIds?.map((e) => e) || [];
    message.impactedTokenAmount = object.impactedTokenAmount ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryTokenOutputsRequest(): QueryTokenOutputsRequest {
  return { ownerPublicKeys: [], tokenPublicKeys: [], tokenIdentifiers: [], network: 0 };
}

export const QueryTokenOutputsRequest: MessageFns<QueryTokenOutputsRequest> = {
  encode(message: QueryTokenOutputsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ownerPublicKeys) {
      writer.uint32(10).bytes(v!);
    }
    for (const v of message.tokenPublicKeys) {
      writer.uint32(18).bytes(v!);
    }
    for (const v of message.tokenIdentifiers) {
      writer.uint32(34).bytes(v!);
    }
    if (message.network !== 0) {
      writer.uint32(24).int32(message.network);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTokenOutputsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTokenOutputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerPublicKeys.push(reader.bytes());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenPublicKeys.push(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tokenIdentifiers.push(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTokenOutputsRequest {
    return {
      ownerPublicKeys: globalThis.Array.isArray(object?.ownerPublicKeys)
        ? object.ownerPublicKeys.map((e: any) => bytesFromBase64(e))
        : [],
      tokenPublicKeys: globalThis.Array.isArray(object?.tokenPublicKeys)
        ? object.tokenPublicKeys.map((e: any) => bytesFromBase64(e))
        : [],
      tokenIdentifiers: globalThis.Array.isArray(object?.tokenIdentifiers)
        ? object.tokenIdentifiers.map((e: any) => bytesFromBase64(e))
        : [],
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
    };
  },

  toJSON(message: QueryTokenOutputsRequest): unknown {
    const obj: any = {};
    if (message.ownerPublicKeys?.length) {
      obj.ownerPublicKeys = message.ownerPublicKeys.map((e) => base64FromBytes(e));
    }
    if (message.tokenPublicKeys?.length) {
      obj.tokenPublicKeys = message.tokenPublicKeys.map((e) => base64FromBytes(e));
    }
    if (message.tokenIdentifiers?.length) {
      obj.tokenIdentifiers = message.tokenIdentifiers.map((e) => base64FromBytes(e));
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTokenOutputsRequest>): QueryTokenOutputsRequest {
    return QueryTokenOutputsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTokenOutputsRequest>): QueryTokenOutputsRequest {
    const message = createBaseQueryTokenOutputsRequest();
    message.ownerPublicKeys = object.ownerPublicKeys?.map((e) => e) || [];
    message.tokenPublicKeys = object.tokenPublicKeys?.map((e) => e) || [];
    message.tokenIdentifiers = object.tokenIdentifiers?.map((e) => e) || [];
    message.network = object.network ?? 0;
    return message;
  },
};

function createBaseQueryTokenTransactionsRequest(): QueryTokenTransactionsRequest {
  return {
    outputIds: [],
    ownerPublicKeys: [],
    tokenPublicKeys: [],
    tokenIdentifiers: [],
    tokenTransactionHashes: [],
    limit: 0,
    offset: 0,
  };
}

export const QueryTokenTransactionsRequest: MessageFns<QueryTokenTransactionsRequest> = {
  encode(message: QueryTokenTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.outputIds) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.ownerPublicKeys) {
      writer.uint32(18).bytes(v!);
    }
    for (const v of message.tokenPublicKeys) {
      writer.uint32(26).bytes(v!);
    }
    for (const v of message.tokenIdentifiers) {
      writer.uint32(58).bytes(v!);
    }
    for (const v of message.tokenTransactionHashes) {
      writer.uint32(34).bytes(v!);
    }
    if (message.limit !== 0) {
      writer.uint32(40).int64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(48).int64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTokenTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTokenTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerPublicKeys.push(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenPublicKeys.push(reader.bytes());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tokenIdentifiers.push(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tokenTransactionHashes.push(reader.bytes());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.limit = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTokenTransactionsRequest {
    return {
      outputIds: globalThis.Array.isArray(object?.outputIds)
        ? object.outputIds.map((e: any) => globalThis.String(e))
        : [],
      ownerPublicKeys: globalThis.Array.isArray(object?.ownerPublicKeys)
        ? object.ownerPublicKeys.map((e: any) => bytesFromBase64(e))
        : [],
      tokenPublicKeys: globalThis.Array.isArray(object?.tokenPublicKeys)
        ? object.tokenPublicKeys.map((e: any) => bytesFromBase64(e))
        : [],
      tokenIdentifiers: globalThis.Array.isArray(object?.tokenIdentifiers)
        ? object.tokenIdentifiers.map((e: any) => bytesFromBase64(e))
        : [],
      tokenTransactionHashes: globalThis.Array.isArray(object?.tokenTransactionHashes)
        ? object.tokenTransactionHashes.map((e: any) => bytesFromBase64(e))
        : [],
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: QueryTokenTransactionsRequest): unknown {
    const obj: any = {};
    if (message.outputIds?.length) {
      obj.outputIds = message.outputIds;
    }
    if (message.ownerPublicKeys?.length) {
      obj.ownerPublicKeys = message.ownerPublicKeys.map((e) => base64FromBytes(e));
    }
    if (message.tokenPublicKeys?.length) {
      obj.tokenPublicKeys = message.tokenPublicKeys.map((e) => base64FromBytes(e));
    }
    if (message.tokenIdentifiers?.length) {
      obj.tokenIdentifiers = message.tokenIdentifiers.map((e) => base64FromBytes(e));
    }
    if (message.tokenTransactionHashes?.length) {
      obj.tokenTransactionHashes = message.tokenTransactionHashes.map((e) => base64FromBytes(e));
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTokenTransactionsRequest>): QueryTokenTransactionsRequest {
    return QueryTokenTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTokenTransactionsRequest>): QueryTokenTransactionsRequest {
    const message = createBaseQueryTokenTransactionsRequest();
    message.outputIds = object.outputIds?.map((e) => e) || [];
    message.ownerPublicKeys = object.ownerPublicKeys?.map((e) => e) || [];
    message.tokenPublicKeys = object.tokenPublicKeys?.map((e) => e) || [];
    message.tokenIdentifiers = object.tokenIdentifiers?.map((e) => e) || [];
    message.tokenTransactionHashes = object.tokenTransactionHashes?.map((e) => e) || [];
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseQueryTokenTransactionsResponse(): QueryTokenTransactionsResponse {
  return { tokenTransactionsWithStatus: [], offset: 0 };
}

export const QueryTokenTransactionsResponse: MessageFns<QueryTokenTransactionsResponse> = {
  encode(message: QueryTokenTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tokenTransactionsWithStatus) {
      TokenTransactionWithStatus.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.offset !== 0) {
      writer.uint32(16).int64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTokenTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTokenTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenTransactionsWithStatus.push(TokenTransactionWithStatus.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTokenTransactionsResponse {
    return {
      tokenTransactionsWithStatus: globalThis.Array.isArray(object?.tokenTransactionsWithStatus)
        ? object.tokenTransactionsWithStatus.map((e: any) => TokenTransactionWithStatus.fromJSON(e))
        : [],
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: QueryTokenTransactionsResponse): unknown {
    const obj: any = {};
    if (message.tokenTransactionsWithStatus?.length) {
      obj.tokenTransactionsWithStatus = message.tokenTransactionsWithStatus.map((e) =>
        TokenTransactionWithStatus.toJSON(e)
      );
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTokenTransactionsResponse>): QueryTokenTransactionsResponse {
    return QueryTokenTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTokenTransactionsResponse>): QueryTokenTransactionsResponse {
    const message = createBaseQueryTokenTransactionsResponse();
    message.tokenTransactionsWithStatus =
      object.tokenTransactionsWithStatus?.map((e) => TokenTransactionWithStatus.fromPartial(e)) || [];
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseOutputWithPreviousTransactionData(): OutputWithPreviousTransactionData {
  return { output: undefined, previousTransactionHash: new Uint8Array(0), previousTransactionVout: 0 };
}

export const OutputWithPreviousTransactionData: MessageFns<OutputWithPreviousTransactionData> = {
  encode(message: OutputWithPreviousTransactionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.output !== undefined) {
      TokenOutput.encode(message.output, writer.uint32(10).fork()).join();
    }
    if (message.previousTransactionHash.length !== 0) {
      writer.uint32(18).bytes(message.previousTransactionHash);
    }
    if (message.previousTransactionVout !== 0) {
      writer.uint32(24).uint32(message.previousTransactionVout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputWithPreviousTransactionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputWithPreviousTransactionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.output = TokenOutput.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.previousTransactionHash = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.previousTransactionVout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputWithPreviousTransactionData {
    return {
      output: isSet(object.output) ? TokenOutput.fromJSON(object.output) : undefined,
      previousTransactionHash: isSet(object.previousTransactionHash)
        ? bytesFromBase64(object.previousTransactionHash)
        : new Uint8Array(0),
      previousTransactionVout: isSet(object.previousTransactionVout)
        ? globalThis.Number(object.previousTransactionVout)
        : 0,
    };
  },

  toJSON(message: OutputWithPreviousTransactionData): unknown {
    const obj: any = {};
    if (message.output !== undefined) {
      obj.output = TokenOutput.toJSON(message.output);
    }
    if (message.previousTransactionHash.length !== 0) {
      obj.previousTransactionHash = base64FromBytes(message.previousTransactionHash);
    }
    if (message.previousTransactionVout !== 0) {
      obj.previousTransactionVout = Math.round(message.previousTransactionVout);
    }
    return obj;
  },

  create(base?: DeepPartial<OutputWithPreviousTransactionData>): OutputWithPreviousTransactionData {
    return OutputWithPreviousTransactionData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutputWithPreviousTransactionData>): OutputWithPreviousTransactionData {
    const message = createBaseOutputWithPreviousTransactionData();
    message.output = (object.output !== undefined && object.output !== null)
      ? TokenOutput.fromPartial(object.output)
      : undefined;
    message.previousTransactionHash = object.previousTransactionHash ?? new Uint8Array(0);
    message.previousTransactionVout = object.previousTransactionVout ?? 0;
    return message;
  },
};

function createBaseQueryTokenOutputsResponse(): QueryTokenOutputsResponse {
  return { outputsWithPreviousTransactionData: [] };
}

export const QueryTokenOutputsResponse: MessageFns<QueryTokenOutputsResponse> = {
  encode(message: QueryTokenOutputsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.outputsWithPreviousTransactionData) {
      OutputWithPreviousTransactionData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTokenOutputsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTokenOutputsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputsWithPreviousTransactionData.push(
            OutputWithPreviousTransactionData.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTokenOutputsResponse {
    return {
      outputsWithPreviousTransactionData: globalThis.Array.isArray(object?.outputsWithPreviousTransactionData)
        ? object.outputsWithPreviousTransactionData.map((e: any) => OutputWithPreviousTransactionData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryTokenOutputsResponse): unknown {
    const obj: any = {};
    if (message.outputsWithPreviousTransactionData?.length) {
      obj.outputsWithPreviousTransactionData = message.outputsWithPreviousTransactionData.map((e) =>
        OutputWithPreviousTransactionData.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTokenOutputsResponse>): QueryTokenOutputsResponse {
    return QueryTokenOutputsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTokenOutputsResponse>): QueryTokenOutputsResponse {
    const message = createBaseQueryTokenOutputsResponse();
    message.outputsWithPreviousTransactionData =
      object.outputsWithPreviousTransactionData?.map((e) => OutputWithPreviousTransactionData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTreeNode(): TreeNode {
  return {
    id: "",
    treeId: "",
    value: 0,
    parentNodeId: undefined,
    nodeTx: new Uint8Array(0),
    refundTx: new Uint8Array(0),
    vout: 0,
    verifyingPublicKey: new Uint8Array(0),
    ownerIdentityPublicKey: new Uint8Array(0),
    signingKeyshare: undefined,
    status: "",
    network: 0,
    createdTime: undefined,
    updatedTime: undefined,
    ownerSigningPublicKey: new Uint8Array(0),
    directTx: new Uint8Array(0),
    directRefundTx: new Uint8Array(0),
    directFromCpfpRefundTx: new Uint8Array(0),
  };
}

export const TreeNode: MessageFns<TreeNode> = {
  encode(message: TreeNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.treeId !== "") {
      writer.uint32(18).string(message.treeId);
    }
    if (message.value !== 0) {
      writer.uint32(24).uint64(message.value);
    }
    if (message.parentNodeId !== undefined) {
      writer.uint32(34).string(message.parentNodeId);
    }
    if (message.nodeTx.length !== 0) {
      writer.uint32(42).bytes(message.nodeTx);
    }
    if (message.refundTx.length !== 0) {
      writer.uint32(50).bytes(message.refundTx);
    }
    if (message.vout !== 0) {
      writer.uint32(56).uint32(message.vout);
    }
    if (message.verifyingPublicKey.length !== 0) {
      writer.uint32(66).bytes(message.verifyingPublicKey);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(74).bytes(message.ownerIdentityPublicKey);
    }
    if (message.signingKeyshare !== undefined) {
      SigningKeyshare.encode(message.signingKeyshare, writer.uint32(82).fork()).join();
    }
    if (message.status !== "") {
      writer.uint32(90).string(message.status);
    }
    if (message.network !== 0) {
      writer.uint32(96).int32(message.network);
    }
    if (message.createdTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createdTime), writer.uint32(106).fork()).join();
    }
    if (message.updatedTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedTime), writer.uint32(114).fork()).join();
    }
    if (message.ownerSigningPublicKey.length !== 0) {
      writer.uint32(122).bytes(message.ownerSigningPublicKey);
    }
    if (message.directTx.length !== 0) {
      writer.uint32(130).bytes(message.directTx);
    }
    if (message.directRefundTx.length !== 0) {
      writer.uint32(138).bytes(message.directRefundTx);
    }
    if (message.directFromCpfpRefundTx.length !== 0) {
      writer.uint32(146).bytes(message.directFromCpfpRefundTx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreeNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreeNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.treeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.value = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parentNodeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nodeTx = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.refundTx = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.verifyingPublicKey = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.signingKeyshare = SigningKeyshare.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.ownerSigningPublicKey = reader.bytes();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.directTx = reader.bytes();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.directRefundTx = reader.bytes();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.directFromCpfpRefundTx = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreeNode {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      treeId: isSet(object.treeId) ? globalThis.String(object.treeId) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      parentNodeId: isSet(object.parentNodeId) ? globalThis.String(object.parentNodeId) : undefined,
      nodeTx: isSet(object.nodeTx) ? bytesFromBase64(object.nodeTx) : new Uint8Array(0),
      refundTx: isSet(object.refundTx) ? bytesFromBase64(object.refundTx) : new Uint8Array(0),
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
      verifyingPublicKey: isSet(object.verifyingPublicKey)
        ? bytesFromBase64(object.verifyingPublicKey)
        : new Uint8Array(0),
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      signingKeyshare: isSet(object.signingKeyshare) ? SigningKeyshare.fromJSON(object.signingKeyshare) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
      createdTime: isSet(object.createdTime) ? fromJsonTimestamp(object.createdTime) : undefined,
      updatedTime: isSet(object.updatedTime) ? fromJsonTimestamp(object.updatedTime) : undefined,
      ownerSigningPublicKey: isSet(object.ownerSigningPublicKey)
        ? bytesFromBase64(object.ownerSigningPublicKey)
        : new Uint8Array(0),
      directTx: isSet(object.directTx) ? bytesFromBase64(object.directTx) : new Uint8Array(0),
      directRefundTx: isSet(object.directRefundTx) ? bytesFromBase64(object.directRefundTx) : new Uint8Array(0),
      directFromCpfpRefundTx: isSet(object.directFromCpfpRefundTx)
        ? bytesFromBase64(object.directFromCpfpRefundTx)
        : new Uint8Array(0),
    };
  },

  toJSON(message: TreeNode): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.treeId !== "") {
      obj.treeId = message.treeId;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.parentNodeId !== undefined) {
      obj.parentNodeId = message.parentNodeId;
    }
    if (message.nodeTx.length !== 0) {
      obj.nodeTx = base64FromBytes(message.nodeTx);
    }
    if (message.refundTx.length !== 0) {
      obj.refundTx = base64FromBytes(message.refundTx);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    if (message.verifyingPublicKey.length !== 0) {
      obj.verifyingPublicKey = base64FromBytes(message.verifyingPublicKey);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.signingKeyshare !== undefined) {
      obj.signingKeyshare = SigningKeyshare.toJSON(message.signingKeyshare);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    if (message.createdTime !== undefined) {
      obj.createdTime = message.createdTime.toISOString();
    }
    if (message.updatedTime !== undefined) {
      obj.updatedTime = message.updatedTime.toISOString();
    }
    if (message.ownerSigningPublicKey.length !== 0) {
      obj.ownerSigningPublicKey = base64FromBytes(message.ownerSigningPublicKey);
    }
    if (message.directTx.length !== 0) {
      obj.directTx = base64FromBytes(message.directTx);
    }
    if (message.directRefundTx.length !== 0) {
      obj.directRefundTx = base64FromBytes(message.directRefundTx);
    }
    if (message.directFromCpfpRefundTx.length !== 0) {
      obj.directFromCpfpRefundTx = base64FromBytes(message.directFromCpfpRefundTx);
    }
    return obj;
  },

  create(base?: DeepPartial<TreeNode>): TreeNode {
    return TreeNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TreeNode>): TreeNode {
    const message = createBaseTreeNode();
    message.id = object.id ?? "";
    message.treeId = object.treeId ?? "";
    message.value = object.value ?? 0;
    message.parentNodeId = object.parentNodeId ?? undefined;
    message.nodeTx = object.nodeTx ?? new Uint8Array(0);
    message.refundTx = object.refundTx ?? new Uint8Array(0);
    message.vout = object.vout ?? 0;
    message.verifyingPublicKey = object.verifyingPublicKey ?? new Uint8Array(0);
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.signingKeyshare = (object.signingKeyshare !== undefined && object.signingKeyshare !== null)
      ? SigningKeyshare.fromPartial(object.signingKeyshare)
      : undefined;
    message.status = object.status ?? "";
    message.network = object.network ?? 0;
    message.createdTime = object.createdTime ?? undefined;
    message.updatedTime = object.updatedTime ?? undefined;
    message.ownerSigningPublicKey = object.ownerSigningPublicKey ?? new Uint8Array(0);
    message.directTx = object.directTx ?? new Uint8Array(0);
    message.directRefundTx = object.directRefundTx ?? new Uint8Array(0);
    message.directFromCpfpRefundTx = object.directFromCpfpRefundTx ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFinalizeNodeSignaturesRequest(): FinalizeNodeSignaturesRequest {
  return { intent: 0, nodeSignatures: [] };
}

export const FinalizeNodeSignaturesRequest: MessageFns<FinalizeNodeSignaturesRequest> = {
  encode(message: FinalizeNodeSignaturesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intent !== 0) {
      writer.uint32(8).int32(message.intent);
    }
    for (const v of message.nodeSignatures) {
      NodeSignatures.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeNodeSignaturesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeNodeSignaturesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.intent = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeSignatures.push(NodeSignatures.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeNodeSignaturesRequest {
    return {
      intent: isSet(object.intent) ? signatureIntentFromJSON(object.intent) : 0,
      nodeSignatures: globalThis.Array.isArray(object?.nodeSignatures)
        ? object.nodeSignatures.map((e: any) => NodeSignatures.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FinalizeNodeSignaturesRequest): unknown {
    const obj: any = {};
    if (message.intent !== 0) {
      obj.intent = signatureIntentToJSON(message.intent);
    }
    if (message.nodeSignatures?.length) {
      obj.nodeSignatures = message.nodeSignatures.map((e) => NodeSignatures.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeNodeSignaturesRequest>): FinalizeNodeSignaturesRequest {
    return FinalizeNodeSignaturesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeNodeSignaturesRequest>): FinalizeNodeSignaturesRequest {
    const message = createBaseFinalizeNodeSignaturesRequest();
    message.intent = object.intent ?? 0;
    message.nodeSignatures = object.nodeSignatures?.map((e) => NodeSignatures.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinalizeNodeSignaturesResponse(): FinalizeNodeSignaturesResponse {
  return { nodes: [] };
}

export const FinalizeNodeSignaturesResponse: MessageFns<FinalizeNodeSignaturesResponse> = {
  encode(message: FinalizeNodeSignaturesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      TreeNode.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeNodeSignaturesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeNodeSignaturesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(TreeNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeNodeSignaturesResponse {
    return { nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => TreeNode.fromJSON(e)) : [] };
  },

  toJSON(message: FinalizeNodeSignaturesResponse): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => TreeNode.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeNodeSignaturesResponse>): FinalizeNodeSignaturesResponse {
    return FinalizeNodeSignaturesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeNodeSignaturesResponse>): FinalizeNodeSignaturesResponse {
    const message = createBaseFinalizeNodeSignaturesResponse();
    message.nodes = object.nodes?.map((e) => TreeNode.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSecretShare(): SecretShare {
  return { secretShare: new Uint8Array(0), proofs: [] };
}

export const SecretShare: MessageFns<SecretShare> = {
  encode(message: SecretShare, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secretShare.length !== 0) {
      writer.uint32(10).bytes(message.secretShare);
    }
    for (const v of message.proofs) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretShare {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretShare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.secretShare = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proofs.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretShare {
    return {
      secretShare: isSet(object.secretShare) ? bytesFromBase64(object.secretShare) : new Uint8Array(0),
      proofs: globalThis.Array.isArray(object?.proofs) ? object.proofs.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: SecretShare): unknown {
    const obj: any = {};
    if (message.secretShare.length !== 0) {
      obj.secretShare = base64FromBytes(message.secretShare);
    }
    if (message.proofs?.length) {
      obj.proofs = message.proofs.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SecretShare>): SecretShare {
    return SecretShare.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SecretShare>): SecretShare {
    const message = createBaseSecretShare();
    message.secretShare = object.secretShare ?? new Uint8Array(0);
    message.proofs = object.proofs?.map((e) => e) || [];
    return message;
  },
};

function createBaseSecretProof(): SecretProof {
  return { proofs: [] };
}

export const SecretProof: MessageFns<SecretProof> = {
  encode(message: SecretProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.proofs) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proofs.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretProof {
    return {
      proofs: globalThis.Array.isArray(object?.proofs) ? object.proofs.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: SecretProof): unknown {
    const obj: any = {};
    if (message.proofs?.length) {
      obj.proofs = message.proofs.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SecretProof>): SecretProof {
    return SecretProof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SecretProof>): SecretProof {
    const message = createBaseSecretProof();
    message.proofs = object.proofs?.map((e) => e) || [];
    return message;
  },
};

function createBaseLeafRefundTxSigningJob(): LeafRefundTxSigningJob {
  return {
    leafId: "",
    refundTxSigningJob: undefined,
    directRefundTxSigningJob: undefined,
    directFromCpfpRefundTxSigningJob: undefined,
  };
}

export const LeafRefundTxSigningJob: MessageFns<LeafRefundTxSigningJob> = {
  encode(message: LeafRefundTxSigningJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.refundTxSigningJob !== undefined) {
      SigningJob.encode(message.refundTxSigningJob, writer.uint32(18).fork()).join();
    }
    if (message.directRefundTxSigningJob !== undefined) {
      SigningJob.encode(message.directRefundTxSigningJob, writer.uint32(26).fork()).join();
    }
    if (message.directFromCpfpRefundTxSigningJob !== undefined) {
      SigningJob.encode(message.directFromCpfpRefundTxSigningJob, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeafRefundTxSigningJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeafRefundTxSigningJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.directRefundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.directFromCpfpRefundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeafRefundTxSigningJob {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      refundTxSigningJob: isSet(object.refundTxSigningJob) ? SigningJob.fromJSON(object.refundTxSigningJob) : undefined,
      directRefundTxSigningJob: isSet(object.directRefundTxSigningJob)
        ? SigningJob.fromJSON(object.directRefundTxSigningJob)
        : undefined,
      directFromCpfpRefundTxSigningJob: isSet(object.directFromCpfpRefundTxSigningJob)
        ? SigningJob.fromJSON(object.directFromCpfpRefundTxSigningJob)
        : undefined,
    };
  },

  toJSON(message: LeafRefundTxSigningJob): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
    }
    if (message.directRefundTxSigningJob !== undefined) {
      obj.directRefundTxSigningJob = SigningJob.toJSON(message.directRefundTxSigningJob);
    }
    if (message.directFromCpfpRefundTxSigningJob !== undefined) {
      obj.directFromCpfpRefundTxSigningJob = SigningJob.toJSON(message.directFromCpfpRefundTxSigningJob);
    }
    return obj;
  },

  create(base?: DeepPartial<LeafRefundTxSigningJob>): LeafRefundTxSigningJob {
    return LeafRefundTxSigningJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LeafRefundTxSigningJob>): LeafRefundTxSigningJob {
    const message = createBaseLeafRefundTxSigningJob();
    message.leafId = object.leafId ?? "";
    message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
      ? SigningJob.fromPartial(object.refundTxSigningJob)
      : undefined;
    message.directRefundTxSigningJob =
      (object.directRefundTxSigningJob !== undefined && object.directRefundTxSigningJob !== null)
        ? SigningJob.fromPartial(object.directRefundTxSigningJob)
        : undefined;
    message.directFromCpfpRefundTxSigningJob =
      (object.directFromCpfpRefundTxSigningJob !== undefined && object.directFromCpfpRefundTxSigningJob !== null)
        ? SigningJob.fromPartial(object.directFromCpfpRefundTxSigningJob)
        : undefined;
    return message;
  },
};

function createBaseUserSignedTxSigningJob(): UserSignedTxSigningJob {
  return {
    leafId: "",
    signingPublicKey: new Uint8Array(0),
    rawTx: new Uint8Array(0),
    signingNonceCommitment: undefined,
    userSignature: new Uint8Array(0),
    signingCommitments: undefined,
  };
}

export const UserSignedTxSigningJob: MessageFns<UserSignedTxSigningJob> = {
  encode(message: UserSignedTxSigningJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.signingPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.signingPublicKey);
    }
    if (message.rawTx.length !== 0) {
      writer.uint32(26).bytes(message.rawTx);
    }
    if (message.signingNonceCommitment !== undefined) {
      SigningCommitment.encode(message.signingNonceCommitment, writer.uint32(34).fork()).join();
    }
    if (message.userSignature.length !== 0) {
      writer.uint32(42).bytes(message.userSignature);
    }
    if (message.signingCommitments !== undefined) {
      SigningCommitments.encode(message.signingCommitments, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSignedTxSigningJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSignedTxSigningJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rawTx = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signingNonceCommitment = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userSignature = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.signingCommitments = SigningCommitments.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSignedTxSigningJob {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      signingPublicKey: isSet(object.signingPublicKey) ? bytesFromBase64(object.signingPublicKey) : new Uint8Array(0),
      rawTx: isSet(object.rawTx) ? bytesFromBase64(object.rawTx) : new Uint8Array(0),
      signingNonceCommitment: isSet(object.signingNonceCommitment)
        ? SigningCommitment.fromJSON(object.signingNonceCommitment)
        : undefined,
      userSignature: isSet(object.userSignature) ? bytesFromBase64(object.userSignature) : new Uint8Array(0),
      signingCommitments: isSet(object.signingCommitments)
        ? SigningCommitments.fromJSON(object.signingCommitments)
        : undefined,
    };
  },

  toJSON(message: UserSignedTxSigningJob): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.signingPublicKey.length !== 0) {
      obj.signingPublicKey = base64FromBytes(message.signingPublicKey);
    }
    if (message.rawTx.length !== 0) {
      obj.rawTx = base64FromBytes(message.rawTx);
    }
    if (message.signingNonceCommitment !== undefined) {
      obj.signingNonceCommitment = SigningCommitment.toJSON(message.signingNonceCommitment);
    }
    if (message.userSignature.length !== 0) {
      obj.userSignature = base64FromBytes(message.userSignature);
    }
    if (message.signingCommitments !== undefined) {
      obj.signingCommitments = SigningCommitments.toJSON(message.signingCommitments);
    }
    return obj;
  },

  create(base?: DeepPartial<UserSignedTxSigningJob>): UserSignedTxSigningJob {
    return UserSignedTxSigningJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserSignedTxSigningJob>): UserSignedTxSigningJob {
    const message = createBaseUserSignedTxSigningJob();
    message.leafId = object.leafId ?? "";
    message.signingPublicKey = object.signingPublicKey ?? new Uint8Array(0);
    message.rawTx = object.rawTx ?? new Uint8Array(0);
    message.signingNonceCommitment =
      (object.signingNonceCommitment !== undefined && object.signingNonceCommitment !== null)
        ? SigningCommitment.fromPartial(object.signingNonceCommitment)
        : undefined;
    message.userSignature = object.userSignature ?? new Uint8Array(0);
    message.signingCommitments = (object.signingCommitments !== undefined && object.signingCommitments !== null)
      ? SigningCommitments.fromPartial(object.signingCommitments)
      : undefined;
    return message;
  },
};

function createBaseLeafRefundTxSigningResult(): LeafRefundTxSigningResult {
  return {
    leafId: "",
    refundTxSigningResult: undefined,
    verifyingKey: new Uint8Array(0),
    directRefundTxSigningResult: undefined,
    directFromCpfpRefundTxSigningResult: undefined,
  };
}

export const LeafRefundTxSigningResult: MessageFns<LeafRefundTxSigningResult> = {
  encode(message: LeafRefundTxSigningResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.refundTxSigningResult !== undefined) {
      SigningResult.encode(message.refundTxSigningResult, writer.uint32(18).fork()).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(26).bytes(message.verifyingKey);
    }
    if (message.directRefundTxSigningResult !== undefined) {
      SigningResult.encode(message.directRefundTxSigningResult, writer.uint32(34).fork()).join();
    }
    if (message.directFromCpfpRefundTxSigningResult !== undefined) {
      SigningResult.encode(message.directFromCpfpRefundTxSigningResult, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeafRefundTxSigningResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeafRefundTxSigningResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.directRefundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.directFromCpfpRefundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeafRefundTxSigningResult {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      refundTxSigningResult: isSet(object.refundTxSigningResult)
        ? SigningResult.fromJSON(object.refundTxSigningResult)
        : undefined,
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
      directRefundTxSigningResult: isSet(object.directRefundTxSigningResult)
        ? SigningResult.fromJSON(object.directRefundTxSigningResult)
        : undefined,
      directFromCpfpRefundTxSigningResult: isSet(object.directFromCpfpRefundTxSigningResult)
        ? SigningResult.fromJSON(object.directFromCpfpRefundTxSigningResult)
        : undefined,
    };
  },

  toJSON(message: LeafRefundTxSigningResult): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.refundTxSigningResult !== undefined) {
      obj.refundTxSigningResult = SigningResult.toJSON(message.refundTxSigningResult);
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    if (message.directRefundTxSigningResult !== undefined) {
      obj.directRefundTxSigningResult = SigningResult.toJSON(message.directRefundTxSigningResult);
    }
    if (message.directFromCpfpRefundTxSigningResult !== undefined) {
      obj.directFromCpfpRefundTxSigningResult = SigningResult.toJSON(message.directFromCpfpRefundTxSigningResult);
    }
    return obj;
  },

  create(base?: DeepPartial<LeafRefundTxSigningResult>): LeafRefundTxSigningResult {
    return LeafRefundTxSigningResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LeafRefundTxSigningResult>): LeafRefundTxSigningResult {
    const message = createBaseLeafRefundTxSigningResult();
    message.leafId = object.leafId ?? "";
    message.refundTxSigningResult =
      (object.refundTxSigningResult !== undefined && object.refundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.refundTxSigningResult)
        : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    message.directRefundTxSigningResult =
      (object.directRefundTxSigningResult !== undefined && object.directRefundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.directRefundTxSigningResult)
        : undefined;
    message.directFromCpfpRefundTxSigningResult =
      (object.directFromCpfpRefundTxSigningResult !== undefined && object.directFromCpfpRefundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.directFromCpfpRefundTxSigningResult)
        : undefined;
    return message;
  },
};

function createBaseStartUserSignedTransferRequest(): StartUserSignedTransferRequest {
  return {
    transferId: "",
    ownerIdentityPublicKey: new Uint8Array(0),
    leavesToSend: [],
    receiverIdentityPublicKey: new Uint8Array(0),
    expiryTime: undefined,
    directLeavesToSend: [],
    directFromCpfpLeavesToSend: [],
  };
}

export const StartUserSignedTransferRequest: MessageFns<StartUserSignedTransferRequest> = {
  encode(message: StartUserSignedTransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.leavesToSend) {
      UserSignedTxSigningJob.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.receiverIdentityPublicKey);
    }
    if (message.expiryTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expiryTime), writer.uint32(42).fork()).join();
    }
    for (const v of message.directLeavesToSend) {
      UserSignedTxSigningJob.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.directFromCpfpLeavesToSend) {
      UserSignedTxSigningJob.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartUserSignedTransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartUserSignedTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.leavesToSend.push(UserSignedTxSigningJob.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.receiverIdentityPublicKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.expiryTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.directLeavesToSend.push(UserSignedTxSigningJob.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.directFromCpfpLeavesToSend.push(UserSignedTxSigningJob.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartUserSignedTransferRequest {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      leavesToSend: globalThis.Array.isArray(object?.leavesToSend)
        ? object.leavesToSend.map((e: any) => UserSignedTxSigningJob.fromJSON(e))
        : [],
      receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
        ? bytesFromBase64(object.receiverIdentityPublicKey)
        : new Uint8Array(0),
      expiryTime: isSet(object.expiryTime) ? fromJsonTimestamp(object.expiryTime) : undefined,
      directLeavesToSend: globalThis.Array.isArray(object?.directLeavesToSend)
        ? object.directLeavesToSend.map((e: any) => UserSignedTxSigningJob.fromJSON(e))
        : [],
      directFromCpfpLeavesToSend: globalThis.Array.isArray(object?.directFromCpfpLeavesToSend)
        ? object.directFromCpfpLeavesToSend.map((e: any) => UserSignedTxSigningJob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StartUserSignedTransferRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.leavesToSend?.length) {
      obj.leavesToSend = message.leavesToSend.map((e) => UserSignedTxSigningJob.toJSON(e));
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      obj.receiverIdentityPublicKey = base64FromBytes(message.receiverIdentityPublicKey);
    }
    if (message.expiryTime !== undefined) {
      obj.expiryTime = message.expiryTime.toISOString();
    }
    if (message.directLeavesToSend?.length) {
      obj.directLeavesToSend = message.directLeavesToSend.map((e) => UserSignedTxSigningJob.toJSON(e));
    }
    if (message.directFromCpfpLeavesToSend?.length) {
      obj.directFromCpfpLeavesToSend = message.directFromCpfpLeavesToSend.map((e) => UserSignedTxSigningJob.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StartUserSignedTransferRequest>): StartUserSignedTransferRequest {
    return StartUserSignedTransferRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartUserSignedTransferRequest>): StartUserSignedTransferRequest {
    const message = createBaseStartUserSignedTransferRequest();
    message.transferId = object.transferId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.leavesToSend = object.leavesToSend?.map((e) => UserSignedTxSigningJob.fromPartial(e)) || [];
    message.receiverIdentityPublicKey = object.receiverIdentityPublicKey ?? new Uint8Array(0);
    message.expiryTime = object.expiryTime ?? undefined;
    message.directLeavesToSend = object.directLeavesToSend?.map((e) => UserSignedTxSigningJob.fromPartial(e)) || [];
    message.directFromCpfpLeavesToSend =
      object.directFromCpfpLeavesToSend?.map((e) => UserSignedTxSigningJob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStartTransferRequest(): StartTransferRequest {
  return {
    transferId: "",
    ownerIdentityPublicKey: new Uint8Array(0),
    leavesToSend: [],
    receiverIdentityPublicKey: new Uint8Array(0),
    expiryTime: undefined,
    transferPackage: undefined,
    sparkInvoice: "",
  };
}

export const StartTransferRequest: MessageFns<StartTransferRequest> = {
  encode(message: StartTransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.leavesToSend) {
      LeafRefundTxSigningJob.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.receiverIdentityPublicKey);
    }
    if (message.expiryTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expiryTime), writer.uint32(42).fork()).join();
    }
    if (message.transferPackage !== undefined) {
      TransferPackage.encode(message.transferPackage, writer.uint32(58).fork()).join();
    }
    if (message.sparkInvoice !== "") {
      writer.uint32(82).string(message.sparkInvoice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.leavesToSend.push(LeafRefundTxSigningJob.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.receiverIdentityPublicKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.expiryTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.transferPackage = TransferPackage.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.sparkInvoice = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTransferRequest {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      leavesToSend: globalThis.Array.isArray(object?.leavesToSend)
        ? object.leavesToSend.map((e: any) => LeafRefundTxSigningJob.fromJSON(e))
        : [],
      receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
        ? bytesFromBase64(object.receiverIdentityPublicKey)
        : new Uint8Array(0),
      expiryTime: isSet(object.expiryTime) ? fromJsonTimestamp(object.expiryTime) : undefined,
      transferPackage: isSet(object.transferPackage) ? TransferPackage.fromJSON(object.transferPackage) : undefined,
      sparkInvoice: isSet(object.sparkInvoice) ? globalThis.String(object.sparkInvoice) : "",
    };
  },

  toJSON(message: StartTransferRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.leavesToSend?.length) {
      obj.leavesToSend = message.leavesToSend.map((e) => LeafRefundTxSigningJob.toJSON(e));
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      obj.receiverIdentityPublicKey = base64FromBytes(message.receiverIdentityPublicKey);
    }
    if (message.expiryTime !== undefined) {
      obj.expiryTime = message.expiryTime.toISOString();
    }
    if (message.transferPackage !== undefined) {
      obj.transferPackage = TransferPackage.toJSON(message.transferPackage);
    }
    if (message.sparkInvoice !== "") {
      obj.sparkInvoice = message.sparkInvoice;
    }
    return obj;
  },

  create(base?: DeepPartial<StartTransferRequest>): StartTransferRequest {
    return StartTransferRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTransferRequest>): StartTransferRequest {
    const message = createBaseStartTransferRequest();
    message.transferId = object.transferId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.leavesToSend = object.leavesToSend?.map((e) => LeafRefundTxSigningJob.fromPartial(e)) || [];
    message.receiverIdentityPublicKey = object.receiverIdentityPublicKey ?? new Uint8Array(0);
    message.expiryTime = object.expiryTime ?? undefined;
    message.transferPackage = (object.transferPackage !== undefined && object.transferPackage !== null)
      ? TransferPackage.fromPartial(object.transferPackage)
      : undefined;
    message.sparkInvoice = object.sparkInvoice ?? "";
    return message;
  },
};

function createBaseStartTransferResponse(): StartTransferResponse {
  return { transfer: undefined, signingResults: [] };
}

export const StartTransferResponse: MessageFns<StartTransferResponse> = {
  encode(message: StartTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    for (const v of message.signingResults) {
      LeafRefundTxSigningResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingResults.push(LeafRefundTxSigningResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTransferResponse {
    return {
      transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined,
      signingResults: globalThis.Array.isArray(object?.signingResults)
        ? object.signingResults.map((e: any) => LeafRefundTxSigningResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StartTransferResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    if (message.signingResults?.length) {
      obj.signingResults = message.signingResults.map((e) => LeafRefundTxSigningResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StartTransferResponse>): StartTransferResponse {
    return StartTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTransferResponse>): StartTransferResponse {
    const message = createBaseStartTransferResponse();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    message.signingResults = object.signingResults?.map((e) => LeafRefundTxSigningResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransferPackage(): TransferPackage {
  return {
    leavesToSend: [],
    keyTweakPackage: {},
    userSignature: new Uint8Array(0),
    directLeavesToSend: [],
    directFromCpfpLeavesToSend: [],
  };
}

export const TransferPackage: MessageFns<TransferPackage> = {
  encode(message: TransferPackage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.leavesToSend) {
      UserSignedTxSigningJob.encode(v!, writer.uint32(10).fork()).join();
    }
    Object.entries(message.keyTweakPackage).forEach(([key, value]) => {
      TransferPackage_KeyTweakPackageEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.userSignature.length !== 0) {
      writer.uint32(26).bytes(message.userSignature);
    }
    for (const v of message.directLeavesToSend) {
      UserSignedTxSigningJob.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.directFromCpfpLeavesToSend) {
      UserSignedTxSigningJob.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferPackage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferPackage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leavesToSend.push(UserSignedTxSigningJob.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = TransferPackage_KeyTweakPackageEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.keyTweakPackage[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userSignature = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.directLeavesToSend.push(UserSignedTxSigningJob.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.directFromCpfpLeavesToSend.push(UserSignedTxSigningJob.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferPackage {
    return {
      leavesToSend: globalThis.Array.isArray(object?.leavesToSend)
        ? object.leavesToSend.map((e: any) => UserSignedTxSigningJob.fromJSON(e))
        : [],
      keyTweakPackage: isObject(object.keyTweakPackage)
        ? Object.entries(object.keyTweakPackage).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      userSignature: isSet(object.userSignature) ? bytesFromBase64(object.userSignature) : new Uint8Array(0),
      directLeavesToSend: globalThis.Array.isArray(object?.directLeavesToSend)
        ? object.directLeavesToSend.map((e: any) => UserSignedTxSigningJob.fromJSON(e))
        : [],
      directFromCpfpLeavesToSend: globalThis.Array.isArray(object?.directFromCpfpLeavesToSend)
        ? object.directFromCpfpLeavesToSend.map((e: any) => UserSignedTxSigningJob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransferPackage): unknown {
    const obj: any = {};
    if (message.leavesToSend?.length) {
      obj.leavesToSend = message.leavesToSend.map((e) => UserSignedTxSigningJob.toJSON(e));
    }
    if (message.keyTweakPackage) {
      const entries = Object.entries(message.keyTweakPackage);
      if (entries.length > 0) {
        obj.keyTweakPackage = {};
        entries.forEach(([k, v]) => {
          obj.keyTweakPackage[k] = base64FromBytes(v);
        });
      }
    }
    if (message.userSignature.length !== 0) {
      obj.userSignature = base64FromBytes(message.userSignature);
    }
    if (message.directLeavesToSend?.length) {
      obj.directLeavesToSend = message.directLeavesToSend.map((e) => UserSignedTxSigningJob.toJSON(e));
    }
    if (message.directFromCpfpLeavesToSend?.length) {
      obj.directFromCpfpLeavesToSend = message.directFromCpfpLeavesToSend.map((e) => UserSignedTxSigningJob.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TransferPackage>): TransferPackage {
    return TransferPackage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferPackage>): TransferPackage {
    const message = createBaseTransferPackage();
    message.leavesToSend = object.leavesToSend?.map((e) => UserSignedTxSigningJob.fromPartial(e)) || [];
    message.keyTweakPackage = Object.entries(object.keyTweakPackage ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.userSignature = object.userSignature ?? new Uint8Array(0);
    message.directLeavesToSend = object.directLeavesToSend?.map((e) => UserSignedTxSigningJob.fromPartial(e)) || [];
    message.directFromCpfpLeavesToSend =
      object.directFromCpfpLeavesToSend?.map((e) => UserSignedTxSigningJob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransferPackage_KeyTweakPackageEntry(): TransferPackage_KeyTweakPackageEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const TransferPackage_KeyTweakPackageEntry: MessageFns<TransferPackage_KeyTweakPackageEntry> = {
  encode(message: TransferPackage_KeyTweakPackageEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferPackage_KeyTweakPackageEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferPackage_KeyTweakPackageEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferPackage_KeyTweakPackageEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: TransferPackage_KeyTweakPackageEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferPackage_KeyTweakPackageEntry>): TransferPackage_KeyTweakPackageEntry {
    return TransferPackage_KeyTweakPackageEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferPackage_KeyTweakPackageEntry>): TransferPackage_KeyTweakPackageEntry {
    const message = createBaseTransferPackage_KeyTweakPackageEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSendLeafKeyTweaks(): SendLeafKeyTweaks {
  return { leavesToSend: [] };
}

export const SendLeafKeyTweaks: MessageFns<SendLeafKeyTweaks> = {
  encode(message: SendLeafKeyTweaks, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.leavesToSend) {
      SendLeafKeyTweak.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendLeafKeyTweaks {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendLeafKeyTweaks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leavesToSend.push(SendLeafKeyTweak.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendLeafKeyTweaks {
    return {
      leavesToSend: globalThis.Array.isArray(object?.leavesToSend)
        ? object.leavesToSend.map((e: any) => SendLeafKeyTweak.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SendLeafKeyTweaks): unknown {
    const obj: any = {};
    if (message.leavesToSend?.length) {
      obj.leavesToSend = message.leavesToSend.map((e) => SendLeafKeyTweak.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SendLeafKeyTweaks>): SendLeafKeyTweaks {
    return SendLeafKeyTweaks.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendLeafKeyTweaks>): SendLeafKeyTweaks {
    const message = createBaseSendLeafKeyTweaks();
    message.leavesToSend = object.leavesToSend?.map((e) => SendLeafKeyTweak.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSendLeafKeyTweak(): SendLeafKeyTweak {
  return {
    leafId: "",
    secretShareTweak: undefined,
    pubkeySharesTweak: {},
    secretCipher: new Uint8Array(0),
    signature: new Uint8Array(0),
    refundSignature: new Uint8Array(0),
    directRefundSignature: new Uint8Array(0),
    directFromCpfpRefundSignature: new Uint8Array(0),
  };
}

export const SendLeafKeyTweak: MessageFns<SendLeafKeyTweak> = {
  encode(message: SendLeafKeyTweak, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.secretShareTweak !== undefined) {
      SecretShare.encode(message.secretShareTweak, writer.uint32(18).fork()).join();
    }
    Object.entries(message.pubkeySharesTweak).forEach(([key, value]) => {
      SendLeafKeyTweak_PubkeySharesTweakEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.secretCipher.length !== 0) {
      writer.uint32(34).bytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      writer.uint32(42).bytes(message.signature);
    }
    if (message.refundSignature.length !== 0) {
      writer.uint32(50).bytes(message.refundSignature);
    }
    if (message.directRefundSignature.length !== 0) {
      writer.uint32(58).bytes(message.directRefundSignature);
    }
    if (message.directFromCpfpRefundSignature.length !== 0) {
      writer.uint32(66).bytes(message.directFromCpfpRefundSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendLeafKeyTweak {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendLeafKeyTweak();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secretShareTweak = SecretShare.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SendLeafKeyTweak_PubkeySharesTweakEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.pubkeySharesTweak[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.secretCipher = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.refundSignature = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.directRefundSignature = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.directFromCpfpRefundSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendLeafKeyTweak {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      secretShareTweak: isSet(object.secretShareTweak) ? SecretShare.fromJSON(object.secretShareTweak) : undefined,
      pubkeySharesTweak: isObject(object.pubkeySharesTweak)
        ? Object.entries(object.pubkeySharesTweak).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      secretCipher: isSet(object.secretCipher) ? bytesFromBase64(object.secretCipher) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      refundSignature: isSet(object.refundSignature) ? bytesFromBase64(object.refundSignature) : new Uint8Array(0),
      directRefundSignature: isSet(object.directRefundSignature)
        ? bytesFromBase64(object.directRefundSignature)
        : new Uint8Array(0),
      directFromCpfpRefundSignature: isSet(object.directFromCpfpRefundSignature)
        ? bytesFromBase64(object.directFromCpfpRefundSignature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SendLeafKeyTweak): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.secretShareTweak !== undefined) {
      obj.secretShareTweak = SecretShare.toJSON(message.secretShareTweak);
    }
    if (message.pubkeySharesTweak) {
      const entries = Object.entries(message.pubkeySharesTweak);
      if (entries.length > 0) {
        obj.pubkeySharesTweak = {};
        entries.forEach(([k, v]) => {
          obj.pubkeySharesTweak[k] = base64FromBytes(v);
        });
      }
    }
    if (message.secretCipher.length !== 0) {
      obj.secretCipher = base64FromBytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.refundSignature.length !== 0) {
      obj.refundSignature = base64FromBytes(message.refundSignature);
    }
    if (message.directRefundSignature.length !== 0) {
      obj.directRefundSignature = base64FromBytes(message.directRefundSignature);
    }
    if (message.directFromCpfpRefundSignature.length !== 0) {
      obj.directFromCpfpRefundSignature = base64FromBytes(message.directFromCpfpRefundSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<SendLeafKeyTweak>): SendLeafKeyTweak {
    return SendLeafKeyTweak.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendLeafKeyTweak>): SendLeafKeyTweak {
    const message = createBaseSendLeafKeyTweak();
    message.leafId = object.leafId ?? "";
    message.secretShareTweak = (object.secretShareTweak !== undefined && object.secretShareTweak !== null)
      ? SecretShare.fromPartial(object.secretShareTweak)
      : undefined;
    message.pubkeySharesTweak = Object.entries(object.pubkeySharesTweak ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.secretCipher = object.secretCipher ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.refundSignature = object.refundSignature ?? new Uint8Array(0);
    message.directRefundSignature = object.directRefundSignature ?? new Uint8Array(0);
    message.directFromCpfpRefundSignature = object.directFromCpfpRefundSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSendLeafKeyTweak_PubkeySharesTweakEntry(): SendLeafKeyTweak_PubkeySharesTweakEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const SendLeafKeyTweak_PubkeySharesTweakEntry: MessageFns<SendLeafKeyTweak_PubkeySharesTweakEntry> = {
  encode(message: SendLeafKeyTweak_PubkeySharesTweakEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendLeafKeyTweak_PubkeySharesTweakEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendLeafKeyTweak_PubkeySharesTweakEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendLeafKeyTweak_PubkeySharesTweakEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: SendLeafKeyTweak_PubkeySharesTweakEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SendLeafKeyTweak_PubkeySharesTweakEntry>): SendLeafKeyTweak_PubkeySharesTweakEntry {
    return SendLeafKeyTweak_PubkeySharesTweakEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendLeafKeyTweak_PubkeySharesTweakEntry>): SendLeafKeyTweak_PubkeySharesTweakEntry {
    const message = createBaseSendLeafKeyTweak_PubkeySharesTweakEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFinalizeTransferRequest(): FinalizeTransferRequest {
  return { transferId: "", ownerIdentityPublicKey: new Uint8Array(0), leavesToSend: [], sparkPaymentIntent: "" };
}

export const FinalizeTransferRequest: MessageFns<FinalizeTransferRequest> = {
  encode(message: FinalizeTransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.leavesToSend) {
      SendLeafKeyTweak.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.sparkPaymentIntent !== "") {
      writer.uint32(34).string(message.sparkPaymentIntent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeTransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.leavesToSend.push(SendLeafKeyTweak.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sparkPaymentIntent = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeTransferRequest {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      leavesToSend: globalThis.Array.isArray(object?.leavesToSend)
        ? object.leavesToSend.map((e: any) => SendLeafKeyTweak.fromJSON(e))
        : [],
      sparkPaymentIntent: isSet(object.sparkPaymentIntent) ? globalThis.String(object.sparkPaymentIntent) : "",
    };
  },

  toJSON(message: FinalizeTransferRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.leavesToSend?.length) {
      obj.leavesToSend = message.leavesToSend.map((e) => SendLeafKeyTweak.toJSON(e));
    }
    if (message.sparkPaymentIntent !== "") {
      obj.sparkPaymentIntent = message.sparkPaymentIntent;
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeTransferRequest>): FinalizeTransferRequest {
    return FinalizeTransferRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeTransferRequest>): FinalizeTransferRequest {
    const message = createBaseFinalizeTransferRequest();
    message.transferId = object.transferId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.leavesToSend = object.leavesToSend?.map((e) => SendLeafKeyTweak.fromPartial(e)) || [];
    message.sparkPaymentIntent = object.sparkPaymentIntent ?? "";
    return message;
  },
};

function createBaseFinalizeTransferWithTransferPackageRequest(): FinalizeTransferWithTransferPackageRequest {
  return { transferId: "", ownerIdentityPublicKey: new Uint8Array(0), transferPackage: undefined };
}

export const FinalizeTransferWithTransferPackageRequest: MessageFns<FinalizeTransferWithTransferPackageRequest> = {
  encode(message: FinalizeTransferWithTransferPackageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    if (message.transferPackage !== undefined) {
      TransferPackage.encode(message.transferPackage, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeTransferWithTransferPackageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeTransferWithTransferPackageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transferPackage = TransferPackage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeTransferWithTransferPackageRequest {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      transferPackage: isSet(object.transferPackage) ? TransferPackage.fromJSON(object.transferPackage) : undefined,
    };
  },

  toJSON(message: FinalizeTransferWithTransferPackageRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.transferPackage !== undefined) {
      obj.transferPackage = TransferPackage.toJSON(message.transferPackage);
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeTransferWithTransferPackageRequest>): FinalizeTransferWithTransferPackageRequest {
    return FinalizeTransferWithTransferPackageRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FinalizeTransferWithTransferPackageRequest>,
  ): FinalizeTransferWithTransferPackageRequest {
    const message = createBaseFinalizeTransferWithTransferPackageRequest();
    message.transferId = object.transferId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.transferPackage = (object.transferPackage !== undefined && object.transferPackage !== null)
      ? TransferPackage.fromPartial(object.transferPackage)
      : undefined;
    return message;
  },
};

function createBaseFinalizeTransferResponse(): FinalizeTransferResponse {
  return { transfer: undefined };
}

export const FinalizeTransferResponse: MessageFns<FinalizeTransferResponse> = {
  encode(message: FinalizeTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeTransferResponse {
    return { transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined };
  },

  toJSON(message: FinalizeTransferResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeTransferResponse>): FinalizeTransferResponse {
    return FinalizeTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeTransferResponse>): FinalizeTransferResponse {
    const message = createBaseFinalizeTransferResponse();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    return message;
  },
};

function createBaseTransfer(): Transfer {
  return {
    id: "",
    senderIdentityPublicKey: new Uint8Array(0),
    receiverIdentityPublicKey: new Uint8Array(0),
    status: 0,
    totalValue: 0,
    expiryTime: undefined,
    leaves: [],
    createdTime: undefined,
    updatedTime: undefined,
    type: 0,
    sparkInvoice: "",
  };
}

export const Transfer: MessageFns<Transfer> = {
  encode(message: Transfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.senderIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.senderIdentityPublicKey);
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.receiverIdentityPublicKey);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.totalValue !== 0) {
      writer.uint32(40).uint64(message.totalValue);
    }
    if (message.expiryTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expiryTime), writer.uint32(50).fork()).join();
    }
    for (const v of message.leaves) {
      TransferLeaf.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.createdTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createdTime), writer.uint32(66).fork()).join();
    }
    if (message.updatedTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedTime), writer.uint32(74).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(80).int32(message.type);
    }
    if (message.sparkInvoice !== "") {
      writer.uint32(90).string(message.sparkInvoice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.senderIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receiverIdentityPublicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalValue = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expiryTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.leaves.push(TransferLeaf.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.sparkInvoice = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transfer {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      senderIdentityPublicKey: isSet(object.senderIdentityPublicKey)
        ? bytesFromBase64(object.senderIdentityPublicKey)
        : new Uint8Array(0),
      receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
        ? bytesFromBase64(object.receiverIdentityPublicKey)
        : new Uint8Array(0),
      status: isSet(object.status) ? transferStatusFromJSON(object.status) : 0,
      totalValue: isSet(object.totalValue) ? globalThis.Number(object.totalValue) : 0,
      expiryTime: isSet(object.expiryTime) ? fromJsonTimestamp(object.expiryTime) : undefined,
      leaves: globalThis.Array.isArray(object?.leaves) ? object.leaves.map((e: any) => TransferLeaf.fromJSON(e)) : [],
      createdTime: isSet(object.createdTime) ? fromJsonTimestamp(object.createdTime) : undefined,
      updatedTime: isSet(object.updatedTime) ? fromJsonTimestamp(object.updatedTime) : undefined,
      type: isSet(object.type) ? transferTypeFromJSON(object.type) : 0,
      sparkInvoice: isSet(object.sparkInvoice) ? globalThis.String(object.sparkInvoice) : "",
    };
  },

  toJSON(message: Transfer): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.senderIdentityPublicKey.length !== 0) {
      obj.senderIdentityPublicKey = base64FromBytes(message.senderIdentityPublicKey);
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      obj.receiverIdentityPublicKey = base64FromBytes(message.receiverIdentityPublicKey);
    }
    if (message.status !== 0) {
      obj.status = transferStatusToJSON(message.status);
    }
    if (message.totalValue !== 0) {
      obj.totalValue = Math.round(message.totalValue);
    }
    if (message.expiryTime !== undefined) {
      obj.expiryTime = message.expiryTime.toISOString();
    }
    if (message.leaves?.length) {
      obj.leaves = message.leaves.map((e) => TransferLeaf.toJSON(e));
    }
    if (message.createdTime !== undefined) {
      obj.createdTime = message.createdTime.toISOString();
    }
    if (message.updatedTime !== undefined) {
      obj.updatedTime = message.updatedTime.toISOString();
    }
    if (message.type !== 0) {
      obj.type = transferTypeToJSON(message.type);
    }
    if (message.sparkInvoice !== "") {
      obj.sparkInvoice = message.sparkInvoice;
    }
    return obj;
  },

  create(base?: DeepPartial<Transfer>): Transfer {
    return Transfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transfer>): Transfer {
    const message = createBaseTransfer();
    message.id = object.id ?? "";
    message.senderIdentityPublicKey = object.senderIdentityPublicKey ?? new Uint8Array(0);
    message.receiverIdentityPublicKey = object.receiverIdentityPublicKey ?? new Uint8Array(0);
    message.status = object.status ?? 0;
    message.totalValue = object.totalValue ?? 0;
    message.expiryTime = object.expiryTime ?? undefined;
    message.leaves = object.leaves?.map((e) => TransferLeaf.fromPartial(e)) || [];
    message.createdTime = object.createdTime ?? undefined;
    message.updatedTime = object.updatedTime ?? undefined;
    message.type = object.type ?? 0;
    message.sparkInvoice = object.sparkInvoice ?? "";
    return message;
  },
};

function createBaseTransferLeaf(): TransferLeaf {
  return {
    leaf: undefined,
    secretCipher: new Uint8Array(0),
    signature: new Uint8Array(0),
    intermediateRefundTx: new Uint8Array(0),
    intermediateDirectRefundTx: new Uint8Array(0),
    intermediateDirectFromCpfpRefundTx: new Uint8Array(0),
    pendingKeyTweakPublicKey: new Uint8Array(0),
  };
}

export const TransferLeaf: MessageFns<TransferLeaf> = {
  encode(message: TransferLeaf, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leaf !== undefined) {
      TreeNode.encode(message.leaf, writer.uint32(10).fork()).join();
    }
    if (message.secretCipher.length !== 0) {
      writer.uint32(18).bytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    if (message.intermediateRefundTx.length !== 0) {
      writer.uint32(34).bytes(message.intermediateRefundTx);
    }
    if (message.intermediateDirectRefundTx.length !== 0) {
      writer.uint32(42).bytes(message.intermediateDirectRefundTx);
    }
    if (message.intermediateDirectFromCpfpRefundTx.length !== 0) {
      writer.uint32(50).bytes(message.intermediateDirectFromCpfpRefundTx);
    }
    if (message.pendingKeyTweakPublicKey.length !== 0) {
      writer.uint32(58).bytes(message.pendingKeyTweakPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferLeaf {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferLeaf();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leaf = TreeNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secretCipher = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.intermediateRefundTx = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.intermediateDirectRefundTx = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.intermediateDirectFromCpfpRefundTx = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pendingKeyTweakPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferLeaf {
    return {
      leaf: isSet(object.leaf) ? TreeNode.fromJSON(object.leaf) : undefined,
      secretCipher: isSet(object.secretCipher) ? bytesFromBase64(object.secretCipher) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      intermediateRefundTx: isSet(object.intermediateRefundTx)
        ? bytesFromBase64(object.intermediateRefundTx)
        : new Uint8Array(0),
      intermediateDirectRefundTx: isSet(object.intermediateDirectRefundTx)
        ? bytesFromBase64(object.intermediateDirectRefundTx)
        : new Uint8Array(0),
      intermediateDirectFromCpfpRefundTx: isSet(object.intermediateDirectFromCpfpRefundTx)
        ? bytesFromBase64(object.intermediateDirectFromCpfpRefundTx)
        : new Uint8Array(0),
      pendingKeyTweakPublicKey: isSet(object.pendingKeyTweakPublicKey)
        ? bytesFromBase64(object.pendingKeyTweakPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: TransferLeaf): unknown {
    const obj: any = {};
    if (message.leaf !== undefined) {
      obj.leaf = TreeNode.toJSON(message.leaf);
    }
    if (message.secretCipher.length !== 0) {
      obj.secretCipher = base64FromBytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.intermediateRefundTx.length !== 0) {
      obj.intermediateRefundTx = base64FromBytes(message.intermediateRefundTx);
    }
    if (message.intermediateDirectRefundTx.length !== 0) {
      obj.intermediateDirectRefundTx = base64FromBytes(message.intermediateDirectRefundTx);
    }
    if (message.intermediateDirectFromCpfpRefundTx.length !== 0) {
      obj.intermediateDirectFromCpfpRefundTx = base64FromBytes(message.intermediateDirectFromCpfpRefundTx);
    }
    if (message.pendingKeyTweakPublicKey.length !== 0) {
      obj.pendingKeyTweakPublicKey = base64FromBytes(message.pendingKeyTweakPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferLeaf>): TransferLeaf {
    return TransferLeaf.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferLeaf>): TransferLeaf {
    const message = createBaseTransferLeaf();
    message.leaf = (object.leaf !== undefined && object.leaf !== null) ? TreeNode.fromPartial(object.leaf) : undefined;
    message.secretCipher = object.secretCipher ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.intermediateRefundTx = object.intermediateRefundTx ?? new Uint8Array(0);
    message.intermediateDirectRefundTx = object.intermediateDirectRefundTx ?? new Uint8Array(0);
    message.intermediateDirectFromCpfpRefundTx = object.intermediateDirectFromCpfpRefundTx ?? new Uint8Array(0);
    message.pendingKeyTweakPublicKey = object.pendingKeyTweakPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTransferFilter(): TransferFilter {
  return {
    participant: undefined,
    transferIds: [],
    limit: 0,
    offset: 0,
    types: [],
    network: 0,
    statuses: [],
    order: 0,
  };
}

export const TransferFilter: MessageFns<TransferFilter> = {
  encode(message: TransferFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.participant?.$case) {
      case "receiverIdentityPublicKey":
        writer.uint32(10).bytes(message.participant.receiverIdentityPublicKey);
        break;
      case "senderIdentityPublicKey":
        writer.uint32(18).bytes(message.participant.senderIdentityPublicKey);
        break;
      case "senderOrReceiverIdentityPublicKey":
        writer.uint32(482).bytes(message.participant.senderOrReceiverIdentityPublicKey);
        break;
    }
    for (const v of message.transferIds) {
      writer.uint32(26).string(v!);
    }
    if (message.limit !== 0) {
      writer.uint32(320).int64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(400).int64(message.offset);
    }
    writer.uint32(562).fork();
    for (const v of message.types) {
      writer.int32(v);
    }
    writer.join();
    if (message.network !== 0) {
      writer.uint32(32).int32(message.network);
    }
    writer.uint32(642).fork();
    for (const v of message.statuses) {
      writer.int32(v);
    }
    writer.join();
    if (message.order !== 0) {
      writer.uint32(40).int32(message.order);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.participant = { $case: "receiverIdentityPublicKey", receiverIdentityPublicKey: reader.bytes() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.participant = { $case: "senderIdentityPublicKey", senderIdentityPublicKey: reader.bytes() };
          continue;
        }
        case 60: {
          if (tag !== 482) {
            break;
          }

          message.participant = {
            $case: "senderOrReceiverIdentityPublicKey",
            senderOrReceiverIdentityPublicKey: reader.bytes(),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transferIds.push(reader.string());
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }

          message.limit = longToNumber(reader.int64());
          continue;
        }
        case 50: {
          if (tag !== 400) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
        case 70: {
          if (tag === 560) {
            message.types.push(reader.int32() as any);

            continue;
          }

          if (tag === 562) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.types.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
        case 80: {
          if (tag === 640) {
            message.statuses.push(reader.int32() as any);

            continue;
          }

          if (tag === 642) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.statuses.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.order = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferFilter {
    return {
      participant: isSet(object.receiverIdentityPublicKey)
        ? {
          $case: "receiverIdentityPublicKey",
          receiverIdentityPublicKey: bytesFromBase64(object.receiverIdentityPublicKey),
        }
        : isSet(object.senderIdentityPublicKey)
        ? { $case: "senderIdentityPublicKey", senderIdentityPublicKey: bytesFromBase64(object.senderIdentityPublicKey) }
        : isSet(object.senderOrReceiverIdentityPublicKey)
        ? {
          $case: "senderOrReceiverIdentityPublicKey",
          senderOrReceiverIdentityPublicKey: bytesFromBase64(object.senderOrReceiverIdentityPublicKey),
        }
        : undefined,
      transferIds: globalThis.Array.isArray(object?.transferIds)
        ? object.transferIds.map((e: any) => globalThis.String(e))
        : [],
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => transferTypeFromJSON(e)) : [],
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
      statuses: globalThis.Array.isArray(object?.statuses)
        ? object.statuses.map((e: any) => transferStatusFromJSON(e))
        : [],
      order: isSet(object.order) ? orderFromJSON(object.order) : 0,
    };
  },

  toJSON(message: TransferFilter): unknown {
    const obj: any = {};
    if (message.participant?.$case === "receiverIdentityPublicKey") {
      obj.receiverIdentityPublicKey = base64FromBytes(message.participant.receiverIdentityPublicKey);
    } else if (message.participant?.$case === "senderIdentityPublicKey") {
      obj.senderIdentityPublicKey = base64FromBytes(message.participant.senderIdentityPublicKey);
    } else if (message.participant?.$case === "senderOrReceiverIdentityPublicKey") {
      obj.senderOrReceiverIdentityPublicKey = base64FromBytes(message.participant.senderOrReceiverIdentityPublicKey);
    }
    if (message.transferIds?.length) {
      obj.transferIds = message.transferIds;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.types?.length) {
      obj.types = message.types.map((e) => transferTypeToJSON(e));
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => transferStatusToJSON(e));
    }
    if (message.order !== 0) {
      obj.order = orderToJSON(message.order);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferFilter>): TransferFilter {
    return TransferFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferFilter>): TransferFilter {
    const message = createBaseTransferFilter();
    switch (object.participant?.$case) {
      case "receiverIdentityPublicKey": {
        if (
          object.participant?.receiverIdentityPublicKey !== undefined &&
          object.participant?.receiverIdentityPublicKey !== null
        ) {
          message.participant = {
            $case: "receiverIdentityPublicKey",
            receiverIdentityPublicKey: object.participant.receiverIdentityPublicKey,
          };
        }
        break;
      }
      case "senderIdentityPublicKey": {
        if (
          object.participant?.senderIdentityPublicKey !== undefined &&
          object.participant?.senderIdentityPublicKey !== null
        ) {
          message.participant = {
            $case: "senderIdentityPublicKey",
            senderIdentityPublicKey: object.participant.senderIdentityPublicKey,
          };
        }
        break;
      }
      case "senderOrReceiverIdentityPublicKey": {
        if (
          object.participant?.senderOrReceiverIdentityPublicKey !== undefined &&
          object.participant?.senderOrReceiverIdentityPublicKey !== null
        ) {
          message.participant = {
            $case: "senderOrReceiverIdentityPublicKey",
            senderOrReceiverIdentityPublicKey: object.participant.senderOrReceiverIdentityPublicKey,
          };
        }
        break;
      }
    }
    message.transferIds = object.transferIds?.map((e) => e) || [];
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.types = object.types?.map((e) => e) || [];
    message.network = object.network ?? 0;
    message.statuses = object.statuses?.map((e) => e) || [];
    message.order = object.order ?? 0;
    return message;
  },
};

function createBaseQueryTransfersResponse(): QueryTransfersResponse {
  return { transfers: [], offset: 0 };
}

export const QueryTransfersResponse: MessageFns<QueryTransfersResponse> = {
  encode(message: QueryTransfersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transfers) {
      Transfer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.offset !== 0) {
      writer.uint32(16).int64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTransfersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTransfersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfers.push(Transfer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTransfersResponse {
    return {
      transfers: globalThis.Array.isArray(object?.transfers)
        ? object.transfers.map((e: any) => Transfer.fromJSON(e))
        : [],
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: QueryTransfersResponse): unknown {
    const obj: any = {};
    if (message.transfers?.length) {
      obj.transfers = message.transfers.map((e) => Transfer.toJSON(e));
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTransfersResponse>): QueryTransfersResponse {
    return QueryTransfersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTransfersResponse>): QueryTransfersResponse {
    const message = createBaseQueryTransfersResponse();
    message.transfers = object.transfers?.map((e) => Transfer.fromPartial(e)) || [];
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseClaimLeafKeyTweak(): ClaimLeafKeyTweak {
  return { leafId: "", secretShareTweak: undefined, pubkeySharesTweak: {} };
}

export const ClaimLeafKeyTweak: MessageFns<ClaimLeafKeyTweak> = {
  encode(message: ClaimLeafKeyTweak, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.secretShareTweak !== undefined) {
      SecretShare.encode(message.secretShareTweak, writer.uint32(18).fork()).join();
    }
    Object.entries(message.pubkeySharesTweak).forEach(([key, value]) => {
      ClaimLeafKeyTweak_PubkeySharesTweakEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimLeafKeyTweak {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimLeafKeyTweak();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secretShareTweak = SecretShare.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ClaimLeafKeyTweak_PubkeySharesTweakEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.pubkeySharesTweak[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimLeafKeyTweak {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      secretShareTweak: isSet(object.secretShareTweak) ? SecretShare.fromJSON(object.secretShareTweak) : undefined,
      pubkeySharesTweak: isObject(object.pubkeySharesTweak)
        ? Object.entries(object.pubkeySharesTweak).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ClaimLeafKeyTweak): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.secretShareTweak !== undefined) {
      obj.secretShareTweak = SecretShare.toJSON(message.secretShareTweak);
    }
    if (message.pubkeySharesTweak) {
      const entries = Object.entries(message.pubkeySharesTweak);
      if (entries.length > 0) {
        obj.pubkeySharesTweak = {};
        entries.forEach(([k, v]) => {
          obj.pubkeySharesTweak[k] = base64FromBytes(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimLeafKeyTweak>): ClaimLeafKeyTweak {
    return ClaimLeafKeyTweak.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimLeafKeyTweak>): ClaimLeafKeyTweak {
    const message = createBaseClaimLeafKeyTweak();
    message.leafId = object.leafId ?? "";
    message.secretShareTweak = (object.secretShareTweak !== undefined && object.secretShareTweak !== null)
      ? SecretShare.fromPartial(object.secretShareTweak)
      : undefined;
    message.pubkeySharesTweak = Object.entries(object.pubkeySharesTweak ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseClaimLeafKeyTweak_PubkeySharesTweakEntry(): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const ClaimLeafKeyTweak_PubkeySharesTweakEntry: MessageFns<ClaimLeafKeyTweak_PubkeySharesTweakEntry> = {
  encode(message: ClaimLeafKeyTweak_PubkeySharesTweakEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimLeafKeyTweak_PubkeySharesTweakEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: ClaimLeafKeyTweak_PubkeySharesTweakEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimLeafKeyTweak_PubkeySharesTweakEntry>): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
    return ClaimLeafKeyTweak_PubkeySharesTweakEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimLeafKeyTweak_PubkeySharesTweakEntry>): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
    const message = createBaseClaimLeafKeyTweak_PubkeySharesTweakEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseClaimTransferTweakKeysRequest(): ClaimTransferTweakKeysRequest {
  return { transferId: "", ownerIdentityPublicKey: new Uint8Array(0), leavesToReceive: [] };
}

export const ClaimTransferTweakKeysRequest: MessageFns<ClaimTransferTweakKeysRequest> = {
  encode(message: ClaimTransferTweakKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.leavesToReceive) {
      ClaimLeafKeyTweak.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimTransferTweakKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTransferTweakKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.leavesToReceive.push(ClaimLeafKeyTweak.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTransferTweakKeysRequest {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      leavesToReceive: globalThis.Array.isArray(object?.leavesToReceive)
        ? object.leavesToReceive.map((e: any) => ClaimLeafKeyTweak.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClaimTransferTweakKeysRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.leavesToReceive?.length) {
      obj.leavesToReceive = message.leavesToReceive.map((e) => ClaimLeafKeyTweak.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTransferTweakKeysRequest>): ClaimTransferTweakKeysRequest {
    return ClaimTransferTweakKeysRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTransferTweakKeysRequest>): ClaimTransferTweakKeysRequest {
    const message = createBaseClaimTransferTweakKeysRequest();
    message.transferId = object.transferId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.leavesToReceive = object.leavesToReceive?.map((e) => ClaimLeafKeyTweak.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClaimTransferSignRefundsRequest(): ClaimTransferSignRefundsRequest {
  return { transferId: "", ownerIdentityPublicKey: new Uint8Array(0), signingJobs: [] };
}

export const ClaimTransferSignRefundsRequest: MessageFns<ClaimTransferSignRefundsRequest> = {
  encode(message: ClaimTransferSignRefundsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.signingJobs) {
      LeafRefundTxSigningJob.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimTransferSignRefundsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTransferSignRefundsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signingJobs.push(LeafRefundTxSigningJob.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTransferSignRefundsRequest {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      signingJobs: globalThis.Array.isArray(object?.signingJobs)
        ? object.signingJobs.map((e: any) => LeafRefundTxSigningJob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClaimTransferSignRefundsRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.signingJobs?.length) {
      obj.signingJobs = message.signingJobs.map((e) => LeafRefundTxSigningJob.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTransferSignRefundsRequest>): ClaimTransferSignRefundsRequest {
    return ClaimTransferSignRefundsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTransferSignRefundsRequest>): ClaimTransferSignRefundsRequest {
    const message = createBaseClaimTransferSignRefundsRequest();
    message.transferId = object.transferId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.signingJobs = object.signingJobs?.map((e) => LeafRefundTxSigningJob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClaimTransferSignRefundsResponse(): ClaimTransferSignRefundsResponse {
  return { signingResults: [] };
}

export const ClaimTransferSignRefundsResponse: MessageFns<ClaimTransferSignRefundsResponse> = {
  encode(message: ClaimTransferSignRefundsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signingResults) {
      LeafRefundTxSigningResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimTransferSignRefundsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTransferSignRefundsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingResults.push(LeafRefundTxSigningResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTransferSignRefundsResponse {
    return {
      signingResults: globalThis.Array.isArray(object?.signingResults)
        ? object.signingResults.map((e: any) => LeafRefundTxSigningResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClaimTransferSignRefundsResponse): unknown {
    const obj: any = {};
    if (message.signingResults?.length) {
      obj.signingResults = message.signingResults.map((e) => LeafRefundTxSigningResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTransferSignRefundsResponse>): ClaimTransferSignRefundsResponse {
    return ClaimTransferSignRefundsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTransferSignRefundsResponse>): ClaimTransferSignRefundsResponse {
    const message = createBaseClaimTransferSignRefundsResponse();
    message.signingResults = object.signingResults?.map((e) => LeafRefundTxSigningResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStorePreimageShareRequest(): StorePreimageShareRequest {
  return {
    paymentHash: new Uint8Array(0),
    preimageShare: undefined,
    threshold: 0,
    invoiceString: "",
    userIdentityPublicKey: new Uint8Array(0),
  };
}

export const StorePreimageShareRequest: MessageFns<StorePreimageShareRequest> = {
  encode(message: StorePreimageShareRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentHash.length !== 0) {
      writer.uint32(10).bytes(message.paymentHash);
    }
    if (message.preimageShare !== undefined) {
      SecretShare.encode(message.preimageShare, writer.uint32(18).fork()).join();
    }
    if (message.threshold !== 0) {
      writer.uint32(24).uint32(message.threshold);
    }
    if (message.invoiceString !== "") {
      writer.uint32(34).string(message.invoiceString);
    }
    if (message.userIdentityPublicKey.length !== 0) {
      writer.uint32(42).bytes(message.userIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorePreimageShareRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorePreimageShareRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preimageShare = SecretShare.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.threshold = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.invoiceString = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorePreimageShareRequest {
    return {
      paymentHash: isSet(object.paymentHash) ? bytesFromBase64(object.paymentHash) : new Uint8Array(0),
      preimageShare: isSet(object.preimageShare) ? SecretShare.fromJSON(object.preimageShare) : undefined,
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      invoiceString: isSet(object.invoiceString) ? globalThis.String(object.invoiceString) : "",
      userIdentityPublicKey: isSet(object.userIdentityPublicKey)
        ? bytesFromBase64(object.userIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: StorePreimageShareRequest): unknown {
    const obj: any = {};
    if (message.paymentHash.length !== 0) {
      obj.paymentHash = base64FromBytes(message.paymentHash);
    }
    if (message.preimageShare !== undefined) {
      obj.preimageShare = SecretShare.toJSON(message.preimageShare);
    }
    if (message.threshold !== 0) {
      obj.threshold = Math.round(message.threshold);
    }
    if (message.invoiceString !== "") {
      obj.invoiceString = message.invoiceString;
    }
    if (message.userIdentityPublicKey.length !== 0) {
      obj.userIdentityPublicKey = base64FromBytes(message.userIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<StorePreimageShareRequest>): StorePreimageShareRequest {
    return StorePreimageShareRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StorePreimageShareRequest>): StorePreimageShareRequest {
    const message = createBaseStorePreimageShareRequest();
    message.paymentHash = object.paymentHash ?? new Uint8Array(0);
    message.preimageShare = (object.preimageShare !== undefined && object.preimageShare !== null)
      ? SecretShare.fromPartial(object.preimageShare)
      : undefined;
    message.threshold = object.threshold ?? 0;
    message.invoiceString = object.invoiceString ?? "";
    message.userIdentityPublicKey = object.userIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRequestedSigningCommitments(): RequestedSigningCommitments {
  return { signingNonceCommitments: {} };
}

export const RequestedSigningCommitments: MessageFns<RequestedSigningCommitments> = {
  encode(message: RequestedSigningCommitments, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.signingNonceCommitments).forEach(([key, value]) => {
      RequestedSigningCommitments_SigningNonceCommitmentsEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestedSigningCommitments {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestedSigningCommitments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = RequestedSigningCommitments_SigningNonceCommitmentsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.signingNonceCommitments[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestedSigningCommitments {
    return {
      signingNonceCommitments: isObject(object.signingNonceCommitments)
        ? Object.entries(object.signingNonceCommitments).reduce<{ [key: string]: SigningCommitment }>(
          (acc, [key, value]) => {
            acc[key] = SigningCommitment.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: RequestedSigningCommitments): unknown {
    const obj: any = {};
    if (message.signingNonceCommitments) {
      const entries = Object.entries(message.signingNonceCommitments);
      if (entries.length > 0) {
        obj.signingNonceCommitments = {};
        entries.forEach(([k, v]) => {
          obj.signingNonceCommitments[k] = SigningCommitment.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<RequestedSigningCommitments>): RequestedSigningCommitments {
    return RequestedSigningCommitments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestedSigningCommitments>): RequestedSigningCommitments {
    const message = createBaseRequestedSigningCommitments();
    message.signingNonceCommitments = Object.entries(object.signingNonceCommitments ?? {}).reduce<
      { [key: string]: SigningCommitment }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SigningCommitment.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRequestedSigningCommitments_SigningNonceCommitmentsEntry(): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
  return { key: "", value: undefined };
}

export const RequestedSigningCommitments_SigningNonceCommitmentsEntry: MessageFns<
  RequestedSigningCommitments_SigningNonceCommitmentsEntry
> = {
  encode(
    message: RequestedSigningCommitments_SigningNonceCommitmentsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SigningCommitment.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestedSigningCommitments_SigningNonceCommitmentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SigningCommitment.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RequestedSigningCommitments_SigningNonceCommitmentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SigningCommitment.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<RequestedSigningCommitments_SigningNonceCommitmentsEntry>,
  ): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
    return RequestedSigningCommitments_SigningNonceCommitmentsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RequestedSigningCommitments_SigningNonceCommitmentsEntry>,
  ): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
    const message = createBaseRequestedSigningCommitments_SigningNonceCommitmentsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SigningCommitment.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGetSigningCommitmentsRequest(): GetSigningCommitmentsRequest {
  return { nodeIds: [], count: 0 };
}

export const GetSigningCommitmentsRequest: MessageFns<GetSigningCommitmentsRequest> = {
  encode(message: GetSigningCommitmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodeIds) {
      writer.uint32(10).string(v!);
    }
    if (message.count !== 0) {
      writer.uint32(16).uint32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSigningCommitmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSigningCommitmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSigningCommitmentsRequest {
    return {
      nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e: any) => globalThis.String(e)) : [],
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: GetSigningCommitmentsRequest): unknown {
    const obj: any = {};
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<GetSigningCommitmentsRequest>): GetSigningCommitmentsRequest {
    return GetSigningCommitmentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSigningCommitmentsRequest>): GetSigningCommitmentsRequest {
    const message = createBaseGetSigningCommitmentsRequest();
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseGetSigningCommitmentsResponse(): GetSigningCommitmentsResponse {
  return { signingCommitments: [] };
}

export const GetSigningCommitmentsResponse: MessageFns<GetSigningCommitmentsResponse> = {
  encode(message: GetSigningCommitmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signingCommitments) {
      RequestedSigningCommitments.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSigningCommitmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSigningCommitmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingCommitments.push(RequestedSigningCommitments.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSigningCommitmentsResponse {
    return {
      signingCommitments: globalThis.Array.isArray(object?.signingCommitments)
        ? object.signingCommitments.map((e: any) => RequestedSigningCommitments.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetSigningCommitmentsResponse): unknown {
    const obj: any = {};
    if (message.signingCommitments?.length) {
      obj.signingCommitments = message.signingCommitments.map((e) => RequestedSigningCommitments.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetSigningCommitmentsResponse>): GetSigningCommitmentsResponse {
    return GetSigningCommitmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSigningCommitmentsResponse>): GetSigningCommitmentsResponse {
    const message = createBaseGetSigningCommitmentsResponse();
    message.signingCommitments = object.signingCommitments?.map((e) => RequestedSigningCommitments.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseSigningCommitments(): SigningCommitments {
  return { signingCommitments: {} };
}

export const SigningCommitments: MessageFns<SigningCommitments> = {
  encode(message: SigningCommitments, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.signingCommitments).forEach(([key, value]) => {
      SigningCommitments_SigningCommitmentsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningCommitments {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningCommitments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = SigningCommitments_SigningCommitmentsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.signingCommitments[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningCommitments {
    return {
      signingCommitments: isObject(object.signingCommitments)
        ? Object.entries(object.signingCommitments).reduce<{ [key: string]: SigningCommitment }>(
          (acc, [key, value]) => {
            acc[key] = SigningCommitment.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: SigningCommitments): unknown {
    const obj: any = {};
    if (message.signingCommitments) {
      const entries = Object.entries(message.signingCommitments);
      if (entries.length > 0) {
        obj.signingCommitments = {};
        entries.forEach(([k, v]) => {
          obj.signingCommitments[k] = SigningCommitment.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SigningCommitments>): SigningCommitments {
    return SigningCommitments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningCommitments>): SigningCommitments {
    const message = createBaseSigningCommitments();
    message.signingCommitments = Object.entries(object.signingCommitments ?? {}).reduce<
      { [key: string]: SigningCommitment }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SigningCommitment.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSigningCommitments_SigningCommitmentsEntry(): SigningCommitments_SigningCommitmentsEntry {
  return { key: "", value: undefined };
}

export const SigningCommitments_SigningCommitmentsEntry: MessageFns<SigningCommitments_SigningCommitmentsEntry> = {
  encode(message: SigningCommitments_SigningCommitmentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SigningCommitment.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningCommitments_SigningCommitmentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningCommitments_SigningCommitmentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningCommitments_SigningCommitmentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SigningCommitment.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SigningCommitments_SigningCommitmentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SigningCommitment.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningCommitments_SigningCommitmentsEntry>): SigningCommitments_SigningCommitmentsEntry {
    return SigningCommitments_SigningCommitmentsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SigningCommitments_SigningCommitmentsEntry>,
  ): SigningCommitments_SigningCommitmentsEntry {
    const message = createBaseSigningCommitments_SigningCommitmentsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SigningCommitment.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseUserSignedRefund(): UserSignedRefund {
  return {
    nodeId: "",
    refundTx: new Uint8Array(0),
    userSignature: new Uint8Array(0),
    signingCommitments: undefined,
    userSignatureCommitment: undefined,
    network: 0,
  };
}

export const UserSignedRefund: MessageFns<UserSignedRefund> = {
  encode(message: UserSignedRefund, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.refundTx.length !== 0) {
      writer.uint32(18).bytes(message.refundTx);
    }
    if (message.userSignature.length !== 0) {
      writer.uint32(26).bytes(message.userSignature);
    }
    if (message.signingCommitments !== undefined) {
      SigningCommitments.encode(message.signingCommitments, writer.uint32(34).fork()).join();
    }
    if (message.userSignatureCommitment !== undefined) {
      SigningCommitment.encode(message.userSignatureCommitment, writer.uint32(42).fork()).join();
    }
    if (message.network !== 0) {
      writer.uint32(48).int32(message.network);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSignedRefund {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSignedRefund();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundTx = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userSignature = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signingCommitments = SigningCommitments.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userSignatureCommitment = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSignedRefund {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      refundTx: isSet(object.refundTx) ? bytesFromBase64(object.refundTx) : new Uint8Array(0),
      userSignature: isSet(object.userSignature) ? bytesFromBase64(object.userSignature) : new Uint8Array(0),
      signingCommitments: isSet(object.signingCommitments)
        ? SigningCommitments.fromJSON(object.signingCommitments)
        : undefined,
      userSignatureCommitment: isSet(object.userSignatureCommitment)
        ? SigningCommitment.fromJSON(object.userSignatureCommitment)
        : undefined,
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
    };
  },

  toJSON(message: UserSignedRefund): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.refundTx.length !== 0) {
      obj.refundTx = base64FromBytes(message.refundTx);
    }
    if (message.userSignature.length !== 0) {
      obj.userSignature = base64FromBytes(message.userSignature);
    }
    if (message.signingCommitments !== undefined) {
      obj.signingCommitments = SigningCommitments.toJSON(message.signingCommitments);
    }
    if (message.userSignatureCommitment !== undefined) {
      obj.userSignatureCommitment = SigningCommitment.toJSON(message.userSignatureCommitment);
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    return obj;
  },

  create(base?: DeepPartial<UserSignedRefund>): UserSignedRefund {
    return UserSignedRefund.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserSignedRefund>): UserSignedRefund {
    const message = createBaseUserSignedRefund();
    message.nodeId = object.nodeId ?? "";
    message.refundTx = object.refundTx ?? new Uint8Array(0);
    message.userSignature = object.userSignature ?? new Uint8Array(0);
    message.signingCommitments = (object.signingCommitments !== undefined && object.signingCommitments !== null)
      ? SigningCommitments.fromPartial(object.signingCommitments)
      : undefined;
    message.userSignatureCommitment =
      (object.userSignatureCommitment !== undefined && object.userSignatureCommitment !== null)
        ? SigningCommitment.fromPartial(object.userSignatureCommitment)
        : undefined;
    message.network = object.network ?? 0;
    return message;
  },
};

function createBaseInvoiceAmountProof(): InvoiceAmountProof {
  return { bolt11Invoice: "" };
}

export const InvoiceAmountProof: MessageFns<InvoiceAmountProof> = {
  encode(message: InvoiceAmountProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bolt11Invoice !== "") {
      writer.uint32(10).string(message.bolt11Invoice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvoiceAmountProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvoiceAmountProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bolt11Invoice = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvoiceAmountProof {
    return { bolt11Invoice: isSet(object.bolt11Invoice) ? globalThis.String(object.bolt11Invoice) : "" };
  },

  toJSON(message: InvoiceAmountProof): unknown {
    const obj: any = {};
    if (message.bolt11Invoice !== "") {
      obj.bolt11Invoice = message.bolt11Invoice;
    }
    return obj;
  },

  create(base?: DeepPartial<InvoiceAmountProof>): InvoiceAmountProof {
    return InvoiceAmountProof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvoiceAmountProof>): InvoiceAmountProof {
    const message = createBaseInvoiceAmountProof();
    message.bolt11Invoice = object.bolt11Invoice ?? "";
    return message;
  },
};

function createBaseInvoiceAmount(): InvoiceAmount {
  return { valueSats: 0, invoiceAmountProof: undefined };
}

export const InvoiceAmount: MessageFns<InvoiceAmount> = {
  encode(message: InvoiceAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valueSats !== 0) {
      writer.uint32(8).uint64(message.valueSats);
    }
    if (message.invoiceAmountProof !== undefined) {
      InvoiceAmountProof.encode(message.invoiceAmountProof, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvoiceAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvoiceAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valueSats = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.invoiceAmountProof = InvoiceAmountProof.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvoiceAmount {
    return {
      valueSats: isSet(object.valueSats) ? globalThis.Number(object.valueSats) : 0,
      invoiceAmountProof: isSet(object.invoiceAmountProof)
        ? InvoiceAmountProof.fromJSON(object.invoiceAmountProof)
        : undefined,
    };
  },

  toJSON(message: InvoiceAmount): unknown {
    const obj: any = {};
    if (message.valueSats !== 0) {
      obj.valueSats = Math.round(message.valueSats);
    }
    if (message.invoiceAmountProof !== undefined) {
      obj.invoiceAmountProof = InvoiceAmountProof.toJSON(message.invoiceAmountProof);
    }
    return obj;
  },

  create(base?: DeepPartial<InvoiceAmount>): InvoiceAmount {
    return InvoiceAmount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvoiceAmount>): InvoiceAmount {
    const message = createBaseInvoiceAmount();
    message.valueSats = object.valueSats ?? 0;
    message.invoiceAmountProof = (object.invoiceAmountProof !== undefined && object.invoiceAmountProof !== null)
      ? InvoiceAmountProof.fromPartial(object.invoiceAmountProof)
      : undefined;
    return message;
  },
};

function createBaseInitiatePreimageSwapRequest(): InitiatePreimageSwapRequest {
  return {
    paymentHash: new Uint8Array(0),
    invoiceAmount: undefined,
    reason: 0,
    transfer: undefined,
    receiverIdentityPublicKey: new Uint8Array(0),
    feeSats: 0,
  };
}

export const InitiatePreimageSwapRequest: MessageFns<InitiatePreimageSwapRequest> = {
  encode(message: InitiatePreimageSwapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentHash.length !== 0) {
      writer.uint32(10).bytes(message.paymentHash);
    }
    if (message.invoiceAmount !== undefined) {
      InvoiceAmount.encode(message.invoiceAmount, writer.uint32(18).fork()).join();
    }
    if (message.reason !== 0) {
      writer.uint32(24).int32(message.reason);
    }
    if (message.transfer !== undefined) {
      StartUserSignedTransferRequest.encode(message.transfer, writer.uint32(34).fork()).join();
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      writer.uint32(42).bytes(message.receiverIdentityPublicKey);
    }
    if (message.feeSats !== 0) {
      writer.uint32(48).uint64(message.feeSats);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiatePreimageSwapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiatePreimageSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.invoiceAmount = InvoiceAmount.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.transfer = StartUserSignedTransferRequest.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.receiverIdentityPublicKey = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.feeSats = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiatePreimageSwapRequest {
    return {
      paymentHash: isSet(object.paymentHash) ? bytesFromBase64(object.paymentHash) : new Uint8Array(0),
      invoiceAmount: isSet(object.invoiceAmount) ? InvoiceAmount.fromJSON(object.invoiceAmount) : undefined,
      reason: isSet(object.reason) ? initiatePreimageSwapRequest_ReasonFromJSON(object.reason) : 0,
      transfer: isSet(object.transfer) ? StartUserSignedTransferRequest.fromJSON(object.transfer) : undefined,
      receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
        ? bytesFromBase64(object.receiverIdentityPublicKey)
        : new Uint8Array(0),
      feeSats: isSet(object.feeSats) ? globalThis.Number(object.feeSats) : 0,
    };
  },

  toJSON(message: InitiatePreimageSwapRequest): unknown {
    const obj: any = {};
    if (message.paymentHash.length !== 0) {
      obj.paymentHash = base64FromBytes(message.paymentHash);
    }
    if (message.invoiceAmount !== undefined) {
      obj.invoiceAmount = InvoiceAmount.toJSON(message.invoiceAmount);
    }
    if (message.reason !== 0) {
      obj.reason = initiatePreimageSwapRequest_ReasonToJSON(message.reason);
    }
    if (message.transfer !== undefined) {
      obj.transfer = StartUserSignedTransferRequest.toJSON(message.transfer);
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      obj.receiverIdentityPublicKey = base64FromBytes(message.receiverIdentityPublicKey);
    }
    if (message.feeSats !== 0) {
      obj.feeSats = Math.round(message.feeSats);
    }
    return obj;
  },

  create(base?: DeepPartial<InitiatePreimageSwapRequest>): InitiatePreimageSwapRequest {
    return InitiatePreimageSwapRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitiatePreimageSwapRequest>): InitiatePreimageSwapRequest {
    const message = createBaseInitiatePreimageSwapRequest();
    message.paymentHash = object.paymentHash ?? new Uint8Array(0);
    message.invoiceAmount = (object.invoiceAmount !== undefined && object.invoiceAmount !== null)
      ? InvoiceAmount.fromPartial(object.invoiceAmount)
      : undefined;
    message.reason = object.reason ?? 0;
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? StartUserSignedTransferRequest.fromPartial(object.transfer)
      : undefined;
    message.receiverIdentityPublicKey = object.receiverIdentityPublicKey ?? new Uint8Array(0);
    message.feeSats = object.feeSats ?? 0;
    return message;
  },
};

function createBaseInitiatePreimageSwapResponse(): InitiatePreimageSwapResponse {
  return { preimage: new Uint8Array(0), transfer: undefined };
}

export const InitiatePreimageSwapResponse: MessageFns<InitiatePreimageSwapResponse> = {
  encode(message: InitiatePreimageSwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preimage.length !== 0) {
      writer.uint32(10).bytes(message.preimage);
    }
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiatePreimageSwapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiatePreimageSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.preimage = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiatePreimageSwapResponse {
    return {
      preimage: isSet(object.preimage) ? bytesFromBase64(object.preimage) : new Uint8Array(0),
      transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined,
    };
  },

  toJSON(message: InitiatePreimageSwapResponse): unknown {
    const obj: any = {};
    if (message.preimage.length !== 0) {
      obj.preimage = base64FromBytes(message.preimage);
    }
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    return obj;
  },

  create(base?: DeepPartial<InitiatePreimageSwapResponse>): InitiatePreimageSwapResponse {
    return InitiatePreimageSwapResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitiatePreimageSwapResponse>): InitiatePreimageSwapResponse {
    const message = createBaseInitiatePreimageSwapResponse();
    message.preimage = object.preimage ?? new Uint8Array(0);
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    return message;
  },
};

function createBaseOutPoint(): OutPoint {
  return { txid: new Uint8Array(0), vout: 0 };
}

export const OutPoint: MessageFns<OutPoint> = {
  encode(message: OutPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid.length !== 0) {
      writer.uint32(10).bytes(message.txid);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutPoint {
    return {
      txid: isSet(object.txid) ? bytesFromBase64(object.txid) : new Uint8Array(0),
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
    };
  },

  toJSON(message: OutPoint): unknown {
    const obj: any = {};
    if (message.txid.length !== 0) {
      obj.txid = base64FromBytes(message.txid);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    return obj;
  },

  create(base?: DeepPartial<OutPoint>): OutPoint {
    return OutPoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutPoint>): OutPoint {
    const message = createBaseOutPoint();
    message.txid = object.txid ?? new Uint8Array(0);
    message.vout = object.vout ?? 0;
    return message;
  },
};

function createBaseCooperativeExitRequest(): CooperativeExitRequest {
  return { transfer: undefined, exitId: "", exitTxid: new Uint8Array(0) };
}

export const CooperativeExitRequest: MessageFns<CooperativeExitRequest> = {
  encode(message: CooperativeExitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      StartTransferRequest.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    if (message.exitId !== "") {
      writer.uint32(18).string(message.exitId);
    }
    if (message.exitTxid.length !== 0) {
      writer.uint32(26).bytes(message.exitTxid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CooperativeExitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCooperativeExitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = StartTransferRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exitId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.exitTxid = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CooperativeExitRequest {
    return {
      transfer: isSet(object.transfer) ? StartTransferRequest.fromJSON(object.transfer) : undefined,
      exitId: isSet(object.exitId) ? globalThis.String(object.exitId) : "",
      exitTxid: isSet(object.exitTxid) ? bytesFromBase64(object.exitTxid) : new Uint8Array(0),
    };
  },

  toJSON(message: CooperativeExitRequest): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = StartTransferRequest.toJSON(message.transfer);
    }
    if (message.exitId !== "") {
      obj.exitId = message.exitId;
    }
    if (message.exitTxid.length !== 0) {
      obj.exitTxid = base64FromBytes(message.exitTxid);
    }
    return obj;
  },

  create(base?: DeepPartial<CooperativeExitRequest>): CooperativeExitRequest {
    return CooperativeExitRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CooperativeExitRequest>): CooperativeExitRequest {
    const message = createBaseCooperativeExitRequest();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? StartTransferRequest.fromPartial(object.transfer)
      : undefined;
    message.exitId = object.exitId ?? "";
    message.exitTxid = object.exitTxid ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCooperativeExitResponse(): CooperativeExitResponse {
  return { transfer: undefined, signingResults: [] };
}

export const CooperativeExitResponse: MessageFns<CooperativeExitResponse> = {
  encode(message: CooperativeExitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    for (const v of message.signingResults) {
      LeafRefundTxSigningResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CooperativeExitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCooperativeExitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingResults.push(LeafRefundTxSigningResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CooperativeExitResponse {
    return {
      transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined,
      signingResults: globalThis.Array.isArray(object?.signingResults)
        ? object.signingResults.map((e: any) => LeafRefundTxSigningResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CooperativeExitResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    if (message.signingResults?.length) {
      obj.signingResults = message.signingResults.map((e) => LeafRefundTxSigningResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CooperativeExitResponse>): CooperativeExitResponse {
    return CooperativeExitResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CooperativeExitResponse>): CooperativeExitResponse {
    const message = createBaseCooperativeExitResponse();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    message.signingResults = object.signingResults?.map((e) => LeafRefundTxSigningResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCounterLeafSwapRequest(): CounterLeafSwapRequest {
  return {
    transfer: undefined,
    swapId: "",
    adaptorPublicKey: new Uint8Array(0),
    directAdaptorPublicKey: new Uint8Array(0),
    directFromCpfpAdaptorPublicKey: new Uint8Array(0),
  };
}

export const CounterLeafSwapRequest: MessageFns<CounterLeafSwapRequest> = {
  encode(message: CounterLeafSwapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      StartTransferRequest.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    if (message.swapId !== "") {
      writer.uint32(18).string(message.swapId);
    }
    if (message.adaptorPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.adaptorPublicKey);
    }
    if (message.directAdaptorPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.directAdaptorPublicKey);
    }
    if (message.directFromCpfpAdaptorPublicKey.length !== 0) {
      writer.uint32(42).bytes(message.directFromCpfpAdaptorPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CounterLeafSwapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCounterLeafSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = StartTransferRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.swapId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.adaptorPublicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.directAdaptorPublicKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.directFromCpfpAdaptorPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CounterLeafSwapRequest {
    return {
      transfer: isSet(object.transfer) ? StartTransferRequest.fromJSON(object.transfer) : undefined,
      swapId: isSet(object.swapId) ? globalThis.String(object.swapId) : "",
      adaptorPublicKey: isSet(object.adaptorPublicKey) ? bytesFromBase64(object.adaptorPublicKey) : new Uint8Array(0),
      directAdaptorPublicKey: isSet(object.directAdaptorPublicKey)
        ? bytesFromBase64(object.directAdaptorPublicKey)
        : new Uint8Array(0),
      directFromCpfpAdaptorPublicKey: isSet(object.directFromCpfpAdaptorPublicKey)
        ? bytesFromBase64(object.directFromCpfpAdaptorPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CounterLeafSwapRequest): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = StartTransferRequest.toJSON(message.transfer);
    }
    if (message.swapId !== "") {
      obj.swapId = message.swapId;
    }
    if (message.adaptorPublicKey.length !== 0) {
      obj.adaptorPublicKey = base64FromBytes(message.adaptorPublicKey);
    }
    if (message.directAdaptorPublicKey.length !== 0) {
      obj.directAdaptorPublicKey = base64FromBytes(message.directAdaptorPublicKey);
    }
    if (message.directFromCpfpAdaptorPublicKey.length !== 0) {
      obj.directFromCpfpAdaptorPublicKey = base64FromBytes(message.directFromCpfpAdaptorPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<CounterLeafSwapRequest>): CounterLeafSwapRequest {
    return CounterLeafSwapRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CounterLeafSwapRequest>): CounterLeafSwapRequest {
    const message = createBaseCounterLeafSwapRequest();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? StartTransferRequest.fromPartial(object.transfer)
      : undefined;
    message.swapId = object.swapId ?? "";
    message.adaptorPublicKey = object.adaptorPublicKey ?? new Uint8Array(0);
    message.directAdaptorPublicKey = object.directAdaptorPublicKey ?? new Uint8Array(0);
    message.directFromCpfpAdaptorPublicKey = object.directFromCpfpAdaptorPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCounterLeafSwapResponse(): CounterLeafSwapResponse {
  return { transfer: undefined, signingResults: [] };
}

export const CounterLeafSwapResponse: MessageFns<CounterLeafSwapResponse> = {
  encode(message: CounterLeafSwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    for (const v of message.signingResults) {
      LeafRefundTxSigningResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CounterLeafSwapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCounterLeafSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingResults.push(LeafRefundTxSigningResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CounterLeafSwapResponse {
    return {
      transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined,
      signingResults: globalThis.Array.isArray(object?.signingResults)
        ? object.signingResults.map((e: any) => LeafRefundTxSigningResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CounterLeafSwapResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    if (message.signingResults?.length) {
      obj.signingResults = message.signingResults.map((e) => LeafRefundTxSigningResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CounterLeafSwapResponse>): CounterLeafSwapResponse {
    return CounterLeafSwapResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CounterLeafSwapResponse>): CounterLeafSwapResponse {
    const message = createBaseCounterLeafSwapResponse();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    message.signingResults = object.signingResults?.map((e) => LeafRefundTxSigningResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRefreshTimelockRequest(): RefreshTimelockRequest {
  return { leafId: "", ownerIdentityPublicKey: new Uint8Array(0), signingJobs: [] };
}

export const RefreshTimelockRequest: MessageFns<RefreshTimelockRequest> = {
  encode(message: RefreshTimelockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.signingJobs) {
      SigningJob.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTimelockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTimelockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signingJobs.push(SigningJob.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTimelockRequest {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      signingJobs: globalThis.Array.isArray(object?.signingJobs)
        ? object.signingJobs.map((e: any) => SigningJob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RefreshTimelockRequest): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.signingJobs?.length) {
      obj.signingJobs = message.signingJobs.map((e) => SigningJob.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RefreshTimelockRequest>): RefreshTimelockRequest {
    return RefreshTimelockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RefreshTimelockRequest>): RefreshTimelockRequest {
    const message = createBaseRefreshTimelockRequest();
    message.leafId = object.leafId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.signingJobs = object.signingJobs?.map((e) => SigningJob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRefreshTimelockSigningResult(): RefreshTimelockSigningResult {
  return { signingResult: undefined, verifyingKey: new Uint8Array(0) };
}

export const RefreshTimelockSigningResult: MessageFns<RefreshTimelockSigningResult> = {
  encode(message: RefreshTimelockSigningResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signingResult !== undefined) {
      SigningResult.encode(message.signingResult, writer.uint32(10).fork()).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(18).bytes(message.verifyingKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTimelockSigningResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTimelockSigningResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTimelockSigningResult {
    return {
      signingResult: isSet(object.signingResult) ? SigningResult.fromJSON(object.signingResult) : undefined,
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
    };
  },

  toJSON(message: RefreshTimelockSigningResult): unknown {
    const obj: any = {};
    if (message.signingResult !== undefined) {
      obj.signingResult = SigningResult.toJSON(message.signingResult);
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    return obj;
  },

  create(base?: DeepPartial<RefreshTimelockSigningResult>): RefreshTimelockSigningResult {
    return RefreshTimelockSigningResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RefreshTimelockSigningResult>): RefreshTimelockSigningResult {
    const message = createBaseRefreshTimelockSigningResult();
    message.signingResult = (object.signingResult !== undefined && object.signingResult !== null)
      ? SigningResult.fromPartial(object.signingResult)
      : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRefreshTimelockResponse(): RefreshTimelockResponse {
  return { signingResults: [] };
}

export const RefreshTimelockResponse: MessageFns<RefreshTimelockResponse> = {
  encode(message: RefreshTimelockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signingResults) {
      RefreshTimelockSigningResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTimelockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTimelockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingResults.push(RefreshTimelockSigningResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTimelockResponse {
    return {
      signingResults: globalThis.Array.isArray(object?.signingResults)
        ? object.signingResults.map((e: any) => RefreshTimelockSigningResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RefreshTimelockResponse): unknown {
    const obj: any = {};
    if (message.signingResults?.length) {
      obj.signingResults = message.signingResults.map((e) => RefreshTimelockSigningResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RefreshTimelockResponse>): RefreshTimelockResponse {
    return RefreshTimelockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RefreshTimelockResponse>): RefreshTimelockResponse {
    const message = createBaseRefreshTimelockResponse();
    message.signingResults = object.signingResults?.map((e) => RefreshTimelockSigningResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExtendLeafRequest(): ExtendLeafRequest {
  return {
    leafId: "",
    ownerIdentityPublicKey: new Uint8Array(0),
    nodeTxSigningJob: undefined,
    refundTxSigningJob: undefined,
    directNodeTxSigningJob: undefined,
    directRefundTxSigningJob: undefined,
    directFromCpfpRefundTxSigningJob: undefined,
  };
}

export const ExtendLeafRequest: MessageFns<ExtendLeafRequest> = {
  encode(message: ExtendLeafRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    if (message.nodeTxSigningJob !== undefined) {
      SigningJob.encode(message.nodeTxSigningJob, writer.uint32(26).fork()).join();
    }
    if (message.refundTxSigningJob !== undefined) {
      SigningJob.encode(message.refundTxSigningJob, writer.uint32(34).fork()).join();
    }
    if (message.directNodeTxSigningJob !== undefined) {
      SigningJob.encode(message.directNodeTxSigningJob, writer.uint32(42).fork()).join();
    }
    if (message.directRefundTxSigningJob !== undefined) {
      SigningJob.encode(message.directRefundTxSigningJob, writer.uint32(50).fork()).join();
    }
    if (message.directFromCpfpRefundTxSigningJob !== undefined) {
      SigningJob.encode(message.directFromCpfpRefundTxSigningJob, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtendLeafRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtendLeafRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodeTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.directNodeTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.directRefundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.directFromCpfpRefundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtendLeafRequest {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      nodeTxSigningJob: isSet(object.nodeTxSigningJob) ? SigningJob.fromJSON(object.nodeTxSigningJob) : undefined,
      refundTxSigningJob: isSet(object.refundTxSigningJob) ? SigningJob.fromJSON(object.refundTxSigningJob) : undefined,
      directNodeTxSigningJob: isSet(object.directNodeTxSigningJob)
        ? SigningJob.fromJSON(object.directNodeTxSigningJob)
        : undefined,
      directRefundTxSigningJob: isSet(object.directRefundTxSigningJob)
        ? SigningJob.fromJSON(object.directRefundTxSigningJob)
        : undefined,
      directFromCpfpRefundTxSigningJob: isSet(object.directFromCpfpRefundTxSigningJob)
        ? SigningJob.fromJSON(object.directFromCpfpRefundTxSigningJob)
        : undefined,
    };
  },

  toJSON(message: ExtendLeafRequest): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.nodeTxSigningJob !== undefined) {
      obj.nodeTxSigningJob = SigningJob.toJSON(message.nodeTxSigningJob);
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
    }
    if (message.directNodeTxSigningJob !== undefined) {
      obj.directNodeTxSigningJob = SigningJob.toJSON(message.directNodeTxSigningJob);
    }
    if (message.directRefundTxSigningJob !== undefined) {
      obj.directRefundTxSigningJob = SigningJob.toJSON(message.directRefundTxSigningJob);
    }
    if (message.directFromCpfpRefundTxSigningJob !== undefined) {
      obj.directFromCpfpRefundTxSigningJob = SigningJob.toJSON(message.directFromCpfpRefundTxSigningJob);
    }
    return obj;
  },

  create(base?: DeepPartial<ExtendLeafRequest>): ExtendLeafRequest {
    return ExtendLeafRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtendLeafRequest>): ExtendLeafRequest {
    const message = createBaseExtendLeafRequest();
    message.leafId = object.leafId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.nodeTxSigningJob = (object.nodeTxSigningJob !== undefined && object.nodeTxSigningJob !== null)
      ? SigningJob.fromPartial(object.nodeTxSigningJob)
      : undefined;
    message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
      ? SigningJob.fromPartial(object.refundTxSigningJob)
      : undefined;
    message.directNodeTxSigningJob =
      (object.directNodeTxSigningJob !== undefined && object.directNodeTxSigningJob !== null)
        ? SigningJob.fromPartial(object.directNodeTxSigningJob)
        : undefined;
    message.directRefundTxSigningJob =
      (object.directRefundTxSigningJob !== undefined && object.directRefundTxSigningJob !== null)
        ? SigningJob.fromPartial(object.directRefundTxSigningJob)
        : undefined;
    message.directFromCpfpRefundTxSigningJob =
      (object.directFromCpfpRefundTxSigningJob !== undefined && object.directFromCpfpRefundTxSigningJob !== null)
        ? SigningJob.fromPartial(object.directFromCpfpRefundTxSigningJob)
        : undefined;
    return message;
  },
};

function createBaseExtendLeafSigningResult(): ExtendLeafSigningResult {
  return { signingResult: undefined, verifyingKey: new Uint8Array(0) };
}

export const ExtendLeafSigningResult: MessageFns<ExtendLeafSigningResult> = {
  encode(message: ExtendLeafSigningResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signingResult !== undefined) {
      SigningResult.encode(message.signingResult, writer.uint32(10).fork()).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(18).bytes(message.verifyingKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtendLeafSigningResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtendLeafSigningResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtendLeafSigningResult {
    return {
      signingResult: isSet(object.signingResult) ? SigningResult.fromJSON(object.signingResult) : undefined,
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
    };
  },

  toJSON(message: ExtendLeafSigningResult): unknown {
    const obj: any = {};
    if (message.signingResult !== undefined) {
      obj.signingResult = SigningResult.toJSON(message.signingResult);
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    return obj;
  },

  create(base?: DeepPartial<ExtendLeafSigningResult>): ExtendLeafSigningResult {
    return ExtendLeafSigningResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtendLeafSigningResult>): ExtendLeafSigningResult {
    const message = createBaseExtendLeafSigningResult();
    message.signingResult = (object.signingResult !== undefined && object.signingResult !== null)
      ? SigningResult.fromPartial(object.signingResult)
      : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseExtendLeafResponse(): ExtendLeafResponse {
  return {
    leafId: "",
    nodeTxSigningResult: undefined,
    refundTxSigningResult: undefined,
    directNodeTxSigningResult: undefined,
    directRefundTxSigningResult: undefined,
    directFromCpfpRefundTxSigningResult: undefined,
  };
}

export const ExtendLeafResponse: MessageFns<ExtendLeafResponse> = {
  encode(message: ExtendLeafResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.nodeTxSigningResult !== undefined) {
      ExtendLeafSigningResult.encode(message.nodeTxSigningResult, writer.uint32(18).fork()).join();
    }
    if (message.refundTxSigningResult !== undefined) {
      ExtendLeafSigningResult.encode(message.refundTxSigningResult, writer.uint32(26).fork()).join();
    }
    if (message.directNodeTxSigningResult !== undefined) {
      ExtendLeafSigningResult.encode(message.directNodeTxSigningResult, writer.uint32(34).fork()).join();
    }
    if (message.directRefundTxSigningResult !== undefined) {
      ExtendLeafSigningResult.encode(message.directRefundTxSigningResult, writer.uint32(42).fork()).join();
    }
    if (message.directFromCpfpRefundTxSigningResult !== undefined) {
      ExtendLeafSigningResult.encode(message.directFromCpfpRefundTxSigningResult, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtendLeafResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtendLeafResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeTxSigningResult = ExtendLeafSigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundTxSigningResult = ExtendLeafSigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.directNodeTxSigningResult = ExtendLeafSigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.directRefundTxSigningResult = ExtendLeafSigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.directFromCpfpRefundTxSigningResult = ExtendLeafSigningResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtendLeafResponse {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      nodeTxSigningResult: isSet(object.nodeTxSigningResult)
        ? ExtendLeafSigningResult.fromJSON(object.nodeTxSigningResult)
        : undefined,
      refundTxSigningResult: isSet(object.refundTxSigningResult)
        ? ExtendLeafSigningResult.fromJSON(object.refundTxSigningResult)
        : undefined,
      directNodeTxSigningResult: isSet(object.directNodeTxSigningResult)
        ? ExtendLeafSigningResult.fromJSON(object.directNodeTxSigningResult)
        : undefined,
      directRefundTxSigningResult: isSet(object.directRefundTxSigningResult)
        ? ExtendLeafSigningResult.fromJSON(object.directRefundTxSigningResult)
        : undefined,
      directFromCpfpRefundTxSigningResult: isSet(object.directFromCpfpRefundTxSigningResult)
        ? ExtendLeafSigningResult.fromJSON(object.directFromCpfpRefundTxSigningResult)
        : undefined,
    };
  },

  toJSON(message: ExtendLeafResponse): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.nodeTxSigningResult !== undefined) {
      obj.nodeTxSigningResult = ExtendLeafSigningResult.toJSON(message.nodeTxSigningResult);
    }
    if (message.refundTxSigningResult !== undefined) {
      obj.refundTxSigningResult = ExtendLeafSigningResult.toJSON(message.refundTxSigningResult);
    }
    if (message.directNodeTxSigningResult !== undefined) {
      obj.directNodeTxSigningResult = ExtendLeafSigningResult.toJSON(message.directNodeTxSigningResult);
    }
    if (message.directRefundTxSigningResult !== undefined) {
      obj.directRefundTxSigningResult = ExtendLeafSigningResult.toJSON(message.directRefundTxSigningResult);
    }
    if (message.directFromCpfpRefundTxSigningResult !== undefined) {
      obj.directFromCpfpRefundTxSigningResult = ExtendLeafSigningResult.toJSON(
        message.directFromCpfpRefundTxSigningResult,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ExtendLeafResponse>): ExtendLeafResponse {
    return ExtendLeafResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtendLeafResponse>): ExtendLeafResponse {
    const message = createBaseExtendLeafResponse();
    message.leafId = object.leafId ?? "";
    message.nodeTxSigningResult = (object.nodeTxSigningResult !== undefined && object.nodeTxSigningResult !== null)
      ? ExtendLeafSigningResult.fromPartial(object.nodeTxSigningResult)
      : undefined;
    message.refundTxSigningResult =
      (object.refundTxSigningResult !== undefined && object.refundTxSigningResult !== null)
        ? ExtendLeafSigningResult.fromPartial(object.refundTxSigningResult)
        : undefined;
    message.directNodeTxSigningResult =
      (object.directNodeTxSigningResult !== undefined && object.directNodeTxSigningResult !== null)
        ? ExtendLeafSigningResult.fromPartial(object.directNodeTxSigningResult)
        : undefined;
    message.directRefundTxSigningResult =
      (object.directRefundTxSigningResult !== undefined && object.directRefundTxSigningResult !== null)
        ? ExtendLeafSigningResult.fromPartial(object.directRefundTxSigningResult)
        : undefined;
    message.directFromCpfpRefundTxSigningResult =
      (object.directFromCpfpRefundTxSigningResult !== undefined && object.directFromCpfpRefundTxSigningResult !== null)
        ? ExtendLeafSigningResult.fromPartial(object.directFromCpfpRefundTxSigningResult)
        : undefined;
    return message;
  },
};

function createBaseAddressRequestNode(): AddressRequestNode {
  return { userPublicKey: new Uint8Array(0), children: [] };
}

export const AddressRequestNode: MessageFns<AddressRequestNode> = {
  encode(message: AddressRequestNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.userPublicKey);
    }
    for (const v of message.children) {
      AddressRequestNode.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressRequestNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressRequestNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.children.push(AddressRequestNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressRequestNode {
    return {
      userPublicKey: isSet(object.userPublicKey) ? bytesFromBase64(object.userPublicKey) : new Uint8Array(0),
      children: globalThis.Array.isArray(object?.children)
        ? object.children.map((e: any) => AddressRequestNode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AddressRequestNode): unknown {
    const obj: any = {};
    if (message.userPublicKey.length !== 0) {
      obj.userPublicKey = base64FromBytes(message.userPublicKey);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => AddressRequestNode.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AddressRequestNode>): AddressRequestNode {
    return AddressRequestNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddressRequestNode>): AddressRequestNode {
    const message = createBaseAddressRequestNode();
    message.userPublicKey = object.userPublicKey ?? new Uint8Array(0);
    message.children = object.children?.map((e) => AddressRequestNode.fromPartial(e)) || [];
    return message;
  },
};

function createBasePrepareTreeAddressRequest(): PrepareTreeAddressRequest {
  return { source: undefined, node: undefined, userIdentityPublicKey: new Uint8Array(0) };
}

export const PrepareTreeAddressRequest: MessageFns<PrepareTreeAddressRequest> = {
  encode(message: PrepareTreeAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.source?.$case) {
      case "parentNodeOutput":
        NodeOutput.encode(message.source.parentNodeOutput, writer.uint32(10).fork()).join();
        break;
      case "onChainUtxo":
        UTXO.encode(message.source.onChainUtxo, writer.uint32(18).fork()).join();
        break;
    }
    if (message.node !== undefined) {
      AddressRequestNode.encode(message.node, writer.uint32(26).fork()).join();
    }
    if (message.userIdentityPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.userIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrepareTreeAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareTreeAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = { $case: "parentNodeOutput", parentNodeOutput: NodeOutput.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = { $case: "onChainUtxo", onChainUtxo: UTXO.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.node = AddressRequestNode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrepareTreeAddressRequest {
    return {
      source: isSet(object.parentNodeOutput)
        ? { $case: "parentNodeOutput", parentNodeOutput: NodeOutput.fromJSON(object.parentNodeOutput) }
        : isSet(object.onChainUtxo)
        ? { $case: "onChainUtxo", onChainUtxo: UTXO.fromJSON(object.onChainUtxo) }
        : undefined,
      node: isSet(object.node) ? AddressRequestNode.fromJSON(object.node) : undefined,
      userIdentityPublicKey: isSet(object.userIdentityPublicKey)
        ? bytesFromBase64(object.userIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: PrepareTreeAddressRequest): unknown {
    const obj: any = {};
    if (message.source?.$case === "parentNodeOutput") {
      obj.parentNodeOutput = NodeOutput.toJSON(message.source.parentNodeOutput);
    } else if (message.source?.$case === "onChainUtxo") {
      obj.onChainUtxo = UTXO.toJSON(message.source.onChainUtxo);
    }
    if (message.node !== undefined) {
      obj.node = AddressRequestNode.toJSON(message.node);
    }
    if (message.userIdentityPublicKey.length !== 0) {
      obj.userIdentityPublicKey = base64FromBytes(message.userIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<PrepareTreeAddressRequest>): PrepareTreeAddressRequest {
    return PrepareTreeAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrepareTreeAddressRequest>): PrepareTreeAddressRequest {
    const message = createBasePrepareTreeAddressRequest();
    switch (object.source?.$case) {
      case "parentNodeOutput": {
        if (object.source?.parentNodeOutput !== undefined && object.source?.parentNodeOutput !== null) {
          message.source = {
            $case: "parentNodeOutput",
            parentNodeOutput: NodeOutput.fromPartial(object.source.parentNodeOutput),
          };
        }
        break;
      }
      case "onChainUtxo": {
        if (object.source?.onChainUtxo !== undefined && object.source?.onChainUtxo !== null) {
          message.source = { $case: "onChainUtxo", onChainUtxo: UTXO.fromPartial(object.source.onChainUtxo) };
        }
        break;
      }
    }
    message.node = (object.node !== undefined && object.node !== null)
      ? AddressRequestNode.fromPartial(object.node)
      : undefined;
    message.userIdentityPublicKey = object.userIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAddressNode(): AddressNode {
  return { address: undefined, children: [] };
}

export const AddressNode: MessageFns<AddressNode> = {
  encode(message: AddressNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).join();
    }
    for (const v of message.children) {
      AddressNode.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.children.push(AddressNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressNode {
    return {
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      children: globalThis.Array.isArray(object?.children)
        ? object.children.map((e: any) => AddressNode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AddressNode): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => AddressNode.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AddressNode>): AddressNode {
    return AddressNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddressNode>): AddressNode {
    const message = createBaseAddressNode();
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.children = object.children?.map((e) => AddressNode.fromPartial(e)) || [];
    return message;
  },
};

function createBasePrepareTreeAddressResponse(): PrepareTreeAddressResponse {
  return { node: undefined };
}

export const PrepareTreeAddressResponse: MessageFns<PrepareTreeAddressResponse> = {
  encode(message: PrepareTreeAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      AddressNode.encode(message.node, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrepareTreeAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareTreeAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = AddressNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrepareTreeAddressResponse {
    return { node: isSet(object.node) ? AddressNode.fromJSON(object.node) : undefined };
  },

  toJSON(message: PrepareTreeAddressResponse): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = AddressNode.toJSON(message.node);
    }
    return obj;
  },

  create(base?: DeepPartial<PrepareTreeAddressResponse>): PrepareTreeAddressResponse {
    return PrepareTreeAddressResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrepareTreeAddressResponse>): PrepareTreeAddressResponse {
    const message = createBasePrepareTreeAddressResponse();
    message.node = (object.node !== undefined && object.node !== null)
      ? AddressNode.fromPartial(object.node)
      : undefined;
    return message;
  },
};

function createBaseCreationNode(): CreationNode {
  return {
    nodeTxSigningJob: undefined,
    refundTxSigningJob: undefined,
    children: [],
    directNodeTxSigningJob: undefined,
    directRefundTxSigningJob: undefined,
    directFromCpfpRefundTxSigningJob: undefined,
  };
}

export const CreationNode: MessageFns<CreationNode> = {
  encode(message: CreationNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeTxSigningJob !== undefined) {
      SigningJob.encode(message.nodeTxSigningJob, writer.uint32(10).fork()).join();
    }
    if (message.refundTxSigningJob !== undefined) {
      SigningJob.encode(message.refundTxSigningJob, writer.uint32(18).fork()).join();
    }
    for (const v of message.children) {
      CreationNode.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.directNodeTxSigningJob !== undefined) {
      SigningJob.encode(message.directNodeTxSigningJob, writer.uint32(34).fork()).join();
    }
    if (message.directRefundTxSigningJob !== undefined) {
      SigningJob.encode(message.directRefundTxSigningJob, writer.uint32(42).fork()).join();
    }
    if (message.directFromCpfpRefundTxSigningJob !== undefined) {
      SigningJob.encode(message.directFromCpfpRefundTxSigningJob, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreationNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreationNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.children.push(CreationNode.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.directNodeTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.directRefundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.directFromCpfpRefundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreationNode {
    return {
      nodeTxSigningJob: isSet(object.nodeTxSigningJob) ? SigningJob.fromJSON(object.nodeTxSigningJob) : undefined,
      refundTxSigningJob: isSet(object.refundTxSigningJob) ? SigningJob.fromJSON(object.refundTxSigningJob) : undefined,
      children: globalThis.Array.isArray(object?.children)
        ? object.children.map((e: any) => CreationNode.fromJSON(e))
        : [],
      directNodeTxSigningJob: isSet(object.directNodeTxSigningJob)
        ? SigningJob.fromJSON(object.directNodeTxSigningJob)
        : undefined,
      directRefundTxSigningJob: isSet(object.directRefundTxSigningJob)
        ? SigningJob.fromJSON(object.directRefundTxSigningJob)
        : undefined,
      directFromCpfpRefundTxSigningJob: isSet(object.directFromCpfpRefundTxSigningJob)
        ? SigningJob.fromJSON(object.directFromCpfpRefundTxSigningJob)
        : undefined,
    };
  },

  toJSON(message: CreationNode): unknown {
    const obj: any = {};
    if (message.nodeTxSigningJob !== undefined) {
      obj.nodeTxSigningJob = SigningJob.toJSON(message.nodeTxSigningJob);
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => CreationNode.toJSON(e));
    }
    if (message.directNodeTxSigningJob !== undefined) {
      obj.directNodeTxSigningJob = SigningJob.toJSON(message.directNodeTxSigningJob);
    }
    if (message.directRefundTxSigningJob !== undefined) {
      obj.directRefundTxSigningJob = SigningJob.toJSON(message.directRefundTxSigningJob);
    }
    if (message.directFromCpfpRefundTxSigningJob !== undefined) {
      obj.directFromCpfpRefundTxSigningJob = SigningJob.toJSON(message.directFromCpfpRefundTxSigningJob);
    }
    return obj;
  },

  create(base?: DeepPartial<CreationNode>): CreationNode {
    return CreationNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreationNode>): CreationNode {
    const message = createBaseCreationNode();
    message.nodeTxSigningJob = (object.nodeTxSigningJob !== undefined && object.nodeTxSigningJob !== null)
      ? SigningJob.fromPartial(object.nodeTxSigningJob)
      : undefined;
    message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
      ? SigningJob.fromPartial(object.refundTxSigningJob)
      : undefined;
    message.children = object.children?.map((e) => CreationNode.fromPartial(e)) || [];
    message.directNodeTxSigningJob =
      (object.directNodeTxSigningJob !== undefined && object.directNodeTxSigningJob !== null)
        ? SigningJob.fromPartial(object.directNodeTxSigningJob)
        : undefined;
    message.directRefundTxSigningJob =
      (object.directRefundTxSigningJob !== undefined && object.directRefundTxSigningJob !== null)
        ? SigningJob.fromPartial(object.directRefundTxSigningJob)
        : undefined;
    message.directFromCpfpRefundTxSigningJob =
      (object.directFromCpfpRefundTxSigningJob !== undefined && object.directFromCpfpRefundTxSigningJob !== null)
        ? SigningJob.fromPartial(object.directFromCpfpRefundTxSigningJob)
        : undefined;
    return message;
  },
};

function createBaseCreateTreeRequest(): CreateTreeRequest {
  return { source: undefined, node: undefined, userIdentityPublicKey: new Uint8Array(0) };
}

export const CreateTreeRequest: MessageFns<CreateTreeRequest> = {
  encode(message: CreateTreeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.source?.$case) {
      case "parentNodeOutput":
        NodeOutput.encode(message.source.parentNodeOutput, writer.uint32(10).fork()).join();
        break;
      case "onChainUtxo":
        UTXO.encode(message.source.onChainUtxo, writer.uint32(18).fork()).join();
        break;
    }
    if (message.node !== undefined) {
      CreationNode.encode(message.node, writer.uint32(26).fork()).join();
    }
    if (message.userIdentityPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.userIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTreeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTreeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = { $case: "parentNodeOutput", parentNodeOutput: NodeOutput.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = { $case: "onChainUtxo", onChainUtxo: UTXO.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.node = CreationNode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTreeRequest {
    return {
      source: isSet(object.parentNodeOutput)
        ? { $case: "parentNodeOutput", parentNodeOutput: NodeOutput.fromJSON(object.parentNodeOutput) }
        : isSet(object.onChainUtxo)
        ? { $case: "onChainUtxo", onChainUtxo: UTXO.fromJSON(object.onChainUtxo) }
        : undefined,
      node: isSet(object.node) ? CreationNode.fromJSON(object.node) : undefined,
      userIdentityPublicKey: isSet(object.userIdentityPublicKey)
        ? bytesFromBase64(object.userIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CreateTreeRequest): unknown {
    const obj: any = {};
    if (message.source?.$case === "parentNodeOutput") {
      obj.parentNodeOutput = NodeOutput.toJSON(message.source.parentNodeOutput);
    } else if (message.source?.$case === "onChainUtxo") {
      obj.onChainUtxo = UTXO.toJSON(message.source.onChainUtxo);
    }
    if (message.node !== undefined) {
      obj.node = CreationNode.toJSON(message.node);
    }
    if (message.userIdentityPublicKey.length !== 0) {
      obj.userIdentityPublicKey = base64FromBytes(message.userIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTreeRequest>): CreateTreeRequest {
    return CreateTreeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTreeRequest>): CreateTreeRequest {
    const message = createBaseCreateTreeRequest();
    switch (object.source?.$case) {
      case "parentNodeOutput": {
        if (object.source?.parentNodeOutput !== undefined && object.source?.parentNodeOutput !== null) {
          message.source = {
            $case: "parentNodeOutput",
            parentNodeOutput: NodeOutput.fromPartial(object.source.parentNodeOutput),
          };
        }
        break;
      }
      case "onChainUtxo": {
        if (object.source?.onChainUtxo !== undefined && object.source?.onChainUtxo !== null) {
          message.source = { $case: "onChainUtxo", onChainUtxo: UTXO.fromPartial(object.source.onChainUtxo) };
        }
        break;
      }
    }
    message.node = (object.node !== undefined && object.node !== null)
      ? CreationNode.fromPartial(object.node)
      : undefined;
    message.userIdentityPublicKey = object.userIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCreationResponseNode(): CreationResponseNode {
  return {
    nodeId: "",
    nodeTxSigningResult: undefined,
    refundTxSigningResult: undefined,
    children: [],
    directNodeTxSigningResult: undefined,
    directRefundTxSigningResult: undefined,
    directFromCpfpRefundTxSigningResult: undefined,
  };
}

export const CreationResponseNode: MessageFns<CreationResponseNode> = {
  encode(message: CreationResponseNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.nodeTxSigningResult !== undefined) {
      SigningResult.encode(message.nodeTxSigningResult, writer.uint32(18).fork()).join();
    }
    if (message.refundTxSigningResult !== undefined) {
      SigningResult.encode(message.refundTxSigningResult, writer.uint32(26).fork()).join();
    }
    for (const v of message.children) {
      CreationResponseNode.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.directNodeTxSigningResult !== undefined) {
      SigningResult.encode(message.directNodeTxSigningResult, writer.uint32(42).fork()).join();
    }
    if (message.directRefundTxSigningResult !== undefined) {
      SigningResult.encode(message.directRefundTxSigningResult, writer.uint32(50).fork()).join();
    }
    if (message.directFromCpfpRefundTxSigningResult !== undefined) {
      SigningResult.encode(message.directFromCpfpRefundTxSigningResult, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreationResponseNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreationResponseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.children.push(CreationResponseNode.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.directNodeTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.directRefundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.directFromCpfpRefundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreationResponseNode {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      nodeTxSigningResult: isSet(object.nodeTxSigningResult)
        ? SigningResult.fromJSON(object.nodeTxSigningResult)
        : undefined,
      refundTxSigningResult: isSet(object.refundTxSigningResult)
        ? SigningResult.fromJSON(object.refundTxSigningResult)
        : undefined,
      children: globalThis.Array.isArray(object?.children)
        ? object.children.map((e: any) => CreationResponseNode.fromJSON(e))
        : [],
      directNodeTxSigningResult: isSet(object.directNodeTxSigningResult)
        ? SigningResult.fromJSON(object.directNodeTxSigningResult)
        : undefined,
      directRefundTxSigningResult: isSet(object.directRefundTxSigningResult)
        ? SigningResult.fromJSON(object.directRefundTxSigningResult)
        : undefined,
      directFromCpfpRefundTxSigningResult: isSet(object.directFromCpfpRefundTxSigningResult)
        ? SigningResult.fromJSON(object.directFromCpfpRefundTxSigningResult)
        : undefined,
    };
  },

  toJSON(message: CreationResponseNode): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.nodeTxSigningResult !== undefined) {
      obj.nodeTxSigningResult = SigningResult.toJSON(message.nodeTxSigningResult);
    }
    if (message.refundTxSigningResult !== undefined) {
      obj.refundTxSigningResult = SigningResult.toJSON(message.refundTxSigningResult);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => CreationResponseNode.toJSON(e));
    }
    if (message.directNodeTxSigningResult !== undefined) {
      obj.directNodeTxSigningResult = SigningResult.toJSON(message.directNodeTxSigningResult);
    }
    if (message.directRefundTxSigningResult !== undefined) {
      obj.directRefundTxSigningResult = SigningResult.toJSON(message.directRefundTxSigningResult);
    }
    if (message.directFromCpfpRefundTxSigningResult !== undefined) {
      obj.directFromCpfpRefundTxSigningResult = SigningResult.toJSON(message.directFromCpfpRefundTxSigningResult);
    }
    return obj;
  },

  create(base?: DeepPartial<CreationResponseNode>): CreationResponseNode {
    return CreationResponseNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreationResponseNode>): CreationResponseNode {
    const message = createBaseCreationResponseNode();
    message.nodeId = object.nodeId ?? "";
    message.nodeTxSigningResult = (object.nodeTxSigningResult !== undefined && object.nodeTxSigningResult !== null)
      ? SigningResult.fromPartial(object.nodeTxSigningResult)
      : undefined;
    message.refundTxSigningResult =
      (object.refundTxSigningResult !== undefined && object.refundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.refundTxSigningResult)
        : undefined;
    message.children = object.children?.map((e) => CreationResponseNode.fromPartial(e)) || [];
    message.directNodeTxSigningResult =
      (object.directNodeTxSigningResult !== undefined && object.directNodeTxSigningResult !== null)
        ? SigningResult.fromPartial(object.directNodeTxSigningResult)
        : undefined;
    message.directRefundTxSigningResult =
      (object.directRefundTxSigningResult !== undefined && object.directRefundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.directRefundTxSigningResult)
        : undefined;
    message.directFromCpfpRefundTxSigningResult =
      (object.directFromCpfpRefundTxSigningResult !== undefined && object.directFromCpfpRefundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.directFromCpfpRefundTxSigningResult)
        : undefined;
    return message;
  },
};

function createBaseCreateTreeResponse(): CreateTreeResponse {
  return { node: undefined };
}

export const CreateTreeResponse: MessageFns<CreateTreeResponse> = {
  encode(message: CreateTreeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      CreationResponseNode.encode(message.node, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTreeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTreeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = CreationResponseNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTreeResponse {
    return { node: isSet(object.node) ? CreationResponseNode.fromJSON(object.node) : undefined };
  },

  toJSON(message: CreateTreeResponse): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = CreationResponseNode.toJSON(message.node);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTreeResponse>): CreateTreeResponse {
    return CreateTreeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTreeResponse>): CreateTreeResponse {
    const message = createBaseCreateTreeResponse();
    message.node = (object.node !== undefined && object.node !== null)
      ? CreationResponseNode.fromPartial(object.node)
      : undefined;
    return message;
  },
};

function createBaseSigningOperatorInfo(): SigningOperatorInfo {
  return { index: 0, identifier: "", publicKey: new Uint8Array(0), address: "" };
}

export const SigningOperatorInfo: MessageFns<SigningOperatorInfo> = {
  encode(message: SigningOperatorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).uint64(message.index);
    }
    if (message.identifier !== "") {
      writer.uint32(18).string(message.identifier);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    if (message.address !== "") {
      writer.uint32(34).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningOperatorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningOperatorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningOperatorInfo {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: SigningOperatorInfo): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<SigningOperatorInfo>): SigningOperatorInfo {
    return SigningOperatorInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningOperatorInfo>): SigningOperatorInfo {
    const message = createBaseSigningOperatorInfo();
    message.index = object.index ?? 0;
    message.identifier = object.identifier ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseGetSigningOperatorListResponse(): GetSigningOperatorListResponse {
  return { signingOperators: {} };
}

export const GetSigningOperatorListResponse: MessageFns<GetSigningOperatorListResponse> = {
  encode(message: GetSigningOperatorListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.signingOperators).forEach(([key, value]) => {
      GetSigningOperatorListResponse_SigningOperatorsEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSigningOperatorListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSigningOperatorListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = GetSigningOperatorListResponse_SigningOperatorsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.signingOperators[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSigningOperatorListResponse {
    return {
      signingOperators: isObject(object.signingOperators)
        ? Object.entries(object.signingOperators).reduce<{ [key: string]: SigningOperatorInfo }>(
          (acc, [key, value]) => {
            acc[key] = SigningOperatorInfo.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: GetSigningOperatorListResponse): unknown {
    const obj: any = {};
    if (message.signingOperators) {
      const entries = Object.entries(message.signingOperators);
      if (entries.length > 0) {
        obj.signingOperators = {};
        entries.forEach(([k, v]) => {
          obj.signingOperators[k] = SigningOperatorInfo.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetSigningOperatorListResponse>): GetSigningOperatorListResponse {
    return GetSigningOperatorListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSigningOperatorListResponse>): GetSigningOperatorListResponse {
    const message = createBaseGetSigningOperatorListResponse();
    message.signingOperators = Object.entries(object.signingOperators ?? {}).reduce<
      { [key: string]: SigningOperatorInfo }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SigningOperatorInfo.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetSigningOperatorListResponse_SigningOperatorsEntry(): GetSigningOperatorListResponse_SigningOperatorsEntry {
  return { key: "", value: undefined };
}

export const GetSigningOperatorListResponse_SigningOperatorsEntry: MessageFns<
  GetSigningOperatorListResponse_SigningOperatorsEntry
> = {
  encode(
    message: GetSigningOperatorListResponse_SigningOperatorsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SigningOperatorInfo.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSigningOperatorListResponse_SigningOperatorsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSigningOperatorListResponse_SigningOperatorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SigningOperatorInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSigningOperatorListResponse_SigningOperatorsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SigningOperatorInfo.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetSigningOperatorListResponse_SigningOperatorsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SigningOperatorInfo.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetSigningOperatorListResponse_SigningOperatorsEntry>,
  ): GetSigningOperatorListResponse_SigningOperatorsEntry {
    return GetSigningOperatorListResponse_SigningOperatorsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetSigningOperatorListResponse_SigningOperatorsEntry>,
  ): GetSigningOperatorListResponse_SigningOperatorsEntry {
    const message = createBaseGetSigningOperatorListResponse_SigningOperatorsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SigningOperatorInfo.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseQueryUserSignedRefundsRequest(): QueryUserSignedRefundsRequest {
  return { paymentHash: new Uint8Array(0), identityPublicKey: new Uint8Array(0) };
}

export const QueryUserSignedRefundsRequest: MessageFns<QueryUserSignedRefundsRequest> = {
  encode(message: QueryUserSignedRefundsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentHash.length !== 0) {
      writer.uint32(10).bytes(message.paymentHash);
    }
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.identityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryUserSignedRefundsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUserSignedRefundsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUserSignedRefundsRequest {
    return {
      paymentHash: isSet(object.paymentHash) ? bytesFromBase64(object.paymentHash) : new Uint8Array(0),
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: QueryUserSignedRefundsRequest): unknown {
    const obj: any = {};
    if (message.paymentHash.length !== 0) {
      obj.paymentHash = base64FromBytes(message.paymentHash);
    }
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryUserSignedRefundsRequest>): QueryUserSignedRefundsRequest {
    return QueryUserSignedRefundsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryUserSignedRefundsRequest>): QueryUserSignedRefundsRequest {
    const message = createBaseQueryUserSignedRefundsRequest();
    message.paymentHash = object.paymentHash ?? new Uint8Array(0);
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryUserSignedRefundsResponse(): QueryUserSignedRefundsResponse {
  return { userSignedRefunds: [], transfer: undefined };
}

export const QueryUserSignedRefundsResponse: MessageFns<QueryUserSignedRefundsResponse> = {
  encode(message: QueryUserSignedRefundsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userSignedRefunds) {
      UserSignedRefund.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryUserSignedRefundsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUserSignedRefundsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userSignedRefunds.push(UserSignedRefund.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUserSignedRefundsResponse {
    return {
      userSignedRefunds: globalThis.Array.isArray(object?.userSignedRefunds)
        ? object.userSignedRefunds.map((e: any) => UserSignedRefund.fromJSON(e))
        : [],
      transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined,
    };
  },

  toJSON(message: QueryUserSignedRefundsResponse): unknown {
    const obj: any = {};
    if (message.userSignedRefunds?.length) {
      obj.userSignedRefunds = message.userSignedRefunds.map((e) => UserSignedRefund.toJSON(e));
    }
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryUserSignedRefundsResponse>): QueryUserSignedRefundsResponse {
    return QueryUserSignedRefundsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryUserSignedRefundsResponse>): QueryUserSignedRefundsResponse {
    const message = createBaseQueryUserSignedRefundsResponse();
    message.userSignedRefunds = object.userSignedRefunds?.map((e) => UserSignedRefund.fromPartial(e)) || [];
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    return message;
  },
};

function createBaseProvidePreimageRequest(): ProvidePreimageRequest {
  return { paymentHash: new Uint8Array(0), preimage: new Uint8Array(0), identityPublicKey: new Uint8Array(0) };
}

export const ProvidePreimageRequest: MessageFns<ProvidePreimageRequest> = {
  encode(message: ProvidePreimageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentHash.length !== 0) {
      writer.uint32(10).bytes(message.paymentHash);
    }
    if (message.preimage.length !== 0) {
      writer.uint32(18).bytes(message.preimage);
    }
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.identityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProvidePreimageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProvidePreimageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preimage = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProvidePreimageRequest {
    return {
      paymentHash: isSet(object.paymentHash) ? bytesFromBase64(object.paymentHash) : new Uint8Array(0),
      preimage: isSet(object.preimage) ? bytesFromBase64(object.preimage) : new Uint8Array(0),
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ProvidePreimageRequest): unknown {
    const obj: any = {};
    if (message.paymentHash.length !== 0) {
      obj.paymentHash = base64FromBytes(message.paymentHash);
    }
    if (message.preimage.length !== 0) {
      obj.preimage = base64FromBytes(message.preimage);
    }
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<ProvidePreimageRequest>): ProvidePreimageRequest {
    return ProvidePreimageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProvidePreimageRequest>): ProvidePreimageRequest {
    const message = createBaseProvidePreimageRequest();
    message.paymentHash = object.paymentHash ?? new Uint8Array(0);
    message.preimage = object.preimage ?? new Uint8Array(0);
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseProvidePreimageResponse(): ProvidePreimageResponse {
  return { transfer: undefined };
}

export const ProvidePreimageResponse: MessageFns<ProvidePreimageResponse> = {
  encode(message: ProvidePreimageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProvidePreimageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProvidePreimageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProvidePreimageResponse {
    return { transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined };
  },

  toJSON(message: ProvidePreimageResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    return obj;
  },

  create(base?: DeepPartial<ProvidePreimageResponse>): ProvidePreimageResponse {
    return ProvidePreimageResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProvidePreimageResponse>): ProvidePreimageResponse {
    const message = createBaseProvidePreimageResponse();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    return message;
  },
};

function createBaseReturnLightningPaymentRequest(): ReturnLightningPaymentRequest {
  return { paymentHash: new Uint8Array(0), userIdentityPublicKey: new Uint8Array(0) };
}

export const ReturnLightningPaymentRequest: MessageFns<ReturnLightningPaymentRequest> = {
  encode(message: ReturnLightningPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentHash.length !== 0) {
      writer.uint32(10).bytes(message.paymentHash);
    }
    if (message.userIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.userIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReturnLightningPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReturnLightningPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReturnLightningPaymentRequest {
    return {
      paymentHash: isSet(object.paymentHash) ? bytesFromBase64(object.paymentHash) : new Uint8Array(0),
      userIdentityPublicKey: isSet(object.userIdentityPublicKey)
        ? bytesFromBase64(object.userIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ReturnLightningPaymentRequest): unknown {
    const obj: any = {};
    if (message.paymentHash.length !== 0) {
      obj.paymentHash = base64FromBytes(message.paymentHash);
    }
    if (message.userIdentityPublicKey.length !== 0) {
      obj.userIdentityPublicKey = base64FromBytes(message.userIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<ReturnLightningPaymentRequest>): ReturnLightningPaymentRequest {
    return ReturnLightningPaymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReturnLightningPaymentRequest>): ReturnLightningPaymentRequest {
    const message = createBaseReturnLightningPaymentRequest();
    message.paymentHash = object.paymentHash ?? new Uint8Array(0);
    message.userIdentityPublicKey = object.userIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTreeNodeIds(): TreeNodeIds {
  return { nodeIds: [] };
}

export const TreeNodeIds: MessageFns<TreeNodeIds> = {
  encode(message: TreeNodeIds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodeIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreeNodeIds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreeNodeIds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreeNodeIds {
    return {
      nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: TreeNodeIds): unknown {
    const obj: any = {};
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds;
    }
    return obj;
  },

  create(base?: DeepPartial<TreeNodeIds>): TreeNodeIds {
    return TreeNodeIds.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TreeNodeIds>): TreeNodeIds {
    const message = createBaseTreeNodeIds();
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryNodesRequest(): QueryNodesRequest {
  return { source: undefined, includeParents: false, limit: 0, offset: 0, network: 0 };
}

export const QueryNodesRequest: MessageFns<QueryNodesRequest> = {
  encode(message: QueryNodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.source?.$case) {
      case "ownerIdentityPubkey":
        writer.uint32(10).bytes(message.source.ownerIdentityPubkey);
        break;
      case "nodeIds":
        TreeNodeIds.encode(message.source.nodeIds, writer.uint32(18).fork()).join();
        break;
    }
    if (message.includeParents !== false) {
      writer.uint32(24).bool(message.includeParents);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(40).int64(message.offset);
    }
    if (message.network !== 0) {
      writer.uint32(48).int32(message.network);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryNodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = { $case: "ownerIdentityPubkey", ownerIdentityPubkey: reader.bytes() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = { $case: "nodeIds", nodeIds: TreeNodeIds.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeParents = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNodesRequest {
    return {
      source: isSet(object.ownerIdentityPubkey)
        ? { $case: "ownerIdentityPubkey", ownerIdentityPubkey: bytesFromBase64(object.ownerIdentityPubkey) }
        : isSet(object.nodeIds)
        ? { $case: "nodeIds", nodeIds: TreeNodeIds.fromJSON(object.nodeIds) }
        : undefined,
      includeParents: isSet(object.includeParents) ? globalThis.Boolean(object.includeParents) : false,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
    };
  },

  toJSON(message: QueryNodesRequest): unknown {
    const obj: any = {};
    if (message.source?.$case === "ownerIdentityPubkey") {
      obj.ownerIdentityPubkey = base64FromBytes(message.source.ownerIdentityPubkey);
    } else if (message.source?.$case === "nodeIds") {
      obj.nodeIds = TreeNodeIds.toJSON(message.source.nodeIds);
    }
    if (message.includeParents !== false) {
      obj.includeParents = message.includeParents;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryNodesRequest>): QueryNodesRequest {
    return QueryNodesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryNodesRequest>): QueryNodesRequest {
    const message = createBaseQueryNodesRequest();
    switch (object.source?.$case) {
      case "ownerIdentityPubkey": {
        if (object.source?.ownerIdentityPubkey !== undefined && object.source?.ownerIdentityPubkey !== null) {
          message.source = { $case: "ownerIdentityPubkey", ownerIdentityPubkey: object.source.ownerIdentityPubkey };
        }
        break;
      }
      case "nodeIds": {
        if (object.source?.nodeIds !== undefined && object.source?.nodeIds !== null) {
          message.source = { $case: "nodeIds", nodeIds: TreeNodeIds.fromPartial(object.source.nodeIds) };
        }
        break;
      }
    }
    message.includeParents = object.includeParents ?? false;
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.network = object.network ?? 0;
    return message;
  },
};

function createBaseQueryNodesResponse(): QueryNodesResponse {
  return { nodes: {}, offset: 0 };
}

export const QueryNodesResponse: MessageFns<QueryNodesResponse> = {
  encode(message: QueryNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.nodes).forEach(([key, value]) => {
      QueryNodesResponse_NodesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.offset !== 0) {
      writer.uint32(16).int64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = QueryNodesResponse_NodesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.nodes[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNodesResponse {
    return {
      nodes: isObject(object.nodes)
        ? Object.entries(object.nodes).reduce<{ [key: string]: TreeNode }>((acc, [key, value]) => {
          acc[key] = TreeNode.fromJSON(value);
          return acc;
        }, {})
        : {},
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: QueryNodesResponse): unknown {
    const obj: any = {};
    if (message.nodes) {
      const entries = Object.entries(message.nodes);
      if (entries.length > 0) {
        obj.nodes = {};
        entries.forEach(([k, v]) => {
          obj.nodes[k] = TreeNode.toJSON(v);
        });
      }
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryNodesResponse>): QueryNodesResponse {
    return QueryNodesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryNodesResponse>): QueryNodesResponse {
    const message = createBaseQueryNodesResponse();
    message.nodes = Object.entries(object.nodes ?? {}).reduce<{ [key: string]: TreeNode }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = TreeNode.fromPartial(value);
      }
      return acc;
    }, {});
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseQueryNodesResponse_NodesEntry(): QueryNodesResponse_NodesEntry {
  return { key: "", value: undefined };
}

export const QueryNodesResponse_NodesEntry: MessageFns<QueryNodesResponse_NodesEntry> = {
  encode(message: QueryNodesResponse_NodesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TreeNode.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryNodesResponse_NodesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNodesResponse_NodesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = TreeNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNodesResponse_NodesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? TreeNode.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: QueryNodesResponse_NodesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = TreeNode.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryNodesResponse_NodesEntry>): QueryNodesResponse_NodesEntry {
    return QueryNodesResponse_NodesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryNodesResponse_NodesEntry>): QueryNodesResponse_NodesEntry {
    const message = createBaseQueryNodesResponse_NodesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TreeNode.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCancelTransferRequest(): CancelTransferRequest {
  return { transferId: "", senderIdentityPublicKey: new Uint8Array(0) };
}

export const CancelTransferRequest: MessageFns<CancelTransferRequest> = {
  encode(message: CancelTransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.senderIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.senderIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelTransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.senderIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTransferRequest {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      senderIdentityPublicKey: isSet(object.senderIdentityPublicKey)
        ? bytesFromBase64(object.senderIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CancelTransferRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.senderIdentityPublicKey.length !== 0) {
      obj.senderIdentityPublicKey = base64FromBytes(message.senderIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<CancelTransferRequest>): CancelTransferRequest {
    return CancelTransferRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelTransferRequest>): CancelTransferRequest {
    const message = createBaseCancelTransferRequest();
    message.transferId = object.transferId ?? "";
    message.senderIdentityPublicKey = object.senderIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCancelTransferResponse(): CancelTransferResponse {
  return { transfer: undefined };
}

export const CancelTransferResponse: MessageFns<CancelTransferResponse> = {
  encode(message: CancelTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTransferResponse {
    return { transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined };
  },

  toJSON(message: CancelTransferResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    return obj;
  },

  create(base?: DeepPartial<CancelTransferResponse>): CancelTransferResponse {
    return CancelTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelTransferResponse>): CancelTransferResponse {
    const message = createBaseCancelTransferResponse();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    return message;
  },
};

function createBaseQueryUnusedDepositAddressesRequest(): QueryUnusedDepositAddressesRequest {
  return { identityPublicKey: new Uint8Array(0), network: 0, limit: 0, offset: 0 };
}

export const QueryUnusedDepositAddressesRequest: MessageFns<QueryUnusedDepositAddressesRequest> = {
  encode(message: QueryUnusedDepositAddressesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.identityPublicKey);
    }
    if (message.network !== 0) {
      writer.uint32(16).int32(message.network);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(32).int64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryUnusedDepositAddressesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUnusedDepositAddressesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUnusedDepositAddressesRequest {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: QueryUnusedDepositAddressesRequest): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryUnusedDepositAddressesRequest>): QueryUnusedDepositAddressesRequest {
    return QueryUnusedDepositAddressesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryUnusedDepositAddressesRequest>): QueryUnusedDepositAddressesRequest {
    const message = createBaseQueryUnusedDepositAddressesRequest();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.network = object.network ?? 0;
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseQueryStaticDepositAddressesRequest(): QueryStaticDepositAddressesRequest {
  return { identityPublicKey: new Uint8Array(0), network: 0, limit: 0, offset: 0, depositAddress: undefined };
}

export const QueryStaticDepositAddressesRequest: MessageFns<QueryStaticDepositAddressesRequest> = {
  encode(message: QueryStaticDepositAddressesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.identityPublicKey);
    }
    if (message.network !== 0) {
      writer.uint32(16).int32(message.network);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(40).int64(message.offset);
    }
    if (message.depositAddress !== undefined) {
      writer.uint32(50).string(message.depositAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryStaticDepositAddressesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStaticDepositAddressesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.depositAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStaticDepositAddressesRequest {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      depositAddress: isSet(object.depositAddress) ? globalThis.String(object.depositAddress) : undefined,
    };
  },

  toJSON(message: QueryStaticDepositAddressesRequest): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.depositAddress !== undefined) {
      obj.depositAddress = message.depositAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryStaticDepositAddressesRequest>): QueryStaticDepositAddressesRequest {
    return QueryStaticDepositAddressesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryStaticDepositAddressesRequest>): QueryStaticDepositAddressesRequest {
    const message = createBaseQueryStaticDepositAddressesRequest();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.network = object.network ?? 0;
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.depositAddress = object.depositAddress ?? undefined;
    return message;
  },
};

function createBaseDepositAddressQueryResult(): DepositAddressQueryResult {
  return {
    depositAddress: "",
    userSigningPublicKey: new Uint8Array(0),
    verifyingPublicKey: new Uint8Array(0),
    leafId: undefined,
    proofOfPossession: undefined,
  };
}

export const DepositAddressQueryResult: MessageFns<DepositAddressQueryResult> = {
  encode(message: DepositAddressQueryResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.depositAddress !== "") {
      writer.uint32(10).string(message.depositAddress);
    }
    if (message.userSigningPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.userSigningPublicKey);
    }
    if (message.verifyingPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.verifyingPublicKey);
    }
    if (message.leafId !== undefined) {
      writer.uint32(34).string(message.leafId);
    }
    if (message.proofOfPossession !== undefined) {
      DepositAddressProof.encode(message.proofOfPossession, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositAddressQueryResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositAddressQueryResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.depositAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userSigningPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.verifyingPublicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.proofOfPossession = DepositAddressProof.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositAddressQueryResult {
    return {
      depositAddress: isSet(object.depositAddress) ? globalThis.String(object.depositAddress) : "",
      userSigningPublicKey: isSet(object.userSigningPublicKey)
        ? bytesFromBase64(object.userSigningPublicKey)
        : new Uint8Array(0),
      verifyingPublicKey: isSet(object.verifyingPublicKey)
        ? bytesFromBase64(object.verifyingPublicKey)
        : new Uint8Array(0),
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : undefined,
      proofOfPossession: isSet(object.proofOfPossession)
        ? DepositAddressProof.fromJSON(object.proofOfPossession)
        : undefined,
    };
  },

  toJSON(message: DepositAddressQueryResult): unknown {
    const obj: any = {};
    if (message.depositAddress !== "") {
      obj.depositAddress = message.depositAddress;
    }
    if (message.userSigningPublicKey.length !== 0) {
      obj.userSigningPublicKey = base64FromBytes(message.userSigningPublicKey);
    }
    if (message.verifyingPublicKey.length !== 0) {
      obj.verifyingPublicKey = base64FromBytes(message.verifyingPublicKey);
    }
    if (message.leafId !== undefined) {
      obj.leafId = message.leafId;
    }
    if (message.proofOfPossession !== undefined) {
      obj.proofOfPossession = DepositAddressProof.toJSON(message.proofOfPossession);
    }
    return obj;
  },

  create(base?: DeepPartial<DepositAddressQueryResult>): DepositAddressQueryResult {
    return DepositAddressQueryResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DepositAddressQueryResult>): DepositAddressQueryResult {
    const message = createBaseDepositAddressQueryResult();
    message.depositAddress = object.depositAddress ?? "";
    message.userSigningPublicKey = object.userSigningPublicKey ?? new Uint8Array(0);
    message.verifyingPublicKey = object.verifyingPublicKey ?? new Uint8Array(0);
    message.leafId = object.leafId ?? undefined;
    message.proofOfPossession = (object.proofOfPossession !== undefined && object.proofOfPossession !== null)
      ? DepositAddressProof.fromPartial(object.proofOfPossession)
      : undefined;
    return message;
  },
};

function createBaseQueryUnusedDepositAddressesResponse(): QueryUnusedDepositAddressesResponse {
  return { depositAddresses: [], offset: 0 };
}

export const QueryUnusedDepositAddressesResponse: MessageFns<QueryUnusedDepositAddressesResponse> = {
  encode(message: QueryUnusedDepositAddressesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.depositAddresses) {
      DepositAddressQueryResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.offset !== 0) {
      writer.uint32(16).int64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryUnusedDepositAddressesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUnusedDepositAddressesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.depositAddresses.push(DepositAddressQueryResult.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUnusedDepositAddressesResponse {
    return {
      depositAddresses: globalThis.Array.isArray(object?.depositAddresses)
        ? object.depositAddresses.map((e: any) => DepositAddressQueryResult.fromJSON(e))
        : [],
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: QueryUnusedDepositAddressesResponse): unknown {
    const obj: any = {};
    if (message.depositAddresses?.length) {
      obj.depositAddresses = message.depositAddresses.map((e) => DepositAddressQueryResult.toJSON(e));
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryUnusedDepositAddressesResponse>): QueryUnusedDepositAddressesResponse {
    return QueryUnusedDepositAddressesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryUnusedDepositAddressesResponse>): QueryUnusedDepositAddressesResponse {
    const message = createBaseQueryUnusedDepositAddressesResponse();
    message.depositAddresses = object.depositAddresses?.map((e) => DepositAddressQueryResult.fromPartial(e)) || [];
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseQueryStaticDepositAddressesResponse(): QueryStaticDepositAddressesResponse {
  return { depositAddresses: [] };
}

export const QueryStaticDepositAddressesResponse: MessageFns<QueryStaticDepositAddressesResponse> = {
  encode(message: QueryStaticDepositAddressesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.depositAddresses) {
      DepositAddressQueryResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryStaticDepositAddressesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStaticDepositAddressesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.depositAddresses.push(DepositAddressQueryResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStaticDepositAddressesResponse {
    return {
      depositAddresses: globalThis.Array.isArray(object?.depositAddresses)
        ? object.depositAddresses.map((e: any) => DepositAddressQueryResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryStaticDepositAddressesResponse): unknown {
    const obj: any = {};
    if (message.depositAddresses?.length) {
      obj.depositAddresses = message.depositAddresses.map((e) => DepositAddressQueryResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryStaticDepositAddressesResponse>): QueryStaticDepositAddressesResponse {
    return QueryStaticDepositAddressesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryStaticDepositAddressesResponse>): QueryStaticDepositAddressesResponse {
    const message = createBaseQueryStaticDepositAddressesResponse();
    message.depositAddresses = object.depositAddresses?.map((e) => DepositAddressQueryResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryBalanceRequest(): QueryBalanceRequest {
  return { identityPublicKey: new Uint8Array(0), network: 0 };
}

export const QueryBalanceRequest: MessageFns<QueryBalanceRequest> = {
  encode(message: QueryBalanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.identityPublicKey);
    }
    if (message.network !== 0) {
      writer.uint32(16).int32(message.network);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBalanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceRequest {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
    };
  },

  toJSON(message: QueryBalanceRequest): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryBalanceRequest>): QueryBalanceRequest {
    return QueryBalanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryBalanceRequest>): QueryBalanceRequest {
    const message = createBaseQueryBalanceRequest();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.network = object.network ?? 0;
    return message;
  },
};

function createBaseQueryBalanceResponse(): QueryBalanceResponse {
  return { balance: 0, nodeBalances: {} };
}

export const QueryBalanceResponse: MessageFns<QueryBalanceResponse> = {
  encode(message: QueryBalanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.balance !== 0) {
      writer.uint32(8).uint64(message.balance);
    }
    Object.entries(message.nodeBalances).forEach(([key, value]) => {
      QueryBalanceResponse_NodeBalancesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBalanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.balance = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = QueryBalanceResponse_NodeBalancesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.nodeBalances[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceResponse {
    return {
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0,
      nodeBalances: isObject(object.nodeBalances)
        ? Object.entries(object.nodeBalances).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: QueryBalanceResponse): unknown {
    const obj: any = {};
    if (message.balance !== 0) {
      obj.balance = Math.round(message.balance);
    }
    if (message.nodeBalances) {
      const entries = Object.entries(message.nodeBalances);
      if (entries.length > 0) {
        obj.nodeBalances = {};
        entries.forEach(([k, v]) => {
          obj.nodeBalances[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<QueryBalanceResponse>): QueryBalanceResponse {
    return QueryBalanceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryBalanceResponse>): QueryBalanceResponse {
    const message = createBaseQueryBalanceResponse();
    message.balance = object.balance ?? 0;
    message.nodeBalances = Object.entries(object.nodeBalances ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseQueryBalanceResponse_NodeBalancesEntry(): QueryBalanceResponse_NodeBalancesEntry {
  return { key: "", value: 0 };
}

export const QueryBalanceResponse_NodeBalancesEntry: MessageFns<QueryBalanceResponse_NodeBalancesEntry> = {
  encode(message: QueryBalanceResponse_NodeBalancesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBalanceResponse_NodeBalancesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceResponse_NodeBalancesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceResponse_NodeBalancesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: QueryBalanceResponse_NodeBalancesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryBalanceResponse_NodeBalancesEntry>): QueryBalanceResponse_NodeBalancesEntry {
    return QueryBalanceResponse_NodeBalancesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryBalanceResponse_NodeBalancesEntry>): QueryBalanceResponse_NodeBalancesEntry {
    const message = createBaseQueryBalanceResponse_NodeBalancesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseSparkAddress(): SparkAddress {
  return { identityPublicKey: new Uint8Array(0), sparkInvoiceFields: undefined, signature: undefined };
}

export const SparkAddress: MessageFns<SparkAddress> = {
  encode(message: SparkAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.identityPublicKey);
    }
    if (message.sparkInvoiceFields !== undefined) {
      SparkInvoiceFields.encode(message.sparkInvoiceFields, writer.uint32(18).fork()).join();
    }
    if (message.signature !== undefined) {
      writer.uint32(26).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SparkAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSparkAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sparkInvoiceFields = SparkInvoiceFields.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SparkAddress {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      sparkInvoiceFields: isSet(object.sparkInvoiceFields)
        ? SparkInvoiceFields.fromJSON(object.sparkInvoiceFields)
        : undefined,
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : undefined,
    };
  },

  toJSON(message: SparkAddress): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.sparkInvoiceFields !== undefined) {
      obj.sparkInvoiceFields = SparkInvoiceFields.toJSON(message.sparkInvoiceFields);
    }
    if (message.signature !== undefined) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create(base?: DeepPartial<SparkAddress>): SparkAddress {
    return SparkAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SparkAddress>): SparkAddress {
    const message = createBaseSparkAddress();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.sparkInvoiceFields = (object.sparkInvoiceFields !== undefined && object.sparkInvoiceFields !== null)
      ? SparkInvoiceFields.fromPartial(object.sparkInvoiceFields)
      : undefined;
    message.signature = object.signature ?? undefined;
    return message;
  },
};

function createBaseSparkInvoiceFields(): SparkInvoiceFields {
  return {
    version: 0,
    id: new Uint8Array(0),
    paymentType: undefined,
    memo: undefined,
    senderPublicKey: undefined,
    expiryTime: undefined,
  };
}

export const SparkInvoiceFields: MessageFns<SparkInvoiceFields> = {
  encode(message: SparkInvoiceFields, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.id.length !== 0) {
      writer.uint32(18).bytes(message.id);
    }
    switch (message.paymentType?.$case) {
      case "tokensPayment":
        TokensPayment.encode(message.paymentType.tokensPayment, writer.uint32(26).fork()).join();
        break;
      case "satsPayment":
        SatsPayment.encode(message.paymentType.satsPayment, writer.uint32(34).fork()).join();
        break;
    }
    if (message.memo !== undefined) {
      writer.uint32(42).string(message.memo);
    }
    if (message.senderPublicKey !== undefined) {
      writer.uint32(50).bytes(message.senderPublicKey);
    }
    if (message.expiryTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expiryTime), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SparkInvoiceFields {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSparkInvoiceFields();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentType = {
            $case: "tokensPayment",
            tokensPayment: TokensPayment.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paymentType = { $case: "satsPayment", satsPayment: SatsPayment.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.memo = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.senderPublicKey = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.expiryTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SparkInvoiceFields {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      paymentType: isSet(object.tokensPayment)
        ? { $case: "tokensPayment", tokensPayment: TokensPayment.fromJSON(object.tokensPayment) }
        : isSet(object.satsPayment)
        ? { $case: "satsPayment", satsPayment: SatsPayment.fromJSON(object.satsPayment) }
        : undefined,
      memo: isSet(object.memo) ? globalThis.String(object.memo) : undefined,
      senderPublicKey: isSet(object.senderPublicKey) ? bytesFromBase64(object.senderPublicKey) : undefined,
      expiryTime: isSet(object.expiryTime) ? fromJsonTimestamp(object.expiryTime) : undefined,
    };
  },

  toJSON(message: SparkInvoiceFields): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.paymentType?.$case === "tokensPayment") {
      obj.tokensPayment = TokensPayment.toJSON(message.paymentType.tokensPayment);
    } else if (message.paymentType?.$case === "satsPayment") {
      obj.satsPayment = SatsPayment.toJSON(message.paymentType.satsPayment);
    }
    if (message.memo !== undefined) {
      obj.memo = message.memo;
    }
    if (message.senderPublicKey !== undefined) {
      obj.senderPublicKey = base64FromBytes(message.senderPublicKey);
    }
    if (message.expiryTime !== undefined) {
      obj.expiryTime = message.expiryTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<SparkInvoiceFields>): SparkInvoiceFields {
    return SparkInvoiceFields.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SparkInvoiceFields>): SparkInvoiceFields {
    const message = createBaseSparkInvoiceFields();
    message.version = object.version ?? 0;
    message.id = object.id ?? new Uint8Array(0);
    switch (object.paymentType?.$case) {
      case "tokensPayment": {
        if (object.paymentType?.tokensPayment !== undefined && object.paymentType?.tokensPayment !== null) {
          message.paymentType = {
            $case: "tokensPayment",
            tokensPayment: TokensPayment.fromPartial(object.paymentType.tokensPayment),
          };
        }
        break;
      }
      case "satsPayment": {
        if (object.paymentType?.satsPayment !== undefined && object.paymentType?.satsPayment !== null) {
          message.paymentType = {
            $case: "satsPayment",
            satsPayment: SatsPayment.fromPartial(object.paymentType.satsPayment),
          };
        }
        break;
      }
    }
    message.memo = object.memo ?? undefined;
    message.senderPublicKey = object.senderPublicKey ?? undefined;
    message.expiryTime = object.expiryTime ?? undefined;
    return message;
  },
};

function createBaseSatsPayment(): SatsPayment {
  return { amount: undefined };
}

export const SatsPayment: MessageFns<SatsPayment> = {
  encode(message: SatsPayment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      writer.uint32(8).uint64(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SatsPayment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSatsPayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.amount = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SatsPayment {
    return { amount: isSet(object.amount) ? globalThis.Number(object.amount) : undefined };
  },

  toJSON(message: SatsPayment): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<SatsPayment>): SatsPayment {
    return SatsPayment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SatsPayment>): SatsPayment {
    const message = createBaseSatsPayment();
    message.amount = object.amount ?? undefined;
    return message;
  },
};

function createBaseTokensPayment(): TokensPayment {
  return { tokenIdentifier: undefined, amount: undefined };
}

export const TokensPayment: MessageFns<TokensPayment> = {
  encode(message: TokensPayment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenIdentifier !== undefined) {
      writer.uint32(10).bytes(message.tokenIdentifier);
    }
    if (message.amount !== undefined) {
      writer.uint32(18).bytes(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokensPayment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokensPayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenIdentifier = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokensPayment {
    return {
      tokenIdentifier: isSet(object.tokenIdentifier) ? bytesFromBase64(object.tokenIdentifier) : undefined,
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : undefined,
    };
  },

  toJSON(message: TokensPayment): unknown {
    const obj: any = {};
    if (message.tokenIdentifier !== undefined) {
      obj.tokenIdentifier = base64FromBytes(message.tokenIdentifier);
    }
    if (message.amount !== undefined) {
      obj.amount = base64FromBytes(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<TokensPayment>): TokensPayment {
    return TokensPayment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokensPayment>): TokensPayment {
    const message = createBaseTokensPayment();
    message.tokenIdentifier = object.tokenIdentifier ?? undefined;
    message.amount = object.amount ?? undefined;
    return message;
  },
};

function createBaseInitiateStaticDepositUtxoRefundRequest(): InitiateStaticDepositUtxoRefundRequest {
  return { onChainUtxo: undefined, refundTxSigningJob: undefined, userSignature: new Uint8Array(0) };
}

export const InitiateStaticDepositUtxoRefundRequest: MessageFns<InitiateStaticDepositUtxoRefundRequest> = {
  encode(message: InitiateStaticDepositUtxoRefundRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.onChainUtxo !== undefined) {
      UTXO.encode(message.onChainUtxo, writer.uint32(10).fork()).join();
    }
    if (message.refundTxSigningJob !== undefined) {
      SigningJob.encode(message.refundTxSigningJob, writer.uint32(26).fork()).join();
    }
    if (message.userSignature.length !== 0) {
      writer.uint32(34).bytes(message.userSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateStaticDepositUtxoRefundRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateStaticDepositUtxoRefundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.onChainUtxo = UTXO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateStaticDepositUtxoRefundRequest {
    return {
      onChainUtxo: isSet(object.onChainUtxo) ? UTXO.fromJSON(object.onChainUtxo) : undefined,
      refundTxSigningJob: isSet(object.refundTxSigningJob) ? SigningJob.fromJSON(object.refundTxSigningJob) : undefined,
      userSignature: isSet(object.userSignature) ? bytesFromBase64(object.userSignature) : new Uint8Array(0),
    };
  },

  toJSON(message: InitiateStaticDepositUtxoRefundRequest): unknown {
    const obj: any = {};
    if (message.onChainUtxo !== undefined) {
      obj.onChainUtxo = UTXO.toJSON(message.onChainUtxo);
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
    }
    if (message.userSignature.length !== 0) {
      obj.userSignature = base64FromBytes(message.userSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<InitiateStaticDepositUtxoRefundRequest>): InitiateStaticDepositUtxoRefundRequest {
    return InitiateStaticDepositUtxoRefundRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitiateStaticDepositUtxoRefundRequest>): InitiateStaticDepositUtxoRefundRequest {
    const message = createBaseInitiateStaticDepositUtxoRefundRequest();
    message.onChainUtxo = (object.onChainUtxo !== undefined && object.onChainUtxo !== null)
      ? UTXO.fromPartial(object.onChainUtxo)
      : undefined;
    message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
      ? SigningJob.fromPartial(object.refundTxSigningJob)
      : undefined;
    message.userSignature = object.userSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseInitiateStaticDepositUtxoRefundResponse(): InitiateStaticDepositUtxoRefundResponse {
  return { refundTxSigningResult: undefined, depositAddress: undefined };
}

export const InitiateStaticDepositUtxoRefundResponse: MessageFns<InitiateStaticDepositUtxoRefundResponse> = {
  encode(message: InitiateStaticDepositUtxoRefundResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refundTxSigningResult !== undefined) {
      SigningResult.encode(message.refundTxSigningResult, writer.uint32(10).fork()).join();
    }
    if (message.depositAddress !== undefined) {
      DepositAddressQueryResult.encode(message.depositAddress, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateStaticDepositUtxoRefundResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateStaticDepositUtxoRefundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.depositAddress = DepositAddressQueryResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateStaticDepositUtxoRefundResponse {
    return {
      refundTxSigningResult: isSet(object.refundTxSigningResult)
        ? SigningResult.fromJSON(object.refundTxSigningResult)
        : undefined,
      depositAddress: isSet(object.depositAddress)
        ? DepositAddressQueryResult.fromJSON(object.depositAddress)
        : undefined,
    };
  },

  toJSON(message: InitiateStaticDepositUtxoRefundResponse): unknown {
    const obj: any = {};
    if (message.refundTxSigningResult !== undefined) {
      obj.refundTxSigningResult = SigningResult.toJSON(message.refundTxSigningResult);
    }
    if (message.depositAddress !== undefined) {
      obj.depositAddress = DepositAddressQueryResult.toJSON(message.depositAddress);
    }
    return obj;
  },

  create(base?: DeepPartial<InitiateStaticDepositUtxoRefundResponse>): InitiateStaticDepositUtxoRefundResponse {
    return InitiateStaticDepositUtxoRefundResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitiateStaticDepositUtxoRefundResponse>): InitiateStaticDepositUtxoRefundResponse {
    const message = createBaseInitiateStaticDepositUtxoRefundResponse();
    message.refundTxSigningResult =
      (object.refundTxSigningResult !== undefined && object.refundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.refundTxSigningResult)
        : undefined;
    message.depositAddress = (object.depositAddress !== undefined && object.depositAddress !== null)
      ? DepositAddressQueryResult.fromPartial(object.depositAddress)
      : undefined;
    return message;
  },
};

function createBaseInitiateUtxoSwapRequest(): InitiateUtxoSwapRequest {
  return {
    onChainUtxo: undefined,
    requestType: 0,
    amount: undefined,
    sspSignature: new Uint8Array(0),
    userSignature: new Uint8Array(0),
    transfer: undefined,
    spendTxSigningJob: undefined,
  };
}

export const InitiateUtxoSwapRequest: MessageFns<InitiateUtxoSwapRequest> = {
  encode(message: InitiateUtxoSwapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.onChainUtxo !== undefined) {
      UTXO.encode(message.onChainUtxo, writer.uint32(10).fork()).join();
    }
    if (message.requestType !== 0) {
      writer.uint32(16).int32(message.requestType);
    }
    switch (message.amount?.$case) {
      case "creditAmountSats":
        writer.uint32(24).uint64(message.amount.creditAmountSats);
        break;
      case "maxFeeSats":
        writer.uint32(32).uint64(message.amount.maxFeeSats);
        break;
    }
    if (message.sspSignature.length !== 0) {
      writer.uint32(42).bytes(message.sspSignature);
    }
    if (message.userSignature.length !== 0) {
      writer.uint32(50).bytes(message.userSignature);
    }
    if (message.transfer !== undefined) {
      StartTransferRequest.encode(message.transfer, writer.uint32(58).fork()).join();
    }
    if (message.spendTxSigningJob !== undefined) {
      SigningJob.encode(message.spendTxSigningJob, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateUtxoSwapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateUtxoSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.onChainUtxo = UTXO.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.requestType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = { $case: "creditAmountSats", creditAmountSats: longToNumber(reader.uint64()) };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amount = { $case: "maxFeeSats", maxFeeSats: longToNumber(reader.uint64()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sspSignature = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userSignature = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.transfer = StartTransferRequest.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.spendTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateUtxoSwapRequest {
    return {
      onChainUtxo: isSet(object.onChainUtxo) ? UTXO.fromJSON(object.onChainUtxo) : undefined,
      requestType: isSet(object.requestType) ? utxoSwapRequestTypeFromJSON(object.requestType) : 0,
      amount: isSet(object.creditAmountSats)
        ? { $case: "creditAmountSats", creditAmountSats: globalThis.Number(object.creditAmountSats) }
        : isSet(object.maxFeeSats)
        ? { $case: "maxFeeSats", maxFeeSats: globalThis.Number(object.maxFeeSats) }
        : undefined,
      sspSignature: isSet(object.sspSignature) ? bytesFromBase64(object.sspSignature) : new Uint8Array(0),
      userSignature: isSet(object.userSignature) ? bytesFromBase64(object.userSignature) : new Uint8Array(0),
      transfer: isSet(object.transfer) ? StartTransferRequest.fromJSON(object.transfer) : undefined,
      spendTxSigningJob: isSet(object.spendTxSigningJob) ? SigningJob.fromJSON(object.spendTxSigningJob) : undefined,
    };
  },

  toJSON(message: InitiateUtxoSwapRequest): unknown {
    const obj: any = {};
    if (message.onChainUtxo !== undefined) {
      obj.onChainUtxo = UTXO.toJSON(message.onChainUtxo);
    }
    if (message.requestType !== 0) {
      obj.requestType = utxoSwapRequestTypeToJSON(message.requestType);
    }
    if (message.amount?.$case === "creditAmountSats") {
      obj.creditAmountSats = Math.round(message.amount.creditAmountSats);
    } else if (message.amount?.$case === "maxFeeSats") {
      obj.maxFeeSats = Math.round(message.amount.maxFeeSats);
    }
    if (message.sspSignature.length !== 0) {
      obj.sspSignature = base64FromBytes(message.sspSignature);
    }
    if (message.userSignature.length !== 0) {
      obj.userSignature = base64FromBytes(message.userSignature);
    }
    if (message.transfer !== undefined) {
      obj.transfer = StartTransferRequest.toJSON(message.transfer);
    }
    if (message.spendTxSigningJob !== undefined) {
      obj.spendTxSigningJob = SigningJob.toJSON(message.spendTxSigningJob);
    }
    return obj;
  },

  create(base?: DeepPartial<InitiateUtxoSwapRequest>): InitiateUtxoSwapRequest {
    return InitiateUtxoSwapRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitiateUtxoSwapRequest>): InitiateUtxoSwapRequest {
    const message = createBaseInitiateUtxoSwapRequest();
    message.onChainUtxo = (object.onChainUtxo !== undefined && object.onChainUtxo !== null)
      ? UTXO.fromPartial(object.onChainUtxo)
      : undefined;
    message.requestType = object.requestType ?? 0;
    switch (object.amount?.$case) {
      case "creditAmountSats": {
        if (object.amount?.creditAmountSats !== undefined && object.amount?.creditAmountSats !== null) {
          message.amount = { $case: "creditAmountSats", creditAmountSats: object.amount.creditAmountSats };
        }
        break;
      }
      case "maxFeeSats": {
        if (object.amount?.maxFeeSats !== undefined && object.amount?.maxFeeSats !== null) {
          message.amount = { $case: "maxFeeSats", maxFeeSats: object.amount.maxFeeSats };
        }
        break;
      }
    }
    message.sspSignature = object.sspSignature ?? new Uint8Array(0);
    message.userSignature = object.userSignature ?? new Uint8Array(0);
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? StartTransferRequest.fromPartial(object.transfer)
      : undefined;
    message.spendTxSigningJob = (object.spendTxSigningJob !== undefined && object.spendTxSigningJob !== null)
      ? SigningJob.fromPartial(object.spendTxSigningJob)
      : undefined;
    return message;
  },
};

function createBaseInitiateUtxoSwapResponse(): InitiateUtxoSwapResponse {
  return { spendTxSigningResult: undefined, transfer: undefined, depositAddress: undefined };
}

export const InitiateUtxoSwapResponse: MessageFns<InitiateUtxoSwapResponse> = {
  encode(message: InitiateUtxoSwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.spendTxSigningResult !== undefined) {
      SigningResult.encode(message.spendTxSigningResult, writer.uint32(10).fork()).join();
    }
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(18).fork()).join();
    }
    if (message.depositAddress !== undefined) {
      DepositAddressQueryResult.encode(message.depositAddress, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateUtxoSwapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateUtxoSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.spendTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.depositAddress = DepositAddressQueryResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateUtxoSwapResponse {
    return {
      spendTxSigningResult: isSet(object.spendTxSigningResult)
        ? SigningResult.fromJSON(object.spendTxSigningResult)
        : undefined,
      transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined,
      depositAddress: isSet(object.depositAddress)
        ? DepositAddressQueryResult.fromJSON(object.depositAddress)
        : undefined,
    };
  },

  toJSON(message: InitiateUtxoSwapResponse): unknown {
    const obj: any = {};
    if (message.spendTxSigningResult !== undefined) {
      obj.spendTxSigningResult = SigningResult.toJSON(message.spendTxSigningResult);
    }
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    if (message.depositAddress !== undefined) {
      obj.depositAddress = DepositAddressQueryResult.toJSON(message.depositAddress);
    }
    return obj;
  },

  create(base?: DeepPartial<InitiateUtxoSwapResponse>): InitiateUtxoSwapResponse {
    return InitiateUtxoSwapResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitiateUtxoSwapResponse>): InitiateUtxoSwapResponse {
    const message = createBaseInitiateUtxoSwapResponse();
    message.spendTxSigningResult = (object.spendTxSigningResult !== undefined && object.spendTxSigningResult !== null)
      ? SigningResult.fromPartial(object.spendTxSigningResult)
      : undefined;
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    message.depositAddress = (object.depositAddress !== undefined && object.depositAddress !== null)
      ? DepositAddressQueryResult.fromPartial(object.depositAddress)
      : undefined;
    return message;
  },
};

function createBaseExitingTree(): ExitingTree {
  return { treeId: "", userSigningCommitment: undefined, vin: 0 };
}

export const ExitingTree: MessageFns<ExitingTree> = {
  encode(message: ExitingTree, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.treeId !== "") {
      writer.uint32(10).string(message.treeId);
    }
    if (message.userSigningCommitment !== undefined) {
      SigningCommitment.encode(message.userSigningCommitment, writer.uint32(18).fork()).join();
    }
    if (message.vin !== 0) {
      writer.uint32(24).uint32(message.vin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExitingTree {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExitingTree();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.treeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userSigningCommitment = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.vin = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExitingTree {
    return {
      treeId: isSet(object.treeId) ? globalThis.String(object.treeId) : "",
      userSigningCommitment: isSet(object.userSigningCommitment)
        ? SigningCommitment.fromJSON(object.userSigningCommitment)
        : undefined,
      vin: isSet(object.vin) ? globalThis.Number(object.vin) : 0,
    };
  },

  toJSON(message: ExitingTree): unknown {
    const obj: any = {};
    if (message.treeId !== "") {
      obj.treeId = message.treeId;
    }
    if (message.userSigningCommitment !== undefined) {
      obj.userSigningCommitment = SigningCommitment.toJSON(message.userSigningCommitment);
    }
    if (message.vin !== 0) {
      obj.vin = Math.round(message.vin);
    }
    return obj;
  },

  create(base?: DeepPartial<ExitingTree>): ExitingTree {
    return ExitingTree.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExitingTree>): ExitingTree {
    const message = createBaseExitingTree();
    message.treeId = object.treeId ?? "";
    message.userSigningCommitment =
      (object.userSigningCommitment !== undefined && object.userSigningCommitment !== null)
        ? SigningCommitment.fromPartial(object.userSigningCommitment)
        : undefined;
    message.vin = object.vin ?? 0;
    return message;
  },
};

function createBaseExitSingleNodeTreeSigningResult(): ExitSingleNodeTreeSigningResult {
  return { treeId: "", signingResult: undefined, verifyingKey: new Uint8Array(0) };
}

export const ExitSingleNodeTreeSigningResult: MessageFns<ExitSingleNodeTreeSigningResult> = {
  encode(message: ExitSingleNodeTreeSigningResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.treeId !== "") {
      writer.uint32(10).string(message.treeId);
    }
    if (message.signingResult !== undefined) {
      SigningResult.encode(message.signingResult, writer.uint32(18).fork()).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(26).bytes(message.verifyingKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExitSingleNodeTreeSigningResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExitSingleNodeTreeSigningResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.treeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExitSingleNodeTreeSigningResult {
    return {
      treeId: isSet(object.treeId) ? globalThis.String(object.treeId) : "",
      signingResult: isSet(object.signingResult) ? SigningResult.fromJSON(object.signingResult) : undefined,
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
    };
  },

  toJSON(message: ExitSingleNodeTreeSigningResult): unknown {
    const obj: any = {};
    if (message.treeId !== "") {
      obj.treeId = message.treeId;
    }
    if (message.signingResult !== undefined) {
      obj.signingResult = SigningResult.toJSON(message.signingResult);
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    return obj;
  },

  create(base?: DeepPartial<ExitSingleNodeTreeSigningResult>): ExitSingleNodeTreeSigningResult {
    return ExitSingleNodeTreeSigningResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExitSingleNodeTreeSigningResult>): ExitSingleNodeTreeSigningResult {
    const message = createBaseExitSingleNodeTreeSigningResult();
    message.treeId = object.treeId ?? "";
    message.signingResult = (object.signingResult !== undefined && object.signingResult !== null)
      ? SigningResult.fromPartial(object.signingResult)
      : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBitcoinTransactionOutput(): BitcoinTransactionOutput {
  return { value: 0, pkScript: new Uint8Array(0) };
}

export const BitcoinTransactionOutput: MessageFns<BitcoinTransactionOutput> = {
  encode(message: BitcoinTransactionOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).int64(message.value);
    }
    if (message.pkScript.length !== 0) {
      writer.uint32(18).bytes(message.pkScript);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BitcoinTransactionOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBitcoinTransactionOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pkScript = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BitcoinTransactionOutput {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      pkScript: isSet(object.pkScript) ? bytesFromBase64(object.pkScript) : new Uint8Array(0),
    };
  },

  toJSON(message: BitcoinTransactionOutput): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.pkScript.length !== 0) {
      obj.pkScript = base64FromBytes(message.pkScript);
    }
    return obj;
  },

  create(base?: DeepPartial<BitcoinTransactionOutput>): BitcoinTransactionOutput {
    return BitcoinTransactionOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BitcoinTransactionOutput>): BitcoinTransactionOutput {
    const message = createBaseBitcoinTransactionOutput();
    message.value = object.value ?? 0;
    message.pkScript = object.pkScript ?? new Uint8Array(0);
    return message;
  },
};

function createBaseExitSingleNodeTreesRequest(): ExitSingleNodeTreesRequest {
  return { ownerIdentityPublicKey: new Uint8Array(0), exitingTrees: [], rawTx: new Uint8Array(0), previousOutputs: [] };
}

export const ExitSingleNodeTreesRequest: MessageFns<ExitSingleNodeTreesRequest> = {
  encode(message: ExitSingleNodeTreesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.exitingTrees) {
      ExitingTree.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.rawTx.length !== 0) {
      writer.uint32(26).bytes(message.rawTx);
    }
    for (const v of message.previousOutputs) {
      BitcoinTransactionOutput.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExitSingleNodeTreesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExitSingleNodeTreesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exitingTrees.push(ExitingTree.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rawTx = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.previousOutputs.push(BitcoinTransactionOutput.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExitSingleNodeTreesRequest {
    return {
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      exitingTrees: globalThis.Array.isArray(object?.exitingTrees)
        ? object.exitingTrees.map((e: any) => ExitingTree.fromJSON(e))
        : [],
      rawTx: isSet(object.rawTx) ? bytesFromBase64(object.rawTx) : new Uint8Array(0),
      previousOutputs: globalThis.Array.isArray(object?.previousOutputs)
        ? object.previousOutputs.map((e: any) => BitcoinTransactionOutput.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExitSingleNodeTreesRequest): unknown {
    const obj: any = {};
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.exitingTrees?.length) {
      obj.exitingTrees = message.exitingTrees.map((e) => ExitingTree.toJSON(e));
    }
    if (message.rawTx.length !== 0) {
      obj.rawTx = base64FromBytes(message.rawTx);
    }
    if (message.previousOutputs?.length) {
      obj.previousOutputs = message.previousOutputs.map((e) => BitcoinTransactionOutput.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ExitSingleNodeTreesRequest>): ExitSingleNodeTreesRequest {
    return ExitSingleNodeTreesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExitSingleNodeTreesRequest>): ExitSingleNodeTreesRequest {
    const message = createBaseExitSingleNodeTreesRequest();
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.exitingTrees = object.exitingTrees?.map((e) => ExitingTree.fromPartial(e)) || [];
    message.rawTx = object.rawTx ?? new Uint8Array(0);
    message.previousOutputs = object.previousOutputs?.map((e) => BitcoinTransactionOutput.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExitSingleNodeTreesResponse(): ExitSingleNodeTreesResponse {
  return { signingResults: [] };
}

export const ExitSingleNodeTreesResponse: MessageFns<ExitSingleNodeTreesResponse> = {
  encode(message: ExitSingleNodeTreesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signingResults) {
      ExitSingleNodeTreeSigningResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExitSingleNodeTreesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExitSingleNodeTreesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingResults.push(ExitSingleNodeTreeSigningResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExitSingleNodeTreesResponse {
    return {
      signingResults: globalThis.Array.isArray(object?.signingResults)
        ? object.signingResults.map((e: any) => ExitSingleNodeTreeSigningResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExitSingleNodeTreesResponse): unknown {
    const obj: any = {};
    if (message.signingResults?.length) {
      obj.signingResults = message.signingResults.map((e) => ExitSingleNodeTreeSigningResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ExitSingleNodeTreesResponse>): ExitSingleNodeTreesResponse {
    return ExitSingleNodeTreesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExitSingleNodeTreesResponse>): ExitSingleNodeTreesResponse {
    const message = createBaseExitSingleNodeTreesResponse();
    message.signingResults = object.signingResults?.map((e) => ExitSingleNodeTreeSigningResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInvestigateLeavesRequest(): InvestigateLeavesRequest {
  return { leafIds: [], ownerIdentityPublicKey: new Uint8Array(0), transferId: "" };
}

export const InvestigateLeavesRequest: MessageFns<InvestigateLeavesRequest> = {
  encode(message: InvestigateLeavesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.leafIds) {
      writer.uint32(10).string(v!);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    if (message.transferId !== "") {
      writer.uint32(26).string(message.transferId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvestigateLeavesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvestigateLeavesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvestigateLeavesRequest {
    return {
      leafIds: globalThis.Array.isArray(object?.leafIds) ? object.leafIds.map((e: any) => globalThis.String(e)) : [],
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
    };
  },

  toJSON(message: InvestigateLeavesRequest): unknown {
    const obj: any = {};
    if (message.leafIds?.length) {
      obj.leafIds = message.leafIds;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    return obj;
  },

  create(base?: DeepPartial<InvestigateLeavesRequest>): InvestigateLeavesRequest {
    return InvestigateLeavesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvestigateLeavesRequest>): InvestigateLeavesRequest {
    const message = createBaseInvestigateLeavesRequest();
    message.leafIds = object.leafIds?.map((e) => e) || [];
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.transferId = object.transferId ?? "";
    return message;
  },
};

function createBaseQueryNodesDistributionRequest(): QueryNodesDistributionRequest {
  return { ownerIdentityPublicKey: new Uint8Array(0) };
}

export const QueryNodesDistributionRequest: MessageFns<QueryNodesDistributionRequest> = {
  encode(message: QueryNodesDistributionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.ownerIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryNodesDistributionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNodesDistributionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNodesDistributionRequest {
    return {
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: QueryNodesDistributionRequest): unknown {
    const obj: any = {};
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryNodesDistributionRequest>): QueryNodesDistributionRequest {
    return QueryNodesDistributionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryNodesDistributionRequest>): QueryNodesDistributionRequest {
    const message = createBaseQueryNodesDistributionRequest();
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryNodesDistributionResponse(): QueryNodesDistributionResponse {
  return { nodeDistribution: {} };
}

export const QueryNodesDistributionResponse: MessageFns<QueryNodesDistributionResponse> = {
  encode(message: QueryNodesDistributionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.nodeDistribution).forEach(([key, value]) => {
      QueryNodesDistributionResponse_NodeDistributionEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryNodesDistributionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNodesDistributionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = QueryNodesDistributionResponse_NodeDistributionEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.nodeDistribution[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNodesDistributionResponse {
    return {
      nodeDistribution: isObject(object.nodeDistribution)
        ? Object.entries(object.nodeDistribution).reduce<{ [key: number]: number }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: QueryNodesDistributionResponse): unknown {
    const obj: any = {};
    if (message.nodeDistribution) {
      const entries = Object.entries(message.nodeDistribution);
      if (entries.length > 0) {
        obj.nodeDistribution = {};
        entries.forEach(([k, v]) => {
          obj.nodeDistribution[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<QueryNodesDistributionResponse>): QueryNodesDistributionResponse {
    return QueryNodesDistributionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryNodesDistributionResponse>): QueryNodesDistributionResponse {
    const message = createBaseQueryNodesDistributionResponse();
    message.nodeDistribution = Object.entries(object.nodeDistribution ?? {}).reduce<{ [key: number]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseQueryNodesDistributionResponse_NodeDistributionEntry(): QueryNodesDistributionResponse_NodeDistributionEntry {
  return { key: 0, value: 0 };
}

export const QueryNodesDistributionResponse_NodeDistributionEntry: MessageFns<
  QueryNodesDistributionResponse_NodeDistributionEntry
> = {
  encode(
    message: QueryNodesDistributionResponse_NodeDistributionEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).uint64(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryNodesDistributionResponse_NodeDistributionEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNodesDistributionResponse_NodeDistributionEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNodesDistributionResponse_NodeDistributionEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: QueryNodesDistributionResponse_NodeDistributionEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<QueryNodesDistributionResponse_NodeDistributionEntry>,
  ): QueryNodesDistributionResponse_NodeDistributionEntry {
    return QueryNodesDistributionResponse_NodeDistributionEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<QueryNodesDistributionResponse_NodeDistributionEntry>,
  ): QueryNodesDistributionResponse_NodeDistributionEntry {
    const message = createBaseQueryNodesDistributionResponse_NodeDistributionEntry();
    message.key = object.key ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseQueryNodesByValueRequest(): QueryNodesByValueRequest {
  return { ownerIdentityPublicKey: new Uint8Array(0), value: 0, offset: 0, limit: 0 };
}

export const QueryNodesByValueRequest: MessageFns<QueryNodesByValueRequest> = {
  encode(message: QueryNodesByValueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.ownerIdentityPublicKey);
    }
    if (message.value !== 0) {
      writer.uint32(16).int64(message.value);
    }
    if (message.offset !== 0) {
      writer.uint32(24).int64(message.offset);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int64(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryNodesByValueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNodesByValueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNodesByValueRequest {
    return {
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: QueryNodesByValueRequest): unknown {
    const obj: any = {};
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryNodesByValueRequest>): QueryNodesByValueRequest {
    return QueryNodesByValueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryNodesByValueRequest>): QueryNodesByValueRequest {
    const message = createBaseQueryNodesByValueRequest();
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.value = object.value ?? 0;
    message.offset = object.offset ?? 0;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseQueryNodesByValueResponse(): QueryNodesByValueResponse {
  return { nodes: {}, offset: 0 };
}

export const QueryNodesByValueResponse: MessageFns<QueryNodesByValueResponse> = {
  encode(message: QueryNodesByValueResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.nodes).forEach(([key, value]) => {
      QueryNodesByValueResponse_NodesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.offset !== 0) {
      writer.uint32(16).int64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryNodesByValueResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNodesByValueResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = QueryNodesByValueResponse_NodesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.nodes[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNodesByValueResponse {
    return {
      nodes: isObject(object.nodes)
        ? Object.entries(object.nodes).reduce<{ [key: string]: TreeNode }>((acc, [key, value]) => {
          acc[key] = TreeNode.fromJSON(value);
          return acc;
        }, {})
        : {},
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: QueryNodesByValueResponse): unknown {
    const obj: any = {};
    if (message.nodes) {
      const entries = Object.entries(message.nodes);
      if (entries.length > 0) {
        obj.nodes = {};
        entries.forEach(([k, v]) => {
          obj.nodes[k] = TreeNode.toJSON(v);
        });
      }
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryNodesByValueResponse>): QueryNodesByValueResponse {
    return QueryNodesByValueResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryNodesByValueResponse>): QueryNodesByValueResponse {
    const message = createBaseQueryNodesByValueResponse();
    message.nodes = Object.entries(object.nodes ?? {}).reduce<{ [key: string]: TreeNode }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = TreeNode.fromPartial(value);
      }
      return acc;
    }, {});
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseQueryNodesByValueResponse_NodesEntry(): QueryNodesByValueResponse_NodesEntry {
  return { key: "", value: undefined };
}

export const QueryNodesByValueResponse_NodesEntry: MessageFns<QueryNodesByValueResponse_NodesEntry> = {
  encode(message: QueryNodesByValueResponse_NodesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TreeNode.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryNodesByValueResponse_NodesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNodesByValueResponse_NodesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = TreeNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNodesByValueResponse_NodesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? TreeNode.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: QueryNodesByValueResponse_NodesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = TreeNode.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryNodesByValueResponse_NodesEntry>): QueryNodesByValueResponse_NodesEntry {
    return QueryNodesByValueResponse_NodesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryNodesByValueResponse_NodesEntry>): QueryNodesByValueResponse_NodesEntry {
    const message = createBaseQueryNodesByValueResponse_NodesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TreeNode.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGetUtxosForAddressRequest(): GetUtxosForAddressRequest {
  return { address: "", offset: 0, limit: 0, network: 0, excludeClaimed: false };
}

export const GetUtxosForAddressRequest: MessageFns<GetUtxosForAddressRequest> = {
  encode(message: GetUtxosForAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint64(message.offset);
    }
    if (message.limit !== 0) {
      writer.uint32(24).uint64(message.limit);
    }
    if (message.network !== 0) {
      writer.uint32(32).int32(message.network);
    }
    if (message.excludeClaimed !== false) {
      writer.uint32(40).bool(message.excludeClaimed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUtxosForAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUtxosForAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.excludeClaimed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUtxosForAddressRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
      excludeClaimed: isSet(object.excludeClaimed) ? globalThis.Boolean(object.excludeClaimed) : false,
    };
  },

  toJSON(message: GetUtxosForAddressRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    if (message.excludeClaimed !== false) {
      obj.excludeClaimed = message.excludeClaimed;
    }
    return obj;
  },

  create(base?: DeepPartial<GetUtxosForAddressRequest>): GetUtxosForAddressRequest {
    return GetUtxosForAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUtxosForAddressRequest>): GetUtxosForAddressRequest {
    const message = createBaseGetUtxosForAddressRequest();
    message.address = object.address ?? "";
    message.offset = object.offset ?? 0;
    message.limit = object.limit ?? 0;
    message.network = object.network ?? 0;
    message.excludeClaimed = object.excludeClaimed ?? false;
    return message;
  },
};

function createBaseGetUtxosForAddressResponse(): GetUtxosForAddressResponse {
  return { utxos: [], offset: 0 };
}

export const GetUtxosForAddressResponse: MessageFns<GetUtxosForAddressResponse> = {
  encode(message: GetUtxosForAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.utxos) {
      UTXO.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUtxosForAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUtxosForAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.utxos.push(UTXO.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUtxosForAddressResponse {
    return {
      utxos: globalThis.Array.isArray(object?.utxos) ? object.utxos.map((e: any) => UTXO.fromJSON(e)) : [],
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: GetUtxosForAddressResponse): unknown {
    const obj: any = {};
    if (message.utxos?.length) {
      obj.utxos = message.utxos.map((e) => UTXO.toJSON(e));
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create(base?: DeepPartial<GetUtxosForAddressResponse>): GetUtxosForAddressResponse {
    return GetUtxosForAddressResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUtxosForAddressResponse>): GetUtxosForAddressResponse {
    const message = createBaseGetUtxosForAddressResponse();
    message.utxos = object.utxos?.map((e) => UTXO.fromPartial(e)) || [];
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseQuerySparkInvoicesRequest(): QuerySparkInvoicesRequest {
  return { limit: 0, offset: 0, invoice: [] };
}

export const QuerySparkInvoicesRequest: MessageFns<QuerySparkInvoicesRequest> = {
  encode(message: QuerySparkInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.limit !== 0) {
      writer.uint32(8).int64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(16).int64(message.offset);
    }
    for (const v of message.invoice) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySparkInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySparkInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.limit = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.invoice.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySparkInvoicesRequest {
    return {
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      invoice: globalThis.Array.isArray(object?.invoice) ? object.invoice.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: QuerySparkInvoicesRequest): unknown {
    const obj: any = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.invoice?.length) {
      obj.invoice = message.invoice;
    }
    return obj;
  },

  create(base?: DeepPartial<QuerySparkInvoicesRequest>): QuerySparkInvoicesRequest {
    return QuerySparkInvoicesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuerySparkInvoicesRequest>): QuerySparkInvoicesRequest {
    const message = createBaseQuerySparkInvoicesRequest();
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.invoice = object.invoice?.map((e) => e) || [];
    return message;
  },
};

function createBaseQuerySparkInvoicesResponse(): QuerySparkInvoicesResponse {
  return { offset: 0, invoiceStatuses: [] };
}

export const QuerySparkInvoicesResponse: MessageFns<QuerySparkInvoicesResponse> = {
  encode(message: QuerySparkInvoicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== 0) {
      writer.uint32(8).int64(message.offset);
    }
    for (const v of message.invoiceStatuses) {
      InvoiceResponse.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySparkInvoicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySparkInvoicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.invoiceStatuses.push(InvoiceResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySparkInvoicesResponse {
    return {
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      invoiceStatuses: globalThis.Array.isArray(object?.invoiceStatuses)
        ? object.invoiceStatuses.map((e: any) => InvoiceResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QuerySparkInvoicesResponse): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.invoiceStatuses?.length) {
      obj.invoiceStatuses = message.invoiceStatuses.map((e) => InvoiceResponse.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QuerySparkInvoicesResponse>): QuerySparkInvoicesResponse {
    return QuerySparkInvoicesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuerySparkInvoicesResponse>): QuerySparkInvoicesResponse {
    const message = createBaseQuerySparkInvoicesResponse();
    message.offset = object.offset ?? 0;
    message.invoiceStatuses = object.invoiceStatuses?.map((e) => InvoiceResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInvoiceResponse(): InvoiceResponse {
  return { invoice: "", status: 0, transferType: undefined };
}

export const InvoiceResponse: MessageFns<InvoiceResponse> = {
  encode(message: InvoiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invoice !== "") {
      writer.uint32(10).string(message.invoice);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    switch (message.transferType?.$case) {
      case "satsTransfer":
        SatsTransfer.encode(message.transferType.satsTransfer, writer.uint32(26).fork()).join();
        break;
      case "tokenTransfer":
        TokenTransfer.encode(message.transferType.tokenTransfer, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvoiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvoiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invoice = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transferType = { $case: "satsTransfer", satsTransfer: SatsTransfer.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.transferType = {
            $case: "tokenTransfer",
            tokenTransfer: TokenTransfer.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvoiceResponse {
    return {
      invoice: isSet(object.invoice) ? globalThis.String(object.invoice) : "",
      status: isSet(object.status) ? invoiceStatusFromJSON(object.status) : 0,
      transferType: isSet(object.satsTransfer)
        ? { $case: "satsTransfer", satsTransfer: SatsTransfer.fromJSON(object.satsTransfer) }
        : isSet(object.tokenTransfer)
        ? { $case: "tokenTransfer", tokenTransfer: TokenTransfer.fromJSON(object.tokenTransfer) }
        : undefined,
    };
  },

  toJSON(message: InvoiceResponse): unknown {
    const obj: any = {};
    if (message.invoice !== "") {
      obj.invoice = message.invoice;
    }
    if (message.status !== 0) {
      obj.status = invoiceStatusToJSON(message.status);
    }
    if (message.transferType?.$case === "satsTransfer") {
      obj.satsTransfer = SatsTransfer.toJSON(message.transferType.satsTransfer);
    } else if (message.transferType?.$case === "tokenTransfer") {
      obj.tokenTransfer = TokenTransfer.toJSON(message.transferType.tokenTransfer);
    }
    return obj;
  },

  create(base?: DeepPartial<InvoiceResponse>): InvoiceResponse {
    return InvoiceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvoiceResponse>): InvoiceResponse {
    const message = createBaseInvoiceResponse();
    message.invoice = object.invoice ?? "";
    message.status = object.status ?? 0;
    switch (object.transferType?.$case) {
      case "satsTransfer": {
        if (object.transferType?.satsTransfer !== undefined && object.transferType?.satsTransfer !== null) {
          message.transferType = {
            $case: "satsTransfer",
            satsTransfer: SatsTransfer.fromPartial(object.transferType.satsTransfer),
          };
        }
        break;
      }
      case "tokenTransfer": {
        if (object.transferType?.tokenTransfer !== undefined && object.transferType?.tokenTransfer !== null) {
          message.transferType = {
            $case: "tokenTransfer",
            tokenTransfer: TokenTransfer.fromPartial(object.transferType.tokenTransfer),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseSatsTransfer(): SatsTransfer {
  return { transferId: new Uint8Array(0) };
}

export const SatsTransfer: MessageFns<SatsTransfer> = {
  encode(message: SatsTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId.length !== 0) {
      writer.uint32(10).bytes(message.transferId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SatsTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSatsTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SatsTransfer {
    return { transferId: isSet(object.transferId) ? bytesFromBase64(object.transferId) : new Uint8Array(0) };
  },

  toJSON(message: SatsTransfer): unknown {
    const obj: any = {};
    if (message.transferId.length !== 0) {
      obj.transferId = base64FromBytes(message.transferId);
    }
    return obj;
  },

  create(base?: DeepPartial<SatsTransfer>): SatsTransfer {
    return SatsTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SatsTransfer>): SatsTransfer {
    const message = createBaseSatsTransfer();
    message.transferId = object.transferId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTokenTransfer(): TokenTransfer {
  return { finalTokenTransactionHash: new Uint8Array(0) };
}

export const TokenTransfer: MessageFns<TokenTransfer> = {
  encode(message: TokenTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.finalTokenTransactionHash.length !== 0) {
      writer.uint32(10).bytes(message.finalTokenTransactionHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.finalTokenTransactionHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenTransfer {
    return {
      finalTokenTransactionHash: isSet(object.finalTokenTransactionHash)
        ? bytesFromBase64(object.finalTokenTransactionHash)
        : new Uint8Array(0),
    };
  },

  toJSON(message: TokenTransfer): unknown {
    const obj: any = {};
    if (message.finalTokenTransactionHash.length !== 0) {
      obj.finalTokenTransactionHash = base64FromBytes(message.finalTokenTransactionHash);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenTransfer>): TokenTransfer {
    return TokenTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenTransfer>): TokenTransfer {
    const message = createBaseTokenTransfer();
    message.finalTokenTransactionHash = object.finalTokenTransactionHash ?? new Uint8Array(0);
    return message;
  },
};

export type SparkServiceDefinition = typeof SparkServiceDefinition;
export const SparkServiceDefinition = {
  name: "SparkService",
  fullName: "spark.SparkService",
  methods: {
    generate_deposit_address: {
      name: "generate_deposit_address",
      requestType: GenerateDepositAddressRequest,
      requestStream: false,
      responseType: GenerateDepositAddressResponse,
      responseStream: false,
      options: {},
    },
    /** Generates a new static deposit address of the user or returns the existing one for the specified network. */
    generate_static_deposit_address: {
      name: "generate_static_deposit_address",
      requestType: GenerateStaticDepositAddressRequest,
      requestStream: false,
      responseType: GenerateStaticDepositAddressResponse,
      responseStream: false,
      options: {},
    },
    start_deposit_tree_creation: {
      name: "start_deposit_tree_creation",
      requestType: StartDepositTreeCreationRequest,
      requestStream: false,
      responseType: StartDepositTreeCreationResponse,
      responseStream: false,
      options: {},
    },
    /**
     * This is deprecated, please use start_deposit_tree_creation instead.
     *
     * @deprecated
     */
    start_tree_creation: {
      name: "start_tree_creation",
      requestType: StartTreeCreationRequest,
      requestStream: false,
      responseType: StartTreeCreationResponse,
      responseStream: false,
      options: {},
    },
    finalize_node_signatures: {
      name: "finalize_node_signatures",
      requestType: FinalizeNodeSignaturesRequest,
      requestStream: false,
      responseType: FinalizeNodeSignaturesResponse,
      responseStream: false,
      options: {},
    },
    start_transfer: {
      name: "start_transfer",
      requestType: StartTransferRequest,
      requestStream: false,
      responseType: StartTransferResponse,
      responseStream: false,
      options: {},
    },
    /**
     * This is deprecated, please use finalize_transfer_with_transfer_package instead.
     *
     * @deprecated
     */
    finalize_transfer: {
      name: "finalize_transfer",
      requestType: FinalizeTransferRequest,
      requestStream: false,
      responseType: FinalizeTransferResponse,
      responseStream: false,
      options: {},
    },
    finalize_transfer_with_transfer_package: {
      name: "finalize_transfer_with_transfer_package",
      requestType: FinalizeTransferWithTransferPackageRequest,
      requestStream: false,
      responseType: FinalizeTransferResponse,
      responseStream: false,
      options: {},
    },
    cancel_transfer: {
      name: "cancel_transfer",
      requestType: CancelTransferRequest,
      requestStream: false,
      responseType: CancelTransferResponse,
      responseStream: false,
      options: {},
    },
    query_pending_transfers: {
      name: "query_pending_transfers",
      requestType: TransferFilter,
      requestStream: false,
      responseType: QueryTransfersResponse,
      responseStream: false,
      options: {},
    },
    query_all_transfers: {
      name: "query_all_transfers",
      requestType: TransferFilter,
      requestStream: false,
      responseType: QueryTransfersResponse,
      responseStream: false,
      options: {},
    },
    claim_transfer_tweak_keys: {
      name: "claim_transfer_tweak_keys",
      requestType: ClaimTransferTweakKeysRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    claim_transfer_sign_refunds: {
      name: "claim_transfer_sign_refunds",
      requestType: ClaimTransferSignRefundsRequest,
      requestStream: false,
      responseType: ClaimTransferSignRefundsResponse,
      responseStream: false,
      options: {},
    },
    store_preimage_share: {
      name: "store_preimage_share",
      requestType: StorePreimageShareRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    get_signing_commitments: {
      name: "get_signing_commitments",
      requestType: GetSigningCommitmentsRequest,
      requestStream: false,
      responseType: GetSigningCommitmentsResponse,
      responseStream: false,
      options: {},
    },
    cooperative_exit: {
      name: "cooperative_exit",
      requestType: CooperativeExitRequest,
      requestStream: false,
      responseType: CooperativeExitResponse,
      responseStream: false,
      options: {},
    },
    initiate_preimage_swap: {
      name: "initiate_preimage_swap",
      requestType: InitiatePreimageSwapRequest,
      requestStream: false,
      responseType: InitiatePreimageSwapResponse,
      responseStream: false,
      options: {},
    },
    provide_preimage: {
      name: "provide_preimage",
      requestType: ProvidePreimageRequest,
      requestStream: false,
      responseType: ProvidePreimageResponse,
      responseStream: false,
      options: {},
    },
    /**
     * This is the exact same as start_transfer, but expresses to the SO
     * this transfer is specifically for a leaf swap.
     */
    start_leaf_swap: {
      name: "start_leaf_swap",
      requestType: StartTransferRequest,
      requestStream: false,
      responseType: StartTransferResponse,
      responseStream: false,
      options: {},
    },
    /**
     * This is deprecated, please use counter_leaf_swap instead.
     *
     * @deprecated
     */
    leaf_swap: {
      name: "leaf_swap",
      requestType: CounterLeafSwapRequest,
      requestStream: false,
      responseType: CounterLeafSwapResponse,
      responseStream: false,
      options: {},
    },
    /**
     * This is the exact same as start_leaf_swap, but signs with
     * an adaptor public key after a counterparty has begun the swap via start_leaf_swap.
     */
    counter_leaf_swap: {
      name: "counter_leaf_swap",
      requestType: CounterLeafSwapRequest,
      requestStream: false,
      responseType: CounterLeafSwapResponse,
      responseStream: false,
      options: {},
    },
    refresh_timelock: {
      name: "refresh_timelock",
      requestType: RefreshTimelockRequest,
      requestStream: false,
      responseType: RefreshTimelockResponse,
      responseStream: false,
      options: {},
    },
    extend_leaf: {
      name: "extend_leaf",
      requestType: ExtendLeafRequest,
      requestStream: false,
      responseType: ExtendLeafResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Resets the timelocks for a leaf's transactions. Can be used to reset the
     * refund transaction timelock for a leaf (when the node transaction
     * timelock is still > 300) or reset the node and refund transaction
     * timelock. Returns an error if a leaf is not yet eligible to renew the
     * timelocks, see RenewLeafRequest for more details.
     */
    renew_leaf: {
      name: "renew_leaf",
      requestType: RenewLeafRequest,
      requestStream: false,
      responseType: RenewLeafResponse,
      responseStream: false,
      options: {},
    },
    get_signing_operator_list: {
      name: "get_signing_operator_list",
      requestType: Empty,
      requestStream: false,
      responseType: GetSigningOperatorListResponse,
      responseStream: false,
      options: {},
    },
    query_nodes: {
      name: "query_nodes",
      requestType: QueryNodesRequest,
      requestStream: false,
      responseType: QueryNodesResponse,
      responseStream: false,
      options: {},
    },
    query_nodes_distribution: {
      name: "query_nodes_distribution",
      requestType: QueryNodesDistributionRequest,
      requestStream: false,
      responseType: QueryNodesDistributionResponse,
      responseStream: false,
      options: {},
    },
    query_nodes_by_value: {
      name: "query_nodes_by_value",
      requestType: QueryNodesByValueRequest,
      requestStream: false,
      responseType: QueryNodesByValueResponse,
      responseStream: false,
      options: {},
    },
    query_balance: {
      name: "query_balance",
      requestType: QueryBalanceRequest,
      requestStream: false,
      responseType: QueryBalanceResponse,
      responseStream: false,
      options: {},
    },
    query_user_signed_refunds: {
      name: "query_user_signed_refunds",
      requestType: QueryUserSignedRefundsRequest,
      requestStream: false,
      responseType: QueryUserSignedRefundsResponse,
      responseStream: false,
      options: {},
    },
    /** Token RPCs */
    start_token_transaction: {
      name: "start_token_transaction",
      requestType: StartTokenTransactionRequest,
      requestStream: false,
      responseType: StartTokenTransactionResponse,
      responseStream: false,
      options: {},
    },
    sign_token_transaction: {
      name: "sign_token_transaction",
      requestType: SignTokenTransactionRequest,
      requestStream: false,
      responseType: SignTokenTransactionResponse,
      responseStream: false,
      options: {},
    },
    finalize_token_transaction: {
      name: "finalize_token_transaction",
      requestType: FinalizeTokenTransactionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    freeze_tokens: {
      name: "freeze_tokens",
      requestType: FreezeTokensRequest,
      requestStream: false,
      responseType: FreezeTokensResponse,
      responseStream: false,
      options: {},
    },
    query_token_outputs: {
      name: "query_token_outputs",
      requestType: QueryTokenOutputsRequest,
      requestStream: false,
      responseType: QueryTokenOutputsResponse,
      responseStream: false,
      options: {},
    },
    query_token_transactions: {
      name: "query_token_transactions",
      requestType: QueryTokenTransactionsRequest,
      requestStream: false,
      responseType: QueryTokenTransactionsResponse,
      responseStream: false,
      options: {},
    },
    return_lightning_payment: {
      name: "return_lightning_payment",
      requestType: ReturnLightningPaymentRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    query_unused_deposit_addresses: {
      name: "query_unused_deposit_addresses",
      requestType: QueryUnusedDepositAddressesRequest,
      requestStream: false,
      responseType: QueryUnusedDepositAddressesResponse,
      responseStream: false,
      options: {},
    },
    query_static_deposit_addresses: {
      name: "query_static_deposit_addresses",
      requestType: QueryStaticDepositAddressesRequest,
      requestStream: false,
      responseType: QueryStaticDepositAddressesResponse,
      responseStream: false,
      options: {},
    },
    subscribe_to_events: {
      name: "subscribe_to_events",
      requestType: SubscribeToEventsRequest,
      requestStream: false,
      responseType: SubscribeToEventsResponse,
      responseStream: true,
      options: {},
    },
    /**
     * Signs the provided refund transaction which spends the UTXO from a static
     * deposit address. If successful, the UTXO will no longer be available to claim on
     * the Spark network, and the refund transaction must be broadcasted on L1 to claim
     * the funds. Returns an error if the UTXO has already been claimed.
     */
    initiate_static_deposit_utxo_refund: {
      name: "initiate_static_deposit_utxo_refund",
      requestType: InitiateStaticDepositUtxoRefundRequest,
      requestStream: false,
      responseType: InitiateStaticDepositUtxoRefundResponse,
      responseStream: false,
      options: {},
    },
    /**
     * DEPRECATED: This unified method is being split for better clarity and type safety
     *
     * For swap operations: Use spark_ssp_internal.initiate_static_deposit_utxo_swap()
     * For refund operations: Use initiate_static_deposit_utxo_refund()
     *
     * @deprecated
     */
    initiate_utxo_swap: {
      name: "initiate_utxo_swap",
      requestType: InitiateUtxoSwapRequest,
      requestStream: false,
      responseType: InitiateUtxoSwapResponse,
      responseStream: false,
      options: {},
    },
    exit_single_node_trees: {
      name: "exit_single_node_trees",
      requestType: ExitSingleNodeTreesRequest,
      requestStream: false,
      responseType: ExitSingleNodeTreesResponse,
      responseStream: false,
      options: {},
    },
    /**
     * The following endpoints enforce inclusion of Direct Transactions used
     * for unilateral exits
     */
    cooperative_exit_v2: {
      name: "cooperative_exit_v2",
      requestType: CooperativeExitRequest,
      requestStream: false,
      responseType: CooperativeExitResponse,
      responseStream: false,
      options: {},
    },
    extend_leaf_v2: {
      name: "extend_leaf_v2",
      requestType: ExtendLeafRequest,
      requestStream: false,
      responseType: ExtendLeafResponse,
      responseStream: false,
      options: {},
    },
    claim_transfer_sign_refunds_v2: {
      name: "claim_transfer_sign_refunds_v2",
      requestType: ClaimTransferSignRefundsRequest,
      requestStream: false,
      responseType: ClaimTransferSignRefundsResponse,
      responseStream: false,
      options: {},
    },
    finalize_node_signatures_v2: {
      name: "finalize_node_signatures_v2",
      requestType: FinalizeNodeSignaturesRequest,
      requestStream: false,
      responseType: FinalizeNodeSignaturesResponse,
      responseStream: false,
      options: {},
    },
    initiate_preimage_swap_v2: {
      name: "initiate_preimage_swap_v2",
      requestType: InitiatePreimageSwapRequest,
      requestStream: false,
      responseType: InitiatePreimageSwapResponse,
      responseStream: false,
      options: {},
    },
    start_leaf_swap_v2: {
      name: "start_leaf_swap_v2",
      requestType: StartTransferRequest,
      requestStream: false,
      responseType: StartTransferResponse,
      responseStream: false,
      options: {},
    },
    counter_leaf_swap_v2: {
      name: "counter_leaf_swap_v2",
      requestType: CounterLeafSwapRequest,
      requestStream: false,
      responseType: CounterLeafSwapResponse,
      responseStream: false,
      options: {},
    },
    start_transfer_v2: {
      name: "start_transfer_v2",
      requestType: StartTransferRequest,
      requestStream: false,
      responseType: StartTransferResponse,
      responseStream: false,
      options: {},
    },
    refresh_timelock_v2: {
      name: "refresh_timelock_v2",
      requestType: RefreshTimelockRequest,
      requestStream: false,
      responseType: RefreshTimelockResponse,
      responseStream: false,
      options: {},
    },
    get_utxos_for_address: {
      name: "get_utxos_for_address",
      requestType: GetUtxosForAddressRequest,
      requestStream: false,
      responseType: GetUtxosForAddressResponse,
      responseStream: false,
      options: {},
    },
    query_spark_invoices: {
      name: "query_spark_invoices",
      requestType: QuerySparkInvoicesRequest,
      requestStream: false,
      responseType: QuerySparkInvoicesResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface SparkServiceImplementation<CallContextExt = {}> {
  generate_deposit_address(
    request: GenerateDepositAddressRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateDepositAddressResponse>>;
  /** Generates a new static deposit address of the user or returns the existing one for the specified network. */
  generate_static_deposit_address(
    request: GenerateStaticDepositAddressRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateStaticDepositAddressResponse>>;
  start_deposit_tree_creation(
    request: StartDepositTreeCreationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartDepositTreeCreationResponse>>;
  /**
   * This is deprecated, please use start_deposit_tree_creation instead.
   *
   * @deprecated
   */
  start_tree_creation(
    request: StartTreeCreationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartTreeCreationResponse>>;
  finalize_node_signatures(
    request: FinalizeNodeSignaturesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FinalizeNodeSignaturesResponse>>;
  start_transfer(
    request: StartTransferRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartTransferResponse>>;
  /**
   * This is deprecated, please use finalize_transfer_with_transfer_package instead.
   *
   * @deprecated
   */
  finalize_transfer(
    request: FinalizeTransferRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FinalizeTransferResponse>>;
  finalize_transfer_with_transfer_package(
    request: FinalizeTransferWithTransferPackageRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FinalizeTransferResponse>>;
  cancel_transfer(
    request: CancelTransferRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CancelTransferResponse>>;
  query_pending_transfers(
    request: TransferFilter,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryTransfersResponse>>;
  query_all_transfers(
    request: TransferFilter,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryTransfersResponse>>;
  claim_transfer_tweak_keys(
    request: ClaimTransferTweakKeysRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  claim_transfer_sign_refunds(
    request: ClaimTransferSignRefundsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ClaimTransferSignRefundsResponse>>;
  store_preimage_share(
    request: StorePreimageShareRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  get_signing_commitments(
    request: GetSigningCommitmentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetSigningCommitmentsResponse>>;
  cooperative_exit(
    request: CooperativeExitRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CooperativeExitResponse>>;
  initiate_preimage_swap(
    request: InitiatePreimageSwapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<InitiatePreimageSwapResponse>>;
  provide_preimage(
    request: ProvidePreimageRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ProvidePreimageResponse>>;
  /**
   * This is the exact same as start_transfer, but expresses to the SO
   * this transfer is specifically for a leaf swap.
   */
  start_leaf_swap(
    request: StartTransferRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartTransferResponse>>;
  /**
   * This is deprecated, please use counter_leaf_swap instead.
   *
   * @deprecated
   */
  leaf_swap(
    request: CounterLeafSwapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CounterLeafSwapResponse>>;
  /**
   * This is the exact same as start_leaf_swap, but signs with
   * an adaptor public key after a counterparty has begun the swap via start_leaf_swap.
   */
  counter_leaf_swap(
    request: CounterLeafSwapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CounterLeafSwapResponse>>;
  refresh_timelock(
    request: RefreshTimelockRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RefreshTimelockResponse>>;
  extend_leaf(
    request: ExtendLeafRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ExtendLeafResponse>>;
  /**
   * Resets the timelocks for a leaf's transactions. Can be used to reset the
   * refund transaction timelock for a leaf (when the node transaction
   * timelock is still > 300) or reset the node and refund transaction
   * timelock. Returns an error if a leaf is not yet eligible to renew the
   * timelocks, see RenewLeafRequest for more details.
   */
  renew_leaf(request: RenewLeafRequest, context: CallContext & CallContextExt): Promise<DeepPartial<RenewLeafResponse>>;
  get_signing_operator_list(
    request: Empty,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetSigningOperatorListResponse>>;
  query_nodes(
    request: QueryNodesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryNodesResponse>>;
  query_nodes_distribution(
    request: QueryNodesDistributionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryNodesDistributionResponse>>;
  query_nodes_by_value(
    request: QueryNodesByValueRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryNodesByValueResponse>>;
  query_balance(
    request: QueryBalanceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryBalanceResponse>>;
  query_user_signed_refunds(
    request: QueryUserSignedRefundsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryUserSignedRefundsResponse>>;
  /** Token RPCs */
  start_token_transaction(
    request: StartTokenTransactionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartTokenTransactionResponse>>;
  sign_token_transaction(
    request: SignTokenTransactionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SignTokenTransactionResponse>>;
  finalize_token_transaction(
    request: FinalizeTokenTransactionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  freeze_tokens(
    request: FreezeTokensRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FreezeTokensResponse>>;
  query_token_outputs(
    request: QueryTokenOutputsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryTokenOutputsResponse>>;
  query_token_transactions(
    request: QueryTokenTransactionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryTokenTransactionsResponse>>;
  return_lightning_payment(
    request: ReturnLightningPaymentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  query_unused_deposit_addresses(
    request: QueryUnusedDepositAddressesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryUnusedDepositAddressesResponse>>;
  query_static_deposit_addresses(
    request: QueryStaticDepositAddressesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryStaticDepositAddressesResponse>>;
  subscribe_to_events(
    request: SubscribeToEventsRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<SubscribeToEventsResponse>>;
  /**
   * Signs the provided refund transaction which spends the UTXO from a static
   * deposit address. If successful, the UTXO will no longer be available to claim on
   * the Spark network, and the refund transaction must be broadcasted on L1 to claim
   * the funds. Returns an error if the UTXO has already been claimed.
   */
  initiate_static_deposit_utxo_refund(
    request: InitiateStaticDepositUtxoRefundRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<InitiateStaticDepositUtxoRefundResponse>>;
  /**
   * DEPRECATED: This unified method is being split for better clarity and type safety
   *
   * For swap operations: Use spark_ssp_internal.initiate_static_deposit_utxo_swap()
   * For refund operations: Use initiate_static_deposit_utxo_refund()
   *
   * @deprecated
   */
  initiate_utxo_swap(
    request: InitiateUtxoSwapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<InitiateUtxoSwapResponse>>;
  exit_single_node_trees(
    request: ExitSingleNodeTreesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ExitSingleNodeTreesResponse>>;
  /**
   * The following endpoints enforce inclusion of Direct Transactions used
   * for unilateral exits
   */
  cooperative_exit_v2(
    request: CooperativeExitRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CooperativeExitResponse>>;
  extend_leaf_v2(
    request: ExtendLeafRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ExtendLeafResponse>>;
  claim_transfer_sign_refunds_v2(
    request: ClaimTransferSignRefundsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ClaimTransferSignRefundsResponse>>;
  finalize_node_signatures_v2(
    request: FinalizeNodeSignaturesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FinalizeNodeSignaturesResponse>>;
  initiate_preimage_swap_v2(
    request: InitiatePreimageSwapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<InitiatePreimageSwapResponse>>;
  start_leaf_swap_v2(
    request: StartTransferRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartTransferResponse>>;
  counter_leaf_swap_v2(
    request: CounterLeafSwapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CounterLeafSwapResponse>>;
  start_transfer_v2(
    request: StartTransferRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartTransferResponse>>;
  refresh_timelock_v2(
    request: RefreshTimelockRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RefreshTimelockResponse>>;
  get_utxos_for_address(
    request: GetUtxosForAddressRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetUtxosForAddressResponse>>;
  query_spark_invoices(
    request: QuerySparkInvoicesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QuerySparkInvoicesResponse>>;
}

export interface SparkServiceClient<CallOptionsExt = {}> {
  generate_deposit_address(
    request: DeepPartial<GenerateDepositAddressRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateDepositAddressResponse>;
  /** Generates a new static deposit address of the user or returns the existing one for the specified network. */
  generate_static_deposit_address(
    request: DeepPartial<GenerateStaticDepositAddressRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateStaticDepositAddressResponse>;
  start_deposit_tree_creation(
    request: DeepPartial<StartDepositTreeCreationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartDepositTreeCreationResponse>;
  /**
   * This is deprecated, please use start_deposit_tree_creation instead.
   *
   * @deprecated
   */
  start_tree_creation(
    request: DeepPartial<StartTreeCreationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartTreeCreationResponse>;
  finalize_node_signatures(
    request: DeepPartial<FinalizeNodeSignaturesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FinalizeNodeSignaturesResponse>;
  start_transfer(
    request: DeepPartial<StartTransferRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartTransferResponse>;
  /**
   * This is deprecated, please use finalize_transfer_with_transfer_package instead.
   *
   * @deprecated
   */
  finalize_transfer(
    request: DeepPartial<FinalizeTransferRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FinalizeTransferResponse>;
  finalize_transfer_with_transfer_package(
    request: DeepPartial<FinalizeTransferWithTransferPackageRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FinalizeTransferResponse>;
  cancel_transfer(
    request: DeepPartial<CancelTransferRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CancelTransferResponse>;
  query_pending_transfers(
    request: DeepPartial<TransferFilter>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryTransfersResponse>;
  query_all_transfers(
    request: DeepPartial<TransferFilter>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryTransfersResponse>;
  claim_transfer_tweak_keys(
    request: DeepPartial<ClaimTransferTweakKeysRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  claim_transfer_sign_refunds(
    request: DeepPartial<ClaimTransferSignRefundsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ClaimTransferSignRefundsResponse>;
  store_preimage_share(
    request: DeepPartial<StorePreimageShareRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  get_signing_commitments(
    request: DeepPartial<GetSigningCommitmentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetSigningCommitmentsResponse>;
  cooperative_exit(
    request: DeepPartial<CooperativeExitRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CooperativeExitResponse>;
  initiate_preimage_swap(
    request: DeepPartial<InitiatePreimageSwapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<InitiatePreimageSwapResponse>;
  provide_preimage(
    request: DeepPartial<ProvidePreimageRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ProvidePreimageResponse>;
  /**
   * This is the exact same as start_transfer, but expresses to the SO
   * this transfer is specifically for a leaf swap.
   */
  start_leaf_swap(
    request: DeepPartial<StartTransferRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartTransferResponse>;
  /**
   * This is deprecated, please use counter_leaf_swap instead.
   *
   * @deprecated
   */
  leaf_swap(
    request: DeepPartial<CounterLeafSwapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CounterLeafSwapResponse>;
  /**
   * This is the exact same as start_leaf_swap, but signs with
   * an adaptor public key after a counterparty has begun the swap via start_leaf_swap.
   */
  counter_leaf_swap(
    request: DeepPartial<CounterLeafSwapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CounterLeafSwapResponse>;
  refresh_timelock(
    request: DeepPartial<RefreshTimelockRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RefreshTimelockResponse>;
  extend_leaf(
    request: DeepPartial<ExtendLeafRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ExtendLeafResponse>;
  /**
   * Resets the timelocks for a leaf's transactions. Can be used to reset the
   * refund transaction timelock for a leaf (when the node transaction
   * timelock is still > 300) or reset the node and refund transaction
   * timelock. Returns an error if a leaf is not yet eligible to renew the
   * timelocks, see RenewLeafRequest for more details.
   */
  renew_leaf(
    request: DeepPartial<RenewLeafRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RenewLeafResponse>;
  get_signing_operator_list(
    request: DeepPartial<Empty>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetSigningOperatorListResponse>;
  query_nodes(
    request: DeepPartial<QueryNodesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryNodesResponse>;
  query_nodes_distribution(
    request: DeepPartial<QueryNodesDistributionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryNodesDistributionResponse>;
  query_nodes_by_value(
    request: DeepPartial<QueryNodesByValueRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryNodesByValueResponse>;
  query_balance(
    request: DeepPartial<QueryBalanceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryBalanceResponse>;
  query_user_signed_refunds(
    request: DeepPartial<QueryUserSignedRefundsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryUserSignedRefundsResponse>;
  /** Token RPCs */
  start_token_transaction(
    request: DeepPartial<StartTokenTransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartTokenTransactionResponse>;
  sign_token_transaction(
    request: DeepPartial<SignTokenTransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SignTokenTransactionResponse>;
  finalize_token_transaction(
    request: DeepPartial<FinalizeTokenTransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  freeze_tokens(
    request: DeepPartial<FreezeTokensRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FreezeTokensResponse>;
  query_token_outputs(
    request: DeepPartial<QueryTokenOutputsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryTokenOutputsResponse>;
  query_token_transactions(
    request: DeepPartial<QueryTokenTransactionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryTokenTransactionsResponse>;
  return_lightning_payment(
    request: DeepPartial<ReturnLightningPaymentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  query_unused_deposit_addresses(
    request: DeepPartial<QueryUnusedDepositAddressesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryUnusedDepositAddressesResponse>;
  query_static_deposit_addresses(
    request: DeepPartial<QueryStaticDepositAddressesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryStaticDepositAddressesResponse>;
  subscribe_to_events(
    request: DeepPartial<SubscribeToEventsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<SubscribeToEventsResponse>;
  /**
   * Signs the provided refund transaction which spends the UTXO from a static
   * deposit address. If successful, the UTXO will no longer be available to claim on
   * the Spark network, and the refund transaction must be broadcasted on L1 to claim
   * the funds. Returns an error if the UTXO has already been claimed.
   */
  initiate_static_deposit_utxo_refund(
    request: DeepPartial<InitiateStaticDepositUtxoRefundRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<InitiateStaticDepositUtxoRefundResponse>;
  /**
   * DEPRECATED: This unified method is being split for better clarity and type safety
   *
   * For swap operations: Use spark_ssp_internal.initiate_static_deposit_utxo_swap()
   * For refund operations: Use initiate_static_deposit_utxo_refund()
   *
   * @deprecated
   */
  initiate_utxo_swap(
    request: DeepPartial<InitiateUtxoSwapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<InitiateUtxoSwapResponse>;
  exit_single_node_trees(
    request: DeepPartial<ExitSingleNodeTreesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ExitSingleNodeTreesResponse>;
  /**
   * The following endpoints enforce inclusion of Direct Transactions used
   * for unilateral exits
   */
  cooperative_exit_v2(
    request: DeepPartial<CooperativeExitRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CooperativeExitResponse>;
  extend_leaf_v2(
    request: DeepPartial<ExtendLeafRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ExtendLeafResponse>;
  claim_transfer_sign_refunds_v2(
    request: DeepPartial<ClaimTransferSignRefundsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ClaimTransferSignRefundsResponse>;
  finalize_node_signatures_v2(
    request: DeepPartial<FinalizeNodeSignaturesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FinalizeNodeSignaturesResponse>;
  initiate_preimage_swap_v2(
    request: DeepPartial<InitiatePreimageSwapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<InitiatePreimageSwapResponse>;
  start_leaf_swap_v2(
    request: DeepPartial<StartTransferRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartTransferResponse>;
  counter_leaf_swap_v2(
    request: DeepPartial<CounterLeafSwapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CounterLeafSwapResponse>;
  start_transfer_v2(
    request: DeepPartial<StartTransferRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartTransferResponse>;
  refresh_timelock_v2(
    request: DeepPartial<RefreshTimelockRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RefreshTimelockResponse>;
  get_utxos_for_address(
    request: DeepPartial<GetUtxosForAddressRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetUtxosForAddressResponse>;
  query_spark_invoices(
    request: DeepPartial<QuerySparkInvoicesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QuerySparkInvoicesResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
